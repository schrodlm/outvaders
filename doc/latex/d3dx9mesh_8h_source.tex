\hypertarget{d3dx9mesh_8h_source}{}\doxysection{d3dx9mesh.\+h}
\label{d3dx9mesh_8h_source}\index{src/lib/dx/Include/d3dx9mesh.h@{src/lib/dx/Include/d3dx9mesh.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 }
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{//  Copyright (C) Microsoft Corporation.  All Rights Reserved.}}
\DoxyCodeLine{4 \textcolor{comment}{//}}
\DoxyCodeLine{5 \textcolor{comment}{//  File:       d3dx9mesh.h}}
\DoxyCodeLine{6 \textcolor{comment}{//  Content:    D3DX mesh types and functions}}
\DoxyCodeLine{7 \textcolor{comment}{//}}
\DoxyCodeLine{9 \textcolor{comment}{}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#include "{}d3dx9.h"{}}}
\DoxyCodeLine{11 }
\DoxyCodeLine{12 \textcolor{preprocessor}{\#ifndef \_\_D3DX9MESH\_H\_\_}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#define \_\_D3DX9MESH\_H\_\_}}
\DoxyCodeLine{14 }
\DoxyCodeLine{15 \textcolor{comment}{// \{7ED943DD-\/52E8-\/40b5-\/A8D8-\/76685C406330\}}}
\DoxyCodeLine{16 DEFINE\_GUID(IID\_ID3DXBaseMesh, }
\DoxyCodeLine{17 0x7ed943dd, 0x52e8, 0x40b5, 0xa8, 0xd8, 0x76, 0x68, 0x5c, 0x40, 0x63, 0x30);}
\DoxyCodeLine{18 }
\DoxyCodeLine{19 \textcolor{comment}{// \{4020E5C2-\/1403-\/4929-\/883F-\/E2E849FAC195\}}}
\DoxyCodeLine{20 DEFINE\_GUID(IID\_ID3DXMesh, }
\DoxyCodeLine{21 0x4020e5c2, 0x1403, 0x4929, 0x88, 0x3f, 0xe2, 0xe8, 0x49, 0xfa, 0xc1, 0x95);}
\DoxyCodeLine{22 }
\DoxyCodeLine{23 \textcolor{comment}{// \{8875769A-\/D579-\/4088-\/AAEB-\/534D1AD84E96\}}}
\DoxyCodeLine{24 DEFINE\_GUID(IID\_ID3DXPMesh, }
\DoxyCodeLine{25 0x8875769a, 0xd579, 0x4088, 0xaa, 0xeb, 0x53, 0x4d, 0x1a, 0xd8, 0x4e, 0x96);}
\DoxyCodeLine{26 }
\DoxyCodeLine{27 \textcolor{comment}{// \{667EA4C7-\/F1CD-\/4386-\/B523-\/7C0290B83CC5\}}}
\DoxyCodeLine{28 DEFINE\_GUID(IID\_ID3DXSPMesh, }
\DoxyCodeLine{29 0x667ea4c7, 0xf1cd, 0x4386, 0xb5, 0x23, 0x7c, 0x2, 0x90, 0xb8, 0x3c, 0xc5);}
\DoxyCodeLine{30 }
\DoxyCodeLine{31 \textcolor{comment}{// \{11EAA540-\/F9A6-\/4d49-\/AE6A-\/E19221F70CC4\}}}
\DoxyCodeLine{32 DEFINE\_GUID(IID\_ID3DXSkinInfo, }
\DoxyCodeLine{33 0x11eaa540, 0xf9a6, 0x4d49, 0xae, 0x6a, 0xe1, 0x92, 0x21, 0xf7, 0xc, 0xc4);}
\DoxyCodeLine{34 }
\DoxyCodeLine{35 \textcolor{comment}{// \{3CE6CC22-\/DBF2-\/44f4-\/894D-\/F9C34A337139\}}}
\DoxyCodeLine{36 DEFINE\_GUID(IID\_ID3DXPatchMesh, }
\DoxyCodeLine{37 0x3ce6cc22, 0xdbf2, 0x44f4, 0x89, 0x4d, 0xf9, 0xc3, 0x4a, 0x33, 0x71, 0x39);}
\DoxyCodeLine{38 }
\DoxyCodeLine{39 \textcolor{comment}{//patch mesh can be quads or tris}}
\DoxyCodeLine{40 \textcolor{keyword}{typedef} \textcolor{keyword}{enum} \_D3DXPATCHMESHTYPE \{}
\DoxyCodeLine{41     D3DXPATCHMESH\_RECT   = 0x001,}
\DoxyCodeLine{42     D3DXPATCHMESH\_TRI    = 0x002,}
\DoxyCodeLine{43     D3DXPATCHMESH\_NPATCH = 0x003,}
\DoxyCodeLine{44 }
\DoxyCodeLine{45     D3DXPATCHMESH\_FORCE\_DWORD    = 0x7fffffff, \textcolor{comment}{/* force 32-\/bit size enum */}}
\DoxyCodeLine{46 \} D3DXPATCHMESHTYPE;}
\DoxyCodeLine{47 }
\DoxyCodeLine{48 \textcolor{comment}{// Mesh options -\/ lower 3 bytes only, upper byte used by \_D3DXMESHOPT option flags}}
\DoxyCodeLine{49 \textcolor{keyword}{enum} \_D3DXMESH \{}
\DoxyCodeLine{50     D3DXMESH\_32BIT                  = 0x001, \textcolor{comment}{// If set, then use 32 bit indices, if not set use 16 bit indices.}}
\DoxyCodeLine{51     D3DXMESH\_DONOTCLIP              = 0x002, \textcolor{comment}{// Use D3DUSAGE\_DONOTCLIP for VB \& IB.}}
\DoxyCodeLine{52     D3DXMESH\_POINTS                 = 0x004, \textcolor{comment}{// Use D3DUSAGE\_POINTS for VB \& IB. }}
\DoxyCodeLine{53     D3DXMESH\_RTPATCHES              = 0x008, \textcolor{comment}{// Use D3DUSAGE\_RTPATCHES for VB \& IB. }}
\DoxyCodeLine{54     D3DXMESH\_NPATCHES               = 0x4000,\textcolor{comment}{// Use D3DUSAGE\_NPATCHES for VB \& IB. }}
\DoxyCodeLine{55     D3DXMESH\_VB\_SYSTEMMEM           = 0x010, \textcolor{comment}{// Use D3DPOOL\_SYSTEMMEM for VB. Overrides D3DXMESH\_MANAGEDVERTEXBUFFER}}
\DoxyCodeLine{56     D3DXMESH\_VB\_MANAGED             = 0x020, \textcolor{comment}{// Use D3DPOOL\_MANAGED for VB. }}
\DoxyCodeLine{57     D3DXMESH\_VB\_WRITEONLY           = 0x040, \textcolor{comment}{// Use D3DUSAGE\_WRITEONLY for VB.}}
\DoxyCodeLine{58     D3DXMESH\_VB\_DYNAMIC             = 0x080, \textcolor{comment}{// Use D3DUSAGE\_DYNAMIC for VB.}}
\DoxyCodeLine{59     D3DXMESH\_VB\_SOFTWAREPROCESSING = 0x8000, \textcolor{comment}{// Use D3DUSAGE\_SOFTWAREPROCESSING for VB.}}
\DoxyCodeLine{60     D3DXMESH\_IB\_SYSTEMMEM           = 0x100, \textcolor{comment}{// Use D3DPOOL\_SYSTEMMEM for IB. Overrides D3DXMESH\_MANAGEDINDEXBUFFER}}
\DoxyCodeLine{61     D3DXMESH\_IB\_MANAGED             = 0x200, \textcolor{comment}{// Use D3DPOOL\_MANAGED for IB.}}
\DoxyCodeLine{62     D3DXMESH\_IB\_WRITEONLY           = 0x400, \textcolor{comment}{// Use D3DUSAGE\_WRITEONLY for IB.}}
\DoxyCodeLine{63     D3DXMESH\_IB\_DYNAMIC             = 0x800, \textcolor{comment}{// Use D3DUSAGE\_DYNAMIC for IB.}}
\DoxyCodeLine{64     D3DXMESH\_IB\_SOFTWAREPROCESSING= 0x10000, \textcolor{comment}{// Use D3DUSAGE\_SOFTWAREPROCESSING for IB.}}
\DoxyCodeLine{65 }
\DoxyCodeLine{66     D3DXMESH\_VB\_SHARE               = 0x1000, \textcolor{comment}{// Valid for Clone* calls only, forces cloned mesh/pmesh to share vertex buffer}}
\DoxyCodeLine{67 }
\DoxyCodeLine{68     D3DXMESH\_USEHWONLY              = 0x2000, \textcolor{comment}{// Valid for ID3DXSkinInfo::ConvertToBlendedMesh}}
\DoxyCodeLine{69 }
\DoxyCodeLine{70     \textcolor{comment}{// Helper options}}
\DoxyCodeLine{71     D3DXMESH\_SYSTEMMEM              = 0x110, \textcolor{comment}{// D3DXMESH\_VB\_SYSTEMMEM | D3DXMESH\_IB\_SYSTEMMEM}}
\DoxyCodeLine{72     D3DXMESH\_MANAGED                = 0x220, \textcolor{comment}{// D3DXMESH\_VB\_MANAGED | D3DXMESH\_IB\_MANAGED}}
\DoxyCodeLine{73     D3DXMESH\_WRITEONLY              = 0x440, \textcolor{comment}{// D3DXMESH\_VB\_WRITEONLY | D3DXMESH\_IB\_WRITEONLY}}
\DoxyCodeLine{74     D3DXMESH\_DYNAMIC                = 0x880, \textcolor{comment}{// D3DXMESH\_VB\_DYNAMIC | D3DXMESH\_IB\_DYNAMIC}}
\DoxyCodeLine{75     D3DXMESH\_SOFTWAREPROCESSING   = 0x18000, \textcolor{comment}{// D3DXMESH\_VB\_SOFTWAREPROCESSING | D3DXMESH\_IB\_SOFTWAREPROCESSING}}
\DoxyCodeLine{76 }
\DoxyCodeLine{77 \};}
\DoxyCodeLine{78 }
\DoxyCodeLine{79 \textcolor{comment}{//patch mesh options}}
\DoxyCodeLine{80 \textcolor{keyword}{enum} \_D3DXPATCHMESH \{}
\DoxyCodeLine{81     D3DXPATCHMESH\_DEFAULT = 000,}
\DoxyCodeLine{82 \};}
\DoxyCodeLine{83 \textcolor{comment}{// option field values for specifying min value in D3DXGeneratePMesh and D3DXSimplifyMesh}}
\DoxyCodeLine{84 \textcolor{keyword}{enum} \_D3DXMESHSIMP}
\DoxyCodeLine{85 \{}
\DoxyCodeLine{86     D3DXMESHSIMP\_VERTEX   = 0x1,}
\DoxyCodeLine{87     D3DXMESHSIMP\_FACE     = 0x2,}
\DoxyCodeLine{88 }
\DoxyCodeLine{89 \};}
\DoxyCodeLine{90 }
\DoxyCodeLine{91 \textcolor{keyword}{typedef} \textcolor{keyword}{enum} \_D3DXCLEANTYPE \{}
\DoxyCodeLine{92     D3DXCLEAN\_BACKFACING    = 0x00000001,}
\DoxyCodeLine{93     D3DXCLEAN\_BOWTIES       = 0x00000002,}
\DoxyCodeLine{94     }
\DoxyCodeLine{95     \textcolor{comment}{// Helper options}}
\DoxyCodeLine{96     D3DXCLEAN\_SKINNING      = D3DXCLEAN\_BACKFACING, \textcolor{comment}{// Bowtie cleaning modifies geometry and breaks skinning}}
\DoxyCodeLine{97     D3DXCLEAN\_OPTIMIZATION  = D3DXCLEAN\_BACKFACING,}
\DoxyCodeLine{98     D3DXCLEAN\_SIMPLIFICATION= D3DXCLEAN\_BACKFACING | D3DXCLEAN\_BOWTIES, }
\DoxyCodeLine{99 \} D3DXCLEANTYPE;}
\DoxyCodeLine{100 }
\DoxyCodeLine{101 \textcolor{keyword}{enum} \_MAX\_FVF\_DECL\_SIZE}
\DoxyCodeLine{102 \{}
\DoxyCodeLine{103     MAX\_FVF\_DECL\_SIZE = MAXD3DDECLLENGTH + 1 \textcolor{comment}{// +1 for END}}
\DoxyCodeLine{104 \};}
\DoxyCodeLine{105 }
\DoxyCodeLine{106 \textcolor{keyword}{typedef} \textcolor{keyword}{enum} \_D3DXTANGENT}
\DoxyCodeLine{107 \{}
\DoxyCodeLine{108     D3DXTANGENT\_WRAP\_U =                    0x01,}
\DoxyCodeLine{109     D3DXTANGENT\_WRAP\_V =                    0x02,}
\DoxyCodeLine{110     D3DXTANGENT\_WRAP\_UV =                   0x03,}
\DoxyCodeLine{111     D3DXTANGENT\_DONT\_NORMALIZE\_PARTIALS =   0x04,}
\DoxyCodeLine{112     D3DXTANGENT\_DONT\_ORTHOGONALIZE =        0x08,}
\DoxyCodeLine{113     D3DXTANGENT\_ORTHOGONALIZE\_FROM\_V =      0x010,}
\DoxyCodeLine{114     D3DXTANGENT\_ORTHOGONALIZE\_FROM\_U =      0x020,}
\DoxyCodeLine{115     D3DXTANGENT\_WEIGHT\_BY\_AREA =            0x040,}
\DoxyCodeLine{116     D3DXTANGENT\_WEIGHT\_EQUAL =              0x080,}
\DoxyCodeLine{117     D3DXTANGENT\_WIND\_CW =                   0x0100,}
\DoxyCodeLine{118     D3DXTANGENT\_CALCULATE\_NORMALS =         0x0200,}
\DoxyCodeLine{119     D3DXTANGENT\_GENERATE\_IN\_PLACE =         0x0400,}
\DoxyCodeLine{120 \} D3DXTANGENT;}
\DoxyCodeLine{121 }
\DoxyCodeLine{122 \textcolor{comment}{// D3DXIMT\_WRAP\_U means the texture wraps in the U direction}}
\DoxyCodeLine{123 \textcolor{comment}{// D3DXIMT\_WRAP\_V means the texture wraps in the V direction}}
\DoxyCodeLine{124 \textcolor{comment}{// D3DXIMT\_WRAP\_UV means the texture wraps in both directions}}
\DoxyCodeLine{125 \textcolor{keyword}{typedef} \textcolor{keyword}{enum} \_D3DXIMT}
\DoxyCodeLine{126 \{}
\DoxyCodeLine{127     D3DXIMT\_WRAP\_U =                    0x01,}
\DoxyCodeLine{128     D3DXIMT\_WRAP\_V =                    0x02,}
\DoxyCodeLine{129     D3DXIMT\_WRAP\_UV =                   0x03,}
\DoxyCodeLine{130 \} D3DXIMT;}
\DoxyCodeLine{131 }
\DoxyCodeLine{132 }
\DoxyCodeLine{133 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }ID3DXBaseMesh *LPD3DXBASEMESH;}
\DoxyCodeLine{134 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }ID3DXMesh *LPD3DXMESH;}
\DoxyCodeLine{135 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }ID3DXPMesh *LPD3DXPMESH;}
\DoxyCodeLine{136 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }ID3DXSPMesh *LPD3DXSPMESH;}
\DoxyCodeLine{137 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }ID3DXSkinInfo *LPD3DXSKININFO;}
\DoxyCodeLine{138 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }ID3DXPatchMesh *LPD3DXPATCHMESH;}
\DoxyCodeLine{139 \textcolor{keyword}{typedef} \textcolor{keyword}{interface }ID3DXTextureGutterHelper *LPD3DXTEXTUREGUTTERHELPER;}
\DoxyCodeLine{140 \textcolor{keyword}{typedef} \textcolor{keyword}{interface }ID3DXPRTBuffer *LPD3DXPRTBUFFER;}
\DoxyCodeLine{141 }
\DoxyCodeLine{142 }
\DoxyCodeLine{143 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{struct___d3_d_x_a_t_t_r_i_b_u_t_e_r_a_n_g_e}{\_D3DXATTRIBUTERANGE}}}
\DoxyCodeLine{144 \{}
\DoxyCodeLine{145     DWORD AttribId;}
\DoxyCodeLine{146     DWORD FaceStart;}
\DoxyCodeLine{147     DWORD FaceCount;}
\DoxyCodeLine{148     DWORD VertexStart;}
\DoxyCodeLine{149     DWORD VertexCount;}
\DoxyCodeLine{150 \} \mbox{\hyperlink{struct___d3_d_x_a_t_t_r_i_b_u_t_e_r_a_n_g_e}{D3DXATTRIBUTERANGE}};}
\DoxyCodeLine{151 }
\DoxyCodeLine{152 \textcolor{keyword}{typedef} \mbox{\hyperlink{struct___d3_d_x_a_t_t_r_i_b_u_t_e_r_a_n_g_e}{D3DXATTRIBUTERANGE}}* \mbox{\hyperlink{struct___d3_d_x_a_t_t_r_i_b_u_t_e_r_a_n_g_e}{LPD3DXATTRIBUTERANGE}};}
\DoxyCodeLine{153 }
\DoxyCodeLine{154 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{struct___d3_d_x_m_a_t_e_r_i_a_l}{\_D3DXMATERIAL}}}
\DoxyCodeLine{155 \{}
\DoxyCodeLine{156     \mbox{\hyperlink{struct___d3_d_m_a_t_e_r_i_a_l9}{D3DMATERIAL9}}  MatD3D;}
\DoxyCodeLine{157     LPSTR         pTextureFilename;}
\DoxyCodeLine{158 \} \mbox{\hyperlink{struct___d3_d_x_m_a_t_e_r_i_a_l}{D3DXMATERIAL}};}
\DoxyCodeLine{159 \textcolor{keyword}{typedef} \mbox{\hyperlink{struct___d3_d_x_m_a_t_e_r_i_a_l}{D3DXMATERIAL}} *\mbox{\hyperlink{struct___d3_d_x_m_a_t_e_r_i_a_l}{LPD3DXMATERIAL}};}
\DoxyCodeLine{160 }
\DoxyCodeLine{161 \textcolor{keyword}{typedef} \textcolor{keyword}{enum} \_D3DXEFFECTDEFAULTTYPE}
\DoxyCodeLine{162 \{}
\DoxyCodeLine{163     D3DXEDT\_STRING = 0x1,       \textcolor{comment}{// pValue points to a null terminated ASCII string }}
\DoxyCodeLine{164     D3DXEDT\_FLOATS = 0x2,       \textcolor{comment}{// pValue points to an array of floats -\/ number of floats is NumBytes / sizeof(float)}}
\DoxyCodeLine{165     D3DXEDT\_DWORD  = 0x3,       \textcolor{comment}{// pValue points to a DWORD}}
\DoxyCodeLine{166 }
\DoxyCodeLine{167     D3DXEDT\_FORCEDWORD = 0x7fffffff}
\DoxyCodeLine{168 \} D3DXEFFECTDEFAULTTYPE;}
\DoxyCodeLine{169 }
\DoxyCodeLine{170 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{struct___d3_d_x_e_f_f_e_c_t_d_e_f_a_u_l_t}{\_D3DXEFFECTDEFAULT}}}
\DoxyCodeLine{171 \{}
\DoxyCodeLine{172     LPSTR                 pParamName;}
\DoxyCodeLine{173     D3DXEFFECTDEFAULTTYPE Type;           \textcolor{comment}{// type of the data pointed to by pValue}}
\DoxyCodeLine{174     DWORD                 NumBytes;       \textcolor{comment}{// size in bytes of the data pointed to by pValue}}
\DoxyCodeLine{175     LPVOID                pValue;         \textcolor{comment}{// data for the default of the effect}}
\DoxyCodeLine{176 \} \mbox{\hyperlink{struct___d3_d_x_e_f_f_e_c_t_d_e_f_a_u_l_t}{D3DXEFFECTDEFAULT}}, *\mbox{\hyperlink{struct___d3_d_x_e_f_f_e_c_t_d_e_f_a_u_l_t}{LPD3DXEFFECTDEFAULT}};}
\DoxyCodeLine{177 }
\DoxyCodeLine{178 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{struct___d3_d_x_e_f_f_e_c_t_i_n_s_t_a_n_c_e}{\_D3DXEFFECTINSTANCE}}}
\DoxyCodeLine{179 \{}
\DoxyCodeLine{180     LPSTR               pEffectFilename;}
\DoxyCodeLine{181     DWORD               NumDefaults;}
\DoxyCodeLine{182     \mbox{\hyperlink{struct___d3_d_x_e_f_f_e_c_t_d_e_f_a_u_l_t}{LPD3DXEFFECTDEFAULT}} pDefaults;}
\DoxyCodeLine{183 \} \mbox{\hyperlink{struct___d3_d_x_e_f_f_e_c_t_i_n_s_t_a_n_c_e}{D3DXEFFECTINSTANCE}}, *\mbox{\hyperlink{struct___d3_d_x_e_f_f_e_c_t_i_n_s_t_a_n_c_e}{LPD3DXEFFECTINSTANCE}};}
\DoxyCodeLine{184 }
\DoxyCodeLine{185 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{struct___d3_d_x_a_t_t_r_i_b_u_t_e_w_e_i_g_h_t_s}{\_D3DXATTRIBUTEWEIGHTS}}}
\DoxyCodeLine{186 \{}
\DoxyCodeLine{187     FLOAT Position;}
\DoxyCodeLine{188     FLOAT Boundary;}
\DoxyCodeLine{189     FLOAT Normal;}
\DoxyCodeLine{190     FLOAT Diffuse;}
\DoxyCodeLine{191     FLOAT Specular;}
\DoxyCodeLine{192     FLOAT Texcoord[8];}
\DoxyCodeLine{193     FLOAT Tangent;}
\DoxyCodeLine{194     FLOAT Binormal;}
\DoxyCodeLine{195 \} \mbox{\hyperlink{struct___d3_d_x_a_t_t_r_i_b_u_t_e_w_e_i_g_h_t_s}{D3DXATTRIBUTEWEIGHTS}}, *\mbox{\hyperlink{struct___d3_d_x_a_t_t_r_i_b_u_t_e_w_e_i_g_h_t_s}{LPD3DXATTRIBUTEWEIGHTS}};}
\DoxyCodeLine{196 }
\DoxyCodeLine{197 \textcolor{keyword}{enum} \_D3DXWELDEPSILONSFLAGS}
\DoxyCodeLine{198 \{}
\DoxyCodeLine{199     D3DXWELDEPSILONS\_WELDALL             = 0x1,  \textcolor{comment}{// weld all vertices marked by adjacency as being overlapping}}
\DoxyCodeLine{200 }
\DoxyCodeLine{201     D3DXWELDEPSILONS\_WELDPARTIALMATCHES  = 0x2,  \textcolor{comment}{// if a given vertex component is within epsilon, modify partial matched }}
\DoxyCodeLine{202                                                     \textcolor{comment}{// vertices so that both components identical AND if all components "{}equal"{}}}
\DoxyCodeLine{203                                                     \textcolor{comment}{// remove one of the vertices}}
\DoxyCodeLine{204     D3DXWELDEPSILONS\_DONOTREMOVEVERTICES = 0x4,  \textcolor{comment}{// instructs weld to only allow modifications to vertices and not removal}}
\DoxyCodeLine{205                                                     \textcolor{comment}{// ONLY valid if D3DXWELDEPSILONS\_WELDPARTIALMATCHES is set}}
\DoxyCodeLine{206                                                     \textcolor{comment}{// useful to modify vertices to be equal, but not allow vertices to be removed}}
\DoxyCodeLine{207 }
\DoxyCodeLine{208     D3DXWELDEPSILONS\_DONOTSPLIT          = 0x8,  \textcolor{comment}{// instructs weld to specify the D3DXMESHOPT\_DONOTSPLIT flag when doing an Optimize(ATTR\_SORT)}}
\DoxyCodeLine{209                                                     \textcolor{comment}{// if this flag is not set, all vertices that are in separate attribute groups}}
\DoxyCodeLine{210                                                     \textcolor{comment}{// will remain split and not welded.  Setting this flag can slow down software vertex processing}}
\DoxyCodeLine{211 }
\DoxyCodeLine{212 \};}
\DoxyCodeLine{213 }
\DoxyCodeLine{214 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{struct___d3_d_x_w_e_l_d_e_p_s_i_l_o_n_s}{\_D3DXWELDEPSILONS}}}
\DoxyCodeLine{215 \{}
\DoxyCodeLine{216     FLOAT Position;                 \textcolor{comment}{// NOTE: This does NOT replace the epsilon in GenerateAdjacency}}
\DoxyCodeLine{217                                             \textcolor{comment}{// in general, it should be the same value or greater than the one passed to GeneratedAdjacency}}
\DoxyCodeLine{218     FLOAT BlendWeights;}
\DoxyCodeLine{219     FLOAT Normal;}
\DoxyCodeLine{220     FLOAT PSize;}
\DoxyCodeLine{221     FLOAT Specular;}
\DoxyCodeLine{222     FLOAT Diffuse;}
\DoxyCodeLine{223     FLOAT Texcoord[8];}
\DoxyCodeLine{224     FLOAT Tangent;}
\DoxyCodeLine{225     FLOAT Binormal;}
\DoxyCodeLine{226     FLOAT TessFactor;}
\DoxyCodeLine{227 \} \mbox{\hyperlink{struct___d3_d_x_w_e_l_d_e_p_s_i_l_o_n_s}{D3DXWELDEPSILONS}};}
\DoxyCodeLine{228 }
\DoxyCodeLine{229 \textcolor{keyword}{typedef} \mbox{\hyperlink{struct___d3_d_x_w_e_l_d_e_p_s_i_l_o_n_s}{D3DXWELDEPSILONS}}* \mbox{\hyperlink{struct___d3_d_x_w_e_l_d_e_p_s_i_l_o_n_s}{LPD3DXWELDEPSILONS}};}
\DoxyCodeLine{230 }
\DoxyCodeLine{231 }
\DoxyCodeLine{232 \textcolor{preprocessor}{\#undef INTERFACE}}
\DoxyCodeLine{233 \textcolor{preprocessor}{\#define INTERFACE ID3DXBaseMesh}}
\DoxyCodeLine{234 }
\DoxyCodeLine{235 DECLARE\_INTERFACE\_(ID3DXBaseMesh, IUnknown)}
\DoxyCodeLine{236 \{}
\DoxyCodeLine{237     \textcolor{comment}{// IUnknown}}
\DoxyCodeLine{238     STDMETHOD(QueryInterface)(THIS\_ REFIID iid, LPVOID *ppv) PURE;}
\DoxyCodeLine{239     STDMETHOD\_(ULONG, AddRef)(THIS) PURE;}
\DoxyCodeLine{240     STDMETHOD\_(ULONG, Release)(THIS) PURE;}
\DoxyCodeLine{241 }
\DoxyCodeLine{242     \textcolor{comment}{// ID3DXBaseMesh}}
\DoxyCodeLine{243     STDMETHOD(DrawSubset)(THIS\_ DWORD AttribId) PURE;}
\DoxyCodeLine{244     STDMETHOD\_(DWORD, GetNumFaces)(THIS) PURE;}
\DoxyCodeLine{245     STDMETHOD\_(DWORD, GetNumVertices)(THIS) PURE;}
\DoxyCodeLine{246     STDMETHOD\_(DWORD, GetFVF)(THIS) PURE;}
\DoxyCodeLine{247     STDMETHOD(GetDeclaration)(THIS\_ \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} Declaration[MAX\_FVF\_DECL\_SIZE]) PURE;}
\DoxyCodeLine{248     STDMETHOD\_(DWORD, GetNumBytesPerVertex)(THIS) PURE;}
\DoxyCodeLine{249     STDMETHOD\_(DWORD, GetOptions)(THIS) PURE;}
\DoxyCodeLine{250     STDMETHOD(GetDevice)(THIS\_ LPDIRECT3DDEVICE9* ppDevice) PURE;}
\DoxyCodeLine{251     STDMETHOD(CloneMeshFVF)(THIS\_ DWORD Options, }
\DoxyCodeLine{252                 DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;}
\DoxyCodeLine{253     STDMETHOD(CloneMesh)(THIS\_ DWORD Options, }
\DoxyCodeLine{254                 CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;}
\DoxyCodeLine{255     STDMETHOD(GetVertexBuffer)(THIS\_ LPDIRECT3DVERTEXBUFFER9* ppVB) PURE;}
\DoxyCodeLine{256     STDMETHOD(GetIndexBuffer)(THIS\_ LPDIRECT3DINDEXBUFFER9* ppIB) PURE;}
\DoxyCodeLine{257     STDMETHOD(LockVertexBuffer)(THIS\_ DWORD Flags, LPVOID *ppData) PURE;}
\DoxyCodeLine{258     STDMETHOD(UnlockVertexBuffer)(THIS) PURE;}
\DoxyCodeLine{259     STDMETHOD(LockIndexBuffer)(THIS\_ DWORD Flags, LPVOID *ppData) PURE;}
\DoxyCodeLine{260     STDMETHOD(UnlockIndexBuffer)(THIS) PURE;}
\DoxyCodeLine{261     STDMETHOD(GetAttributeTable)(}
\DoxyCodeLine{262                 THIS\_ \mbox{\hyperlink{struct___d3_d_x_a_t_t_r_i_b_u_t_e_r_a_n_g_e}{D3DXATTRIBUTERANGE}} *pAttribTable, DWORD* pAttribTableSize) PURE;}
\DoxyCodeLine{263 }
\DoxyCodeLine{264     STDMETHOD(ConvertPointRepsToAdjacency)(THIS\_ CONST DWORD* pPRep, DWORD* pAdjacency) PURE;}
\DoxyCodeLine{265     STDMETHOD(ConvertAdjacencyToPointReps)(THIS\_ CONST DWORD* pAdjacency, DWORD* pPRep) PURE;}
\DoxyCodeLine{266     STDMETHOD(GenerateAdjacency)(THIS\_ FLOAT Epsilon, DWORD* pAdjacency) PURE;}
\DoxyCodeLine{267 }
\DoxyCodeLine{268     STDMETHOD(UpdateSemantics)(THIS\_ \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} Declaration[MAX\_FVF\_DECL\_SIZE]) PURE;}
\DoxyCodeLine{269 \};}
\DoxyCodeLine{270 }
\DoxyCodeLine{271 }
\DoxyCodeLine{272 \textcolor{preprocessor}{\#undef INTERFACE}}
\DoxyCodeLine{273 \textcolor{preprocessor}{\#define INTERFACE ID3DXMesh}}
\DoxyCodeLine{274 }
\DoxyCodeLine{275 DECLARE\_INTERFACE\_(ID3DXMesh, ID3DXBaseMesh)}
\DoxyCodeLine{276 \{}
\DoxyCodeLine{277     \textcolor{comment}{// IUnknown}}
\DoxyCodeLine{278     STDMETHOD(QueryInterface)(THIS\_ REFIID iid, LPVOID *ppv) PURE;}
\DoxyCodeLine{279     STDMETHOD\_(ULONG, AddRef)(THIS) PURE;}
\DoxyCodeLine{280     STDMETHOD\_(ULONG, Release)(THIS) PURE;}
\DoxyCodeLine{281 }
\DoxyCodeLine{282     \textcolor{comment}{// ID3DXBaseMesh}}
\DoxyCodeLine{283     STDMETHOD(DrawSubset)(THIS\_ DWORD AttribId) PURE;}
\DoxyCodeLine{284     STDMETHOD\_(DWORD, GetNumFaces)(THIS) PURE;}
\DoxyCodeLine{285     STDMETHOD\_(DWORD, GetNumVertices)(THIS) PURE;}
\DoxyCodeLine{286     STDMETHOD\_(DWORD, GetFVF)(THIS) PURE;}
\DoxyCodeLine{287     STDMETHOD(GetDeclaration)(THIS\_ \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} Declaration[MAX\_FVF\_DECL\_SIZE]) PURE;}
\DoxyCodeLine{288     STDMETHOD\_(DWORD, GetNumBytesPerVertex)(THIS) PURE;}
\DoxyCodeLine{289     STDMETHOD\_(DWORD, GetOptions)(THIS) PURE;}
\DoxyCodeLine{290     STDMETHOD(GetDevice)(THIS\_ LPDIRECT3DDEVICE9* ppDevice) PURE;}
\DoxyCodeLine{291     STDMETHOD(CloneMeshFVF)(THIS\_ DWORD Options, }
\DoxyCodeLine{292                 DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;}
\DoxyCodeLine{293     STDMETHOD(CloneMesh)(THIS\_ DWORD Options, }
\DoxyCodeLine{294                 CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;}
\DoxyCodeLine{295     STDMETHOD(GetVertexBuffer)(THIS\_ LPDIRECT3DVERTEXBUFFER9* ppVB) PURE;}
\DoxyCodeLine{296     STDMETHOD(GetIndexBuffer)(THIS\_ LPDIRECT3DINDEXBUFFER9* ppIB) PURE;}
\DoxyCodeLine{297     STDMETHOD(LockVertexBuffer)(THIS\_ DWORD Flags, LPVOID *ppData) PURE;}
\DoxyCodeLine{298     STDMETHOD(UnlockVertexBuffer)(THIS) PURE;}
\DoxyCodeLine{299     STDMETHOD(LockIndexBuffer)(THIS\_ DWORD Flags, LPVOID *ppData) PURE;}
\DoxyCodeLine{300     STDMETHOD(UnlockIndexBuffer)(THIS) PURE;}
\DoxyCodeLine{301     STDMETHOD(GetAttributeTable)(}
\DoxyCodeLine{302                 THIS\_ \mbox{\hyperlink{struct___d3_d_x_a_t_t_r_i_b_u_t_e_r_a_n_g_e}{D3DXATTRIBUTERANGE}} *pAttribTable, DWORD* pAttribTableSize) PURE;}
\DoxyCodeLine{303 }
\DoxyCodeLine{304     STDMETHOD(ConvertPointRepsToAdjacency)(THIS\_ CONST DWORD* pPRep, DWORD* pAdjacency) PURE;}
\DoxyCodeLine{305     STDMETHOD(ConvertAdjacencyToPointReps)(THIS\_ CONST DWORD* pAdjacency, DWORD* pPRep) PURE;}
\DoxyCodeLine{306     STDMETHOD(GenerateAdjacency)(THIS\_ FLOAT Epsilon, DWORD* pAdjacency) PURE;}
\DoxyCodeLine{307 }
\DoxyCodeLine{308     STDMETHOD(UpdateSemantics)(THIS\_ \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} Declaration[MAX\_FVF\_DECL\_SIZE]) PURE;}
\DoxyCodeLine{309 }
\DoxyCodeLine{310     \textcolor{comment}{// ID3DXMesh}}
\DoxyCodeLine{311     STDMETHOD(LockAttributeBuffer)(THIS\_ DWORD Flags, DWORD** ppData) PURE;}
\DoxyCodeLine{312     STDMETHOD(UnlockAttributeBuffer)(THIS) PURE;}
\DoxyCodeLine{313     STDMETHOD(Optimize)(THIS\_ DWORD Flags, CONST DWORD* pAdjacencyIn, DWORD* pAdjacencyOut, }
\DoxyCodeLine{314                      DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap,  }
\DoxyCodeLine{315                      LPD3DXMESH* ppOptMesh) PURE;}
\DoxyCodeLine{316     STDMETHOD(OptimizeInplace)(THIS\_ DWORD Flags, CONST DWORD* pAdjacencyIn, DWORD* pAdjacencyOut, }
\DoxyCodeLine{317                      DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap) PURE;}
\DoxyCodeLine{318     STDMETHOD(SetAttributeTable)(THIS\_ CONST \mbox{\hyperlink{struct___d3_d_x_a_t_t_r_i_b_u_t_e_r_a_n_g_e}{D3DXATTRIBUTERANGE}} *pAttribTable, DWORD cAttribTableSize) PURE;}
\DoxyCodeLine{319 \};}
\DoxyCodeLine{320 }
\DoxyCodeLine{321 }
\DoxyCodeLine{322 \textcolor{preprocessor}{\#undef INTERFACE}}
\DoxyCodeLine{323 \textcolor{preprocessor}{\#define INTERFACE ID3DXPMesh}}
\DoxyCodeLine{324 }
\DoxyCodeLine{325 DECLARE\_INTERFACE\_(ID3DXPMesh, ID3DXBaseMesh)}
\DoxyCodeLine{326 \{}
\DoxyCodeLine{327     \textcolor{comment}{// IUnknown}}
\DoxyCodeLine{328     STDMETHOD(QueryInterface)(THIS\_ REFIID iid, LPVOID *ppv) PURE;}
\DoxyCodeLine{329     STDMETHOD\_(ULONG, AddRef)(THIS) PURE;}
\DoxyCodeLine{330     STDMETHOD\_(ULONG, Release)(THIS) PURE;}
\DoxyCodeLine{331 }
\DoxyCodeLine{332     \textcolor{comment}{// ID3DXBaseMesh}}
\DoxyCodeLine{333     STDMETHOD(DrawSubset)(THIS\_ DWORD AttribId) PURE;}
\DoxyCodeLine{334     STDMETHOD\_(DWORD, GetNumFaces)(THIS) PURE;}
\DoxyCodeLine{335     STDMETHOD\_(DWORD, GetNumVertices)(THIS) PURE;}
\DoxyCodeLine{336     STDMETHOD\_(DWORD, GetFVF)(THIS) PURE;}
\DoxyCodeLine{337     STDMETHOD(GetDeclaration)(THIS\_ \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} Declaration[MAX\_FVF\_DECL\_SIZE]) PURE;}
\DoxyCodeLine{338     STDMETHOD\_(DWORD, GetNumBytesPerVertex)(THIS) PURE;}
\DoxyCodeLine{339     STDMETHOD\_(DWORD, GetOptions)(THIS) PURE;}
\DoxyCodeLine{340     STDMETHOD(GetDevice)(THIS\_ LPDIRECT3DDEVICE9* ppDevice) PURE;}
\DoxyCodeLine{341     STDMETHOD(CloneMeshFVF)(THIS\_ DWORD Options, }
\DoxyCodeLine{342                 DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;}
\DoxyCodeLine{343     STDMETHOD(CloneMesh)(THIS\_ DWORD Options, }
\DoxyCodeLine{344                 CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;}
\DoxyCodeLine{345     STDMETHOD(GetVertexBuffer)(THIS\_ LPDIRECT3DVERTEXBUFFER9* ppVB) PURE;}
\DoxyCodeLine{346     STDMETHOD(GetIndexBuffer)(THIS\_ LPDIRECT3DINDEXBUFFER9* ppIB) PURE;}
\DoxyCodeLine{347     STDMETHOD(LockVertexBuffer)(THIS\_ DWORD Flags, LPVOID *ppData) PURE;}
\DoxyCodeLine{348     STDMETHOD(UnlockVertexBuffer)(THIS) PURE;}
\DoxyCodeLine{349     STDMETHOD(LockIndexBuffer)(THIS\_ DWORD Flags, LPVOID *ppData) PURE;}
\DoxyCodeLine{350     STDMETHOD(UnlockIndexBuffer)(THIS) PURE;}
\DoxyCodeLine{351     STDMETHOD(GetAttributeTable)(}
\DoxyCodeLine{352                 THIS\_ \mbox{\hyperlink{struct___d3_d_x_a_t_t_r_i_b_u_t_e_r_a_n_g_e}{D3DXATTRIBUTERANGE}} *pAttribTable, DWORD* pAttribTableSize) PURE;}
\DoxyCodeLine{353 }
\DoxyCodeLine{354     STDMETHOD(ConvertPointRepsToAdjacency)(THIS\_ CONST DWORD* pPRep, DWORD* pAdjacency) PURE;}
\DoxyCodeLine{355     STDMETHOD(ConvertAdjacencyToPointReps)(THIS\_ CONST DWORD* pAdjacency, DWORD* pPRep) PURE;}
\DoxyCodeLine{356     STDMETHOD(GenerateAdjacency)(THIS\_ FLOAT Epsilon, DWORD* pAdjacency) PURE;}
\DoxyCodeLine{357 }
\DoxyCodeLine{358     STDMETHOD(UpdateSemantics)(THIS\_ \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} Declaration[MAX\_FVF\_DECL\_SIZE]) PURE;}
\DoxyCodeLine{359 }
\DoxyCodeLine{360     \textcolor{comment}{// ID3DXPMesh}}
\DoxyCodeLine{361     STDMETHOD(ClonePMeshFVF)(THIS\_ DWORD Options, }
\DoxyCodeLine{362                 DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXPMESH* ppCloneMesh) PURE;}
\DoxyCodeLine{363     STDMETHOD(ClonePMesh)(THIS\_ DWORD Options, }
\DoxyCodeLine{364                 CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXPMESH* ppCloneMesh) PURE;}
\DoxyCodeLine{365     STDMETHOD(SetNumFaces)(THIS\_ DWORD Faces) PURE;}
\DoxyCodeLine{366     STDMETHOD(SetNumVertices)(THIS\_ DWORD Vertices) PURE;}
\DoxyCodeLine{367     STDMETHOD\_(DWORD, GetMaxFaces)(THIS) PURE;}
\DoxyCodeLine{368     STDMETHOD\_(DWORD, GetMinFaces)(THIS) PURE;}
\DoxyCodeLine{369     STDMETHOD\_(DWORD, GetMaxVertices)(THIS) PURE;}
\DoxyCodeLine{370     STDMETHOD\_(DWORD, GetMinVertices)(THIS) PURE;}
\DoxyCodeLine{371     STDMETHOD(Save)(THIS\_ IStream *pStream, CONST \mbox{\hyperlink{struct___d3_d_x_m_a_t_e_r_i_a_l}{D3DXMATERIAL}}* pMaterials, CONST \mbox{\hyperlink{struct___d3_d_x_e_f_f_e_c_t_i_n_s_t_a_n_c_e}{D3DXEFFECTINSTANCE}}* pEffectInstances, DWORD NumMaterials) PURE;}
\DoxyCodeLine{372 }
\DoxyCodeLine{373     STDMETHOD(Optimize)(THIS\_ DWORD Flags, DWORD* pAdjacencyOut, }
\DoxyCodeLine{374                      DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap,  }
\DoxyCodeLine{375                      LPD3DXMESH* ppOptMesh) PURE;}
\DoxyCodeLine{376 }
\DoxyCodeLine{377     STDMETHOD(OptimizeBaseLOD)(THIS\_ DWORD Flags, DWORD* pFaceRemap) PURE;}
\DoxyCodeLine{378     STDMETHOD(TrimByFaces)(THIS\_ DWORD NewFacesMin, DWORD NewFacesMax, DWORD *rgiFaceRemap, DWORD *rgiVertRemap) PURE;}
\DoxyCodeLine{379     STDMETHOD(TrimByVertices)(THIS\_ DWORD NewVerticesMin, DWORD NewVerticesMax, DWORD *rgiFaceRemap, DWORD *rgiVertRemap) PURE;}
\DoxyCodeLine{380 }
\DoxyCodeLine{381     STDMETHOD(GetAdjacency)(THIS\_ DWORD* pAdjacency) PURE;}
\DoxyCodeLine{382 }
\DoxyCodeLine{383     \textcolor{comment}{//  Used to generate the immediate "{}ancestor"{} for each vertex when it is removed by a vsplit.  Allows generation of geomorphs}}
\DoxyCodeLine{384     \textcolor{comment}{//     Vertex buffer must be equal to or greater than the maximum number of vertices in the pmesh}}
\DoxyCodeLine{385     STDMETHOD(GenerateVertexHistory)(THIS\_ DWORD* pVertexHistory) PURE;}
\DoxyCodeLine{386 \};}
\DoxyCodeLine{387 }
\DoxyCodeLine{388 }
\DoxyCodeLine{389 \textcolor{preprocessor}{\#undef INTERFACE}}
\DoxyCodeLine{390 \textcolor{preprocessor}{\#define INTERFACE ID3DXSPMesh}}
\DoxyCodeLine{391 }
\DoxyCodeLine{392 DECLARE\_INTERFACE\_(ID3DXSPMesh, IUnknown)}
\DoxyCodeLine{393 \{}
\DoxyCodeLine{394     \textcolor{comment}{// IUnknown}}
\DoxyCodeLine{395     STDMETHOD(QueryInterface)(THIS\_ REFIID iid, LPVOID *ppv) PURE;}
\DoxyCodeLine{396     STDMETHOD\_(ULONG, AddRef)(THIS) PURE;}
\DoxyCodeLine{397     STDMETHOD\_(ULONG, Release)(THIS) PURE;}
\DoxyCodeLine{398 }
\DoxyCodeLine{399     \textcolor{comment}{// ID3DXSPMesh}}
\DoxyCodeLine{400     STDMETHOD\_(DWORD, GetNumFaces)(THIS) PURE;}
\DoxyCodeLine{401     STDMETHOD\_(DWORD, GetNumVertices)(THIS) PURE;}
\DoxyCodeLine{402     STDMETHOD\_(DWORD, GetFVF)(THIS) PURE;}
\DoxyCodeLine{403     STDMETHOD(GetDeclaration)(THIS\_ \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} Declaration[MAX\_FVF\_DECL\_SIZE]) PURE;}
\DoxyCodeLine{404     STDMETHOD\_(DWORD, GetOptions)(THIS) PURE;}
\DoxyCodeLine{405     STDMETHOD(GetDevice)(THIS\_ LPDIRECT3DDEVICE9* ppDevice) PURE;}
\DoxyCodeLine{406     STDMETHOD(CloneMeshFVF)(THIS\_ DWORD Options, }
\DoxyCodeLine{407                 DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, DWORD *pAdjacencyOut, DWORD *pVertexRemapOut, LPD3DXMESH* ppCloneMesh) PURE;}
\DoxyCodeLine{408     STDMETHOD(CloneMesh)(THIS\_ DWORD Options, }
\DoxyCodeLine{409                 CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, DWORD *pAdjacencyOut, DWORD *pVertexRemapOut, LPD3DXMESH* ppCloneMesh) PURE;}
\DoxyCodeLine{410     STDMETHOD(ClonePMeshFVF)(THIS\_ DWORD Options, }
\DoxyCodeLine{411                 DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, DWORD *pVertexRemapOut, FLOAT *pErrorsByFace, LPD3DXPMESH* ppCloneMesh) PURE;}
\DoxyCodeLine{412     STDMETHOD(ClonePMesh)(THIS\_ DWORD Options, }
\DoxyCodeLine{413                 CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, DWORD *pVertexRemapOut, FLOAT *pErrorsbyFace, LPD3DXPMESH* ppCloneMesh) PURE;}
\DoxyCodeLine{414     STDMETHOD(ReduceFaces)(THIS\_ DWORD Faces) PURE;}
\DoxyCodeLine{415     STDMETHOD(ReduceVertices)(THIS\_ DWORD Vertices) PURE;}
\DoxyCodeLine{416     STDMETHOD\_(DWORD, GetMaxFaces)(THIS) PURE;}
\DoxyCodeLine{417     STDMETHOD\_(DWORD, GetMaxVertices)(THIS) PURE;}
\DoxyCodeLine{418     STDMETHOD(GetVertexAttributeWeights)(THIS\_ \mbox{\hyperlink{struct___d3_d_x_a_t_t_r_i_b_u_t_e_w_e_i_g_h_t_s}{LPD3DXATTRIBUTEWEIGHTS}} pVertexAttributeWeights) PURE;}
\DoxyCodeLine{419     STDMETHOD(GetVertexWeights)(THIS\_ FLOAT *pVertexWeights) PURE;}
\DoxyCodeLine{420 \};}
\DoxyCodeLine{421 }
\DoxyCodeLine{422 \textcolor{preprocessor}{\#define UNUSED16 (0xffff)}}
\DoxyCodeLine{423 \textcolor{preprocessor}{\#define UNUSED32 (0xffffffff)}}
\DoxyCodeLine{424 }
\DoxyCodeLine{425 \textcolor{comment}{// ID3DXMesh::Optimize options -\/ upper byte only, lower 3 bytes used from \_D3DXMESH option flags}}
\DoxyCodeLine{426 \textcolor{keyword}{enum} \_D3DXMESHOPT \{}
\DoxyCodeLine{427     D3DXMESHOPT\_COMPACT       = 0x01000000,}
\DoxyCodeLine{428     D3DXMESHOPT\_ATTRSORT      = 0x02000000,}
\DoxyCodeLine{429     D3DXMESHOPT\_VERTEXCACHE   = 0x04000000,}
\DoxyCodeLine{430     D3DXMESHOPT\_STRIPREORDER  = 0x08000000,}
\DoxyCodeLine{431     D3DXMESHOPT\_IGNOREVERTS   = 0x10000000,  \textcolor{comment}{// optimize faces only, don't touch vertices}}
\DoxyCodeLine{432     D3DXMESHOPT\_DONOTSPLIT    = 0x20000000,  \textcolor{comment}{// do not split vertices shared between attribute groups when attribute sorting}}
\DoxyCodeLine{433     D3DXMESHOPT\_DEVICEINDEPENDENT = 0x00400000,  \textcolor{comment}{// Only affects VCache.  uses a static known good cache size for all cards}}
\DoxyCodeLine{434                             }
\DoxyCodeLine{435     \textcolor{comment}{// D3DXMESHOPT\_SHAREVB has been removed, please use D3DXMESH\_VB\_SHARE instead}}
\DoxyCodeLine{436 }
\DoxyCodeLine{437 \};}
\DoxyCodeLine{438 }
\DoxyCodeLine{439 \textcolor{comment}{// Subset of the mesh that has the same attribute and bone combination.}}
\DoxyCodeLine{440 \textcolor{comment}{// This subset can be rendered in a single draw call}}
\DoxyCodeLine{441 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{struct___d3_d_x_b_o_n_e_c_o_m_b_i_n_a_t_i_o_n}{\_D3DXBONECOMBINATION}}}
\DoxyCodeLine{442 \{}
\DoxyCodeLine{443     DWORD AttribId;}
\DoxyCodeLine{444     DWORD FaceStart;}
\DoxyCodeLine{445     DWORD FaceCount;}
\DoxyCodeLine{446     DWORD VertexStart;}
\DoxyCodeLine{447     DWORD VertexCount;}
\DoxyCodeLine{448     DWORD* BoneId;}
\DoxyCodeLine{449 \} \mbox{\hyperlink{struct___d3_d_x_b_o_n_e_c_o_m_b_i_n_a_t_i_o_n}{D3DXBONECOMBINATION}}, *\mbox{\hyperlink{struct___d3_d_x_b_o_n_e_c_o_m_b_i_n_a_t_i_o_n}{LPD3DXBONECOMBINATION}};}
\DoxyCodeLine{450 }
\DoxyCodeLine{451 \textcolor{comment}{// The following types of patch combinations are supported:}}
\DoxyCodeLine{452 \textcolor{comment}{// Patch type   Basis       Degree}}
\DoxyCodeLine{453 \textcolor{comment}{// Rect         Bezier      2,3,5}}
\DoxyCodeLine{454 \textcolor{comment}{// Rect         B-\/Spline    2,3,5}}
\DoxyCodeLine{455 \textcolor{comment}{// Rect         Catmull-\/Rom 3}}
\DoxyCodeLine{456 \textcolor{comment}{// Tri          Bezier      2,3,5}}
\DoxyCodeLine{457 \textcolor{comment}{// N-\/Patch      N/A         3}}
\DoxyCodeLine{458 }
\DoxyCodeLine{459 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{struct___d3_d_x_p_a_t_c_h_i_n_f_o}{\_D3DXPATCHINFO}}}
\DoxyCodeLine{460 \{}
\DoxyCodeLine{461     D3DXPATCHMESHTYPE PatchType;}
\DoxyCodeLine{462     D3DDEGREETYPE Degree;}
\DoxyCodeLine{463     D3DBASISTYPE Basis;}
\DoxyCodeLine{464 \} \mbox{\hyperlink{struct___d3_d_x_p_a_t_c_h_i_n_f_o}{D3DXPATCHINFO}}, *\mbox{\hyperlink{struct___d3_d_x_p_a_t_c_h_i_n_f_o}{LPD3DXPATCHINFO}};}
\DoxyCodeLine{465 }
\DoxyCodeLine{466 \textcolor{preprocessor}{\#undef INTERFACE}}
\DoxyCodeLine{467 \textcolor{preprocessor}{\#define INTERFACE ID3DXPatchMesh}}
\DoxyCodeLine{468 }
\DoxyCodeLine{469 DECLARE\_INTERFACE\_(ID3DXPatchMesh, IUnknown)}
\DoxyCodeLine{470 \{}
\DoxyCodeLine{471     \textcolor{comment}{// IUnknown}}
\DoxyCodeLine{472     STDMETHOD(QueryInterface)(THIS\_ REFIID iid, LPVOID *ppv) PURE;}
\DoxyCodeLine{473     STDMETHOD\_(ULONG, AddRef)(THIS) PURE;}
\DoxyCodeLine{474     STDMETHOD\_(ULONG, Release)(THIS) PURE;}
\DoxyCodeLine{475 }
\DoxyCodeLine{476     \textcolor{comment}{// ID3DXPatchMesh}}
\DoxyCodeLine{477 }
\DoxyCodeLine{478     \textcolor{comment}{// Return creation parameters}}
\DoxyCodeLine{479     STDMETHOD\_(DWORD, GetNumPatches)(THIS) PURE;}
\DoxyCodeLine{480     STDMETHOD\_(DWORD, GetNumVertices)(THIS) PURE;}
\DoxyCodeLine{481     STDMETHOD(GetDeclaration)(THIS\_ \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} Declaration[MAX\_FVF\_DECL\_SIZE]) PURE;}
\DoxyCodeLine{482     STDMETHOD\_(DWORD, GetControlVerticesPerPatch)(THIS) PURE;}
\DoxyCodeLine{483     STDMETHOD\_(DWORD, GetOptions)(THIS) PURE;}
\DoxyCodeLine{484     STDMETHOD(GetDevice)(THIS\_ LPDIRECT3DDEVICE9 *ppDevice) PURE;}
\DoxyCodeLine{485     STDMETHOD(GetPatchInfo)(THIS\_ \mbox{\hyperlink{struct___d3_d_x_p_a_t_c_h_i_n_f_o}{LPD3DXPATCHINFO}} PatchInfo) PURE;}
\DoxyCodeLine{486 }
\DoxyCodeLine{487     \textcolor{comment}{// Control mesh access    }}
\DoxyCodeLine{488     STDMETHOD(GetVertexBuffer)(THIS\_ LPDIRECT3DVERTEXBUFFER9* ppVB) PURE;}
\DoxyCodeLine{489     STDMETHOD(GetIndexBuffer)(THIS\_ LPDIRECT3DINDEXBUFFER9* ppIB) PURE;}
\DoxyCodeLine{490     STDMETHOD(LockVertexBuffer)(THIS\_ DWORD flags, LPVOID *ppData) PURE;}
\DoxyCodeLine{491     STDMETHOD(UnlockVertexBuffer)(THIS) PURE;}
\DoxyCodeLine{492     STDMETHOD(LockIndexBuffer)(THIS\_ DWORD flags, LPVOID *ppData) PURE;}
\DoxyCodeLine{493     STDMETHOD(UnlockIndexBuffer)(THIS) PURE;}
\DoxyCodeLine{494     STDMETHOD(LockAttributeBuffer)(THIS\_ DWORD flags, DWORD** ppData) PURE;}
\DoxyCodeLine{495     STDMETHOD(UnlockAttributeBuffer)(THIS) PURE;}
\DoxyCodeLine{496 }
\DoxyCodeLine{497     \textcolor{comment}{// This function returns the size of the tessellated mesh given a tessellation level.}}
\DoxyCodeLine{498     \textcolor{comment}{// This assumes uniform tessellation. For adaptive tessellation the Adaptive parameter must}}
\DoxyCodeLine{499     \textcolor{comment}{// be set to TRUE and TessellationLevel should be the max tessellation.}}
\DoxyCodeLine{500     \textcolor{comment}{// This will result in the max mesh size necessary for adaptive tessellation.    }}
\DoxyCodeLine{501     STDMETHOD(GetTessSize)(THIS\_ FLOAT fTessLevel,DWORD Adaptive, DWORD *NumTriangles,DWORD *NumVertices) PURE;}
\DoxyCodeLine{502     }
\DoxyCodeLine{503     \textcolor{comment}{//GenerateAdjacency determines which patches are adjacent with provided tolerance}}
\DoxyCodeLine{504     \textcolor{comment}{//this information is used internally to optimize tessellation}}
\DoxyCodeLine{505     STDMETHOD(GenerateAdjacency)(THIS\_ FLOAT Tolerance) PURE;}
\DoxyCodeLine{506     }
\DoxyCodeLine{507     \textcolor{comment}{//CloneMesh Creates a new patchmesh with the specified decl, and converts the vertex buffer}}
\DoxyCodeLine{508     \textcolor{comment}{//to the new decl. Entries in the new decl which are new are set to 0. If the current mesh}}
\DoxyCodeLine{509     \textcolor{comment}{//has adjacency, the new mesh will also have adjacency}}
\DoxyCodeLine{510     STDMETHOD(CloneMesh)(THIS\_ DWORD Options, CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pDecl, LPD3DXPATCHMESH *pMesh) PURE;}
\DoxyCodeLine{511     }
\DoxyCodeLine{512     \textcolor{comment}{// Optimizes the patchmesh for efficient tessellation. This function is designed}}
\DoxyCodeLine{513     \textcolor{comment}{// to perform one time optimization for patch meshes that need to be tessellated}}
\DoxyCodeLine{514     \textcolor{comment}{// repeatedly by calling the Tessellate() method. The optimization performed is}}
\DoxyCodeLine{515     \textcolor{comment}{// independent of the actual tessellation level used.}}
\DoxyCodeLine{516     \textcolor{comment}{// Currently Flags is unused.}}
\DoxyCodeLine{517     \textcolor{comment}{// If vertices are changed, Optimize must be called again}}
\DoxyCodeLine{518     STDMETHOD(Optimize)(THIS\_ DWORD flags) PURE;}
\DoxyCodeLine{519 }
\DoxyCodeLine{520     \textcolor{comment}{//gets and sets displacement parameters}}
\DoxyCodeLine{521     \textcolor{comment}{//displacement maps can only be 2D textures MIP-\/MAPPING is ignored for non adapative tessellation}}
\DoxyCodeLine{522     STDMETHOD(SetDisplaceParam)(THIS\_ LPDIRECT3DBASETEXTURE9 Texture,}
\DoxyCodeLine{523                               D3DTEXTUREFILTERTYPE MinFilter,}
\DoxyCodeLine{524                               D3DTEXTUREFILTERTYPE MagFilter,}
\DoxyCodeLine{525                               D3DTEXTUREFILTERTYPE MipFilter,}
\DoxyCodeLine{526                               D3DTEXTUREADDRESS Wrap,}
\DoxyCodeLine{527                               DWORD dwLODBias) PURE;}
\DoxyCodeLine{528 }
\DoxyCodeLine{529     STDMETHOD(GetDisplaceParam)(THIS\_ LPDIRECT3DBASETEXTURE9 *Texture,}
\DoxyCodeLine{530                                 D3DTEXTUREFILTERTYPE *MinFilter,}
\DoxyCodeLine{531                                 D3DTEXTUREFILTERTYPE *MagFilter,}
\DoxyCodeLine{532                                 D3DTEXTUREFILTERTYPE *MipFilter,}
\DoxyCodeLine{533                                 D3DTEXTUREADDRESS *Wrap,}
\DoxyCodeLine{534                                 DWORD *dwLODBias) PURE;}
\DoxyCodeLine{535         }
\DoxyCodeLine{536     \textcolor{comment}{// Performs the uniform tessellation based on the tessellation level. }}
\DoxyCodeLine{537     \textcolor{comment}{// This function will perform more efficiently if the patch mesh has been optimized using the Optimize() call.}}
\DoxyCodeLine{538     STDMETHOD(Tessellate)(THIS\_ FLOAT fTessLevel,LPD3DXMESH pMesh) PURE;}
\DoxyCodeLine{539 }
\DoxyCodeLine{540     \textcolor{comment}{// Performs adaptive tessellation based on the Z based adaptive tessellation criterion.}}
\DoxyCodeLine{541     \textcolor{comment}{// pTrans specifies a 4D vector that is dotted with the vertices to get the per vertex}}
\DoxyCodeLine{542     \textcolor{comment}{// adaptive tessellation amount. Each edge is tessellated to the average of the criterion}}
\DoxyCodeLine{543     \textcolor{comment}{// at the 2 vertices it connects.}}
\DoxyCodeLine{544     \textcolor{comment}{// MaxTessLevel specifies the upper limit for adaptive tesselation.}}
\DoxyCodeLine{545     \textcolor{comment}{// This function will perform more efficiently if the patch mesh has been optimized using the Optimize() call.}}
\DoxyCodeLine{546     STDMETHOD(TessellateAdaptive)(THIS\_ }
\DoxyCodeLine{547         CONST \mbox{\hyperlink{struct_d3_d_x_v_e_c_t_o_r4}{D3DXVECTOR4}} *pTrans,}
\DoxyCodeLine{548         DWORD dwMaxTessLevel, }
\DoxyCodeLine{549         DWORD dwMinTessLevel,}
\DoxyCodeLine{550         LPD3DXMESH pMesh) PURE;}
\DoxyCodeLine{551 }
\DoxyCodeLine{552 \};}
\DoxyCodeLine{553 }
\DoxyCodeLine{554 \textcolor{preprocessor}{\#undef INTERFACE}}
\DoxyCodeLine{555 \textcolor{preprocessor}{\#define INTERFACE ID3DXSkinInfo}}
\DoxyCodeLine{556 }
\DoxyCodeLine{557 DECLARE\_INTERFACE\_(ID3DXSkinInfo, IUnknown)}
\DoxyCodeLine{558 \{}
\DoxyCodeLine{559     \textcolor{comment}{// IUnknown}}
\DoxyCodeLine{560     STDMETHOD(QueryInterface)(THIS\_ REFIID iid, LPVOID *ppv) PURE;}
\DoxyCodeLine{561     STDMETHOD\_(ULONG, AddRef)(THIS) PURE;}
\DoxyCodeLine{562     STDMETHOD\_(ULONG, Release)(THIS) PURE;}
\DoxyCodeLine{563 }
\DoxyCodeLine{564     \textcolor{comment}{// Specify the which vertices do each bones influence and by how much}}
\DoxyCodeLine{565     STDMETHOD(SetBoneInfluence)(THIS\_ DWORD bone, DWORD numInfluences, CONST DWORD* vertices, CONST FLOAT* weights) PURE;}
\DoxyCodeLine{566     STDMETHOD(SetBoneVertexInfluence)(THIS\_ DWORD boneNum, DWORD influenceNum, \textcolor{keywordtype}{float} weight) PURE;}
\DoxyCodeLine{567     STDMETHOD\_(DWORD, GetNumBoneInfluences)(THIS\_ DWORD bone) PURE;}
\DoxyCodeLine{568     STDMETHOD(GetBoneInfluence)(THIS\_ DWORD bone, DWORD* vertices, FLOAT* weights) PURE;}
\DoxyCodeLine{569     STDMETHOD(GetBoneVertexInfluence)(THIS\_ DWORD boneNum, DWORD influenceNum, \textcolor{keywordtype}{float} *pWeight, DWORD *pVertexNum) PURE;}
\DoxyCodeLine{570     STDMETHOD(GetMaxVertexInfluences)(THIS\_ DWORD* maxVertexInfluences) PURE;}
\DoxyCodeLine{571     STDMETHOD\_(DWORD, GetNumBones)(THIS) PURE;}
\DoxyCodeLine{572     STDMETHOD(FindBoneVertexInfluenceIndex)(THIS\_ DWORD boneNum, DWORD vertexNum, DWORD *pInfluenceIndex) PURE;}
\DoxyCodeLine{573 }
\DoxyCodeLine{574     \textcolor{comment}{// This gets the max face influences based on a triangle mesh with the specified index buffer}}
\DoxyCodeLine{575     STDMETHOD(GetMaxFaceInfluences)(THIS\_ LPDIRECT3DINDEXBUFFER9 pIB, DWORD NumFaces, DWORD* maxFaceInfluences) PURE;}
\DoxyCodeLine{576     }
\DoxyCodeLine{577     \textcolor{comment}{// Set min bone influence. Bone influences that are smaller than this are ignored}}
\DoxyCodeLine{578     STDMETHOD(SetMinBoneInfluence)(THIS\_ FLOAT MinInfl) PURE;}
\DoxyCodeLine{579     \textcolor{comment}{// Get min bone influence. }}
\DoxyCodeLine{580     STDMETHOD\_(FLOAT, GetMinBoneInfluence)(THIS) PURE;}
\DoxyCodeLine{581     }
\DoxyCodeLine{582     \textcolor{comment}{// Bone names are returned by D3DXLoadSkinMeshFromXof. They are not used by any other method of this object}}
\DoxyCodeLine{583     STDMETHOD(SetBoneName)(THIS\_ DWORD Bone, LPCSTR pName) PURE; \textcolor{comment}{// pName is copied to an internal string buffer}}
\DoxyCodeLine{584     STDMETHOD\_(LPCSTR, GetBoneName)(THIS\_ DWORD Bone) PURE; \textcolor{comment}{// A pointer to an internal string buffer is returned. Do not free this.}}
\DoxyCodeLine{585     }
\DoxyCodeLine{586     \textcolor{comment}{// Bone offset matrices are returned by D3DXLoadSkinMeshFromXof. They are not used by any other method of this object}}
\DoxyCodeLine{587     STDMETHOD(SetBoneOffsetMatrix)(THIS\_ DWORD Bone, CONST \mbox{\hyperlink{struct___d3_d_m_a_t_r_i_x}{D3DXMATRIX}} *pBoneTransform) PURE; \textcolor{comment}{// pBoneTransform is copied to an internal buffer}}
\DoxyCodeLine{588     STDMETHOD\_(\mbox{\hyperlink{struct___d3_d_m_a_t_r_i_x}{LPD3DXMATRIX}}, GetBoneOffsetMatrix)(THIS\_ DWORD Bone) PURE; \textcolor{comment}{// A pointer to an internal matrix is returned. Do not free this.}}
\DoxyCodeLine{589     }
\DoxyCodeLine{590     \textcolor{comment}{// Clone a skin info object}}
\DoxyCodeLine{591     STDMETHOD(Clone)(THIS\_ LPD3DXSKININFO* ppSkinInfo) PURE;}
\DoxyCodeLine{592     }
\DoxyCodeLine{593     \textcolor{comment}{// Update bone influence information to match vertices after they are reordered. This should be called }}
\DoxyCodeLine{594     \textcolor{comment}{// if the target vertex buffer has been reordered externally.}}
\DoxyCodeLine{595     STDMETHOD(Remap)(THIS\_ DWORD NumVertices, DWORD* pVertexRemap) PURE;}
\DoxyCodeLine{596 }
\DoxyCodeLine{597     \textcolor{comment}{// These methods enable the modification of the vertex layout of the vertices that will be skinned}}
\DoxyCodeLine{598     STDMETHOD(SetFVF)(THIS\_ DWORD FVF) PURE;}
\DoxyCodeLine{599     STDMETHOD(SetDeclaration)(THIS\_ CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pDeclaration) PURE;}
\DoxyCodeLine{600     STDMETHOD\_(DWORD, GetFVF)(THIS) PURE;}
\DoxyCodeLine{601     STDMETHOD(GetDeclaration)(THIS\_ \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} Declaration[MAX\_FVF\_DECL\_SIZE]) PURE;}
\DoxyCodeLine{602 }
\DoxyCodeLine{603     \textcolor{comment}{// Apply SW skinning based on current pose matrices to the target vertices.}}
\DoxyCodeLine{604     STDMETHOD(UpdateSkinnedMesh)(THIS\_ }
\DoxyCodeLine{605         CONST \mbox{\hyperlink{struct___d3_d_m_a_t_r_i_x}{D3DXMATRIX}}* pBoneTransforms, }
\DoxyCodeLine{606         CONST \mbox{\hyperlink{struct___d3_d_m_a_t_r_i_x}{D3DXMATRIX}}* pBoneInvTransposeTransforms, }
\DoxyCodeLine{607         LPCVOID pVerticesSrc, }
\DoxyCodeLine{608         PVOID pVerticesDst) PURE;}
\DoxyCodeLine{609 }
\DoxyCodeLine{610     \textcolor{comment}{// Takes a mesh and returns a new mesh with per vertex blend weights and a bone combination}}
\DoxyCodeLine{611     \textcolor{comment}{// table that describes which bones affect which subsets of the mesh}}
\DoxyCodeLine{612     STDMETHOD(ConvertToBlendedMesh)(THIS\_ }
\DoxyCodeLine{613         LPD3DXMESH pMesh,}
\DoxyCodeLine{614         DWORD Options, }
\DoxyCodeLine{615         CONST DWORD *pAdjacencyIn, }
\DoxyCodeLine{616         LPDWORD pAdjacencyOut,}
\DoxyCodeLine{617         DWORD* pFaceRemap, }
\DoxyCodeLine{618         LPD3DXBUFFER *ppVertexRemap, }
\DoxyCodeLine{619         DWORD* pMaxFaceInfl,}
\DoxyCodeLine{620         DWORD* pNumBoneCombinations, }
\DoxyCodeLine{621         LPD3DXBUFFER* ppBoneCombinationTable, }
\DoxyCodeLine{622         LPD3DXMESH* ppMesh) PURE;}
\DoxyCodeLine{623 }
\DoxyCodeLine{624     \textcolor{comment}{// Takes a mesh and returns a new mesh with per vertex blend weights and indices }}
\DoxyCodeLine{625     \textcolor{comment}{// and a bone combination table that describes which bones palettes affect which subsets of the mesh}}
\DoxyCodeLine{626     STDMETHOD(ConvertToIndexedBlendedMesh)(THIS\_ }
\DoxyCodeLine{627         LPD3DXMESH pMesh,}
\DoxyCodeLine{628         DWORD Options, }
\DoxyCodeLine{629         DWORD paletteSize, }
\DoxyCodeLine{630         CONST DWORD *pAdjacencyIn, }
\DoxyCodeLine{631         LPDWORD pAdjacencyOut, }
\DoxyCodeLine{632         DWORD* pFaceRemap, }
\DoxyCodeLine{633         LPD3DXBUFFER *ppVertexRemap, }
\DoxyCodeLine{634         DWORD* pMaxVertexInfl,}
\DoxyCodeLine{635         DWORD* pNumBoneCombinations, }
\DoxyCodeLine{636         LPD3DXBUFFER* ppBoneCombinationTable, }
\DoxyCodeLine{637         LPD3DXMESH* ppMesh) PURE;}
\DoxyCodeLine{638 \};}
\DoxyCodeLine{639 }
\DoxyCodeLine{640 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{641 \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \{}
\DoxyCodeLine{642 \textcolor{preprocessor}{\#endif }\textcolor{comment}{//\_\_cplusplus}}
\DoxyCodeLine{643 }
\DoxyCodeLine{644 }
\DoxyCodeLine{645 HRESULT WINAPI }
\DoxyCodeLine{646     D3DXCreateMesh(}
\DoxyCodeLine{647         DWORD NumFaces, }
\DoxyCodeLine{648         DWORD NumVertices, }
\DoxyCodeLine{649         DWORD Options, }
\DoxyCodeLine{650         CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pDeclaration, }
\DoxyCodeLine{651         LPDIRECT3DDEVICE9 pD3DDevice, }
\DoxyCodeLine{652         LPD3DXMESH* ppMesh);}
\DoxyCodeLine{653 }
\DoxyCodeLine{654 HRESULT WINAPI }
\DoxyCodeLine{655     D3DXCreateMeshFVF(}
\DoxyCodeLine{656         DWORD NumFaces, }
\DoxyCodeLine{657         DWORD NumVertices, }
\DoxyCodeLine{658         DWORD Options, }
\DoxyCodeLine{659         DWORD FVF, }
\DoxyCodeLine{660         LPDIRECT3DDEVICE9 pD3DDevice, }
\DoxyCodeLine{661         LPD3DXMESH* ppMesh);}
\DoxyCodeLine{662 }
\DoxyCodeLine{663 HRESULT WINAPI }
\DoxyCodeLine{664     D3DXCreateSPMesh(}
\DoxyCodeLine{665         LPD3DXMESH pMesh, }
\DoxyCodeLine{666         CONST DWORD* pAdjacency, }
\DoxyCodeLine{667         CONST \mbox{\hyperlink{struct___d3_d_x_a_t_t_r_i_b_u_t_e_w_e_i_g_h_t_s}{D3DXATTRIBUTEWEIGHTS}} *pVertexAttributeWeights,}
\DoxyCodeLine{668         CONST FLOAT *pVertexWeights,}
\DoxyCodeLine{669         LPD3DXSPMESH* ppSMesh);}
\DoxyCodeLine{670 }
\DoxyCodeLine{671 \textcolor{comment}{// clean a mesh up for simplification, try to make manifold}}
\DoxyCodeLine{672 HRESULT WINAPI}
\DoxyCodeLine{673     D3DXCleanMesh(}
\DoxyCodeLine{674     D3DXCLEANTYPE CleanType,}
\DoxyCodeLine{675     LPD3DXMESH pMeshIn,}
\DoxyCodeLine{676     CONST DWORD* pAdjacencyIn,}
\DoxyCodeLine{677     LPD3DXMESH* ppMeshOut,}
\DoxyCodeLine{678     DWORD* pAdjacencyOut,}
\DoxyCodeLine{679     LPD3DXBUFFER* ppErrorsAndWarnings);}
\DoxyCodeLine{680 }
\DoxyCodeLine{681 HRESULT WINAPI}
\DoxyCodeLine{682     D3DXValidMesh(}
\DoxyCodeLine{683     LPD3DXMESH pMeshIn,}
\DoxyCodeLine{684     CONST DWORD* pAdjacency,}
\DoxyCodeLine{685     LPD3DXBUFFER* ppErrorsAndWarnings);}
\DoxyCodeLine{686 }
\DoxyCodeLine{687 HRESULT WINAPI }
\DoxyCodeLine{688     D3DXGeneratePMesh(}
\DoxyCodeLine{689         LPD3DXMESH pMesh, }
\DoxyCodeLine{690         CONST DWORD* pAdjacency, }
\DoxyCodeLine{691         CONST \mbox{\hyperlink{struct___d3_d_x_a_t_t_r_i_b_u_t_e_w_e_i_g_h_t_s}{D3DXATTRIBUTEWEIGHTS}} *pVertexAttributeWeights,}
\DoxyCodeLine{692         CONST FLOAT *pVertexWeights,}
\DoxyCodeLine{693         DWORD MinValue, }
\DoxyCodeLine{694         DWORD Options, }
\DoxyCodeLine{695         LPD3DXPMESH* ppPMesh);}
\DoxyCodeLine{696 }
\DoxyCodeLine{697 HRESULT WINAPI }
\DoxyCodeLine{698     D3DXSimplifyMesh(}
\DoxyCodeLine{699         LPD3DXMESH pMesh, }
\DoxyCodeLine{700         CONST DWORD* pAdjacency, }
\DoxyCodeLine{701         CONST \mbox{\hyperlink{struct___d3_d_x_a_t_t_r_i_b_u_t_e_w_e_i_g_h_t_s}{D3DXATTRIBUTEWEIGHTS}} *pVertexAttributeWeights,}
\DoxyCodeLine{702         CONST FLOAT *pVertexWeights,}
\DoxyCodeLine{703         DWORD MinValue, }
\DoxyCodeLine{704         DWORD Options, }
\DoxyCodeLine{705         LPD3DXMESH* ppMesh);}
\DoxyCodeLine{706 }
\DoxyCodeLine{707 HRESULT WINAPI }
\DoxyCodeLine{708     D3DXComputeBoundingSphere(}
\DoxyCodeLine{709         CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pFirstPosition,  \textcolor{comment}{// pointer to first position}}
\DoxyCodeLine{710         DWORD NumVertices, }
\DoxyCodeLine{711         DWORD dwStride,                     \textcolor{comment}{// count in bytes to subsequent position vectors}}
\DoxyCodeLine{712         \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pCenter, }
\DoxyCodeLine{713         FLOAT *pRadius);}
\DoxyCodeLine{714 }
\DoxyCodeLine{715 HRESULT WINAPI }
\DoxyCodeLine{716     D3DXComputeBoundingBox(}
\DoxyCodeLine{717         CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pFirstPosition,  \textcolor{comment}{// pointer to first position}}
\DoxyCodeLine{718         DWORD NumVertices, }
\DoxyCodeLine{719         DWORD dwStride,                     \textcolor{comment}{// count in bytes to subsequent position vectors}}
\DoxyCodeLine{720         \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pMin, }
\DoxyCodeLine{721         \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pMax);}
\DoxyCodeLine{722 }
\DoxyCodeLine{723 HRESULT WINAPI }
\DoxyCodeLine{724     D3DXComputeNormals(}
\DoxyCodeLine{725         LPD3DXBASEMESH pMesh,}
\DoxyCodeLine{726         CONST DWORD *pAdjacency);}
\DoxyCodeLine{727 }
\DoxyCodeLine{728 HRESULT WINAPI }
\DoxyCodeLine{729     D3DXCreateBuffer(}
\DoxyCodeLine{730         DWORD NumBytes, }
\DoxyCodeLine{731         LPD3DXBUFFER *ppBuffer);}
\DoxyCodeLine{732 }
\DoxyCodeLine{733 }
\DoxyCodeLine{734 HRESULT WINAPI}
\DoxyCodeLine{735     D3DXLoadMeshFromXA(}
\DoxyCodeLine{736         LPCSTR pFilename, }
\DoxyCodeLine{737         DWORD Options, }
\DoxyCodeLine{738         LPDIRECT3DDEVICE9 pD3DDevice, }
\DoxyCodeLine{739         LPD3DXBUFFER *ppAdjacency,}
\DoxyCodeLine{740         LPD3DXBUFFER *ppMaterials, }
\DoxyCodeLine{741         LPD3DXBUFFER *ppEffectInstances, }
\DoxyCodeLine{742         DWORD *pNumMaterials,}
\DoxyCodeLine{743         LPD3DXMESH *ppMesh);}
\DoxyCodeLine{744 }
\DoxyCodeLine{745 HRESULT WINAPI}
\DoxyCodeLine{746     D3DXLoadMeshFromXW(}
\DoxyCodeLine{747         LPCWSTR pFilename, }
\DoxyCodeLine{748         DWORD Options, }
\DoxyCodeLine{749         LPDIRECT3DDEVICE9 pD3DDevice, }
\DoxyCodeLine{750         LPD3DXBUFFER *ppAdjacency,}
\DoxyCodeLine{751         LPD3DXBUFFER *ppMaterials, }
\DoxyCodeLine{752         LPD3DXBUFFER *ppEffectInstances, }
\DoxyCodeLine{753         DWORD *pNumMaterials,}
\DoxyCodeLine{754         LPD3DXMESH *ppMesh);}
\DoxyCodeLine{755 }
\DoxyCodeLine{756 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{757 \textcolor{preprocessor}{\#define D3DXLoadMeshFromX D3DXLoadMeshFromXW}}
\DoxyCodeLine{758 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{759 \textcolor{preprocessor}{\#define D3DXLoadMeshFromX D3DXLoadMeshFromXA}}
\DoxyCodeLine{760 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{761 }
\DoxyCodeLine{762 HRESULT WINAPI }
\DoxyCodeLine{763     D3DXLoadMeshFromXInMemory(}
\DoxyCodeLine{764         LPCVOID Memory,}
\DoxyCodeLine{765         DWORD SizeOfMemory,}
\DoxyCodeLine{766         DWORD Options, }
\DoxyCodeLine{767         LPDIRECT3DDEVICE9 pD3DDevice, }
\DoxyCodeLine{768         LPD3DXBUFFER *ppAdjacency,}
\DoxyCodeLine{769         LPD3DXBUFFER *ppMaterials, }
\DoxyCodeLine{770         LPD3DXBUFFER *ppEffectInstances, }
\DoxyCodeLine{771         DWORD *pNumMaterials,}
\DoxyCodeLine{772         LPD3DXMESH *ppMesh);}
\DoxyCodeLine{773 }
\DoxyCodeLine{774 HRESULT WINAPI }
\DoxyCodeLine{775     D3DXLoadMeshFromXResource(}
\DoxyCodeLine{776         HMODULE Module,}
\DoxyCodeLine{777         LPCSTR Name,}
\DoxyCodeLine{778         LPCSTR Type,}
\DoxyCodeLine{779         DWORD Options, }
\DoxyCodeLine{780         LPDIRECT3DDEVICE9 pD3DDevice, }
\DoxyCodeLine{781         LPD3DXBUFFER *ppAdjacency,}
\DoxyCodeLine{782         LPD3DXBUFFER *ppMaterials, }
\DoxyCodeLine{783         LPD3DXBUFFER *ppEffectInstances, }
\DoxyCodeLine{784         DWORD *pNumMaterials,}
\DoxyCodeLine{785         LPD3DXMESH *ppMesh);}
\DoxyCodeLine{786 }
\DoxyCodeLine{787 HRESULT WINAPI }
\DoxyCodeLine{788     D3DXSaveMeshToXA(}
\DoxyCodeLine{789         LPCSTR pFilename,}
\DoxyCodeLine{790         LPD3DXMESH pMesh,}
\DoxyCodeLine{791         CONST DWORD* pAdjacency,}
\DoxyCodeLine{792         CONST \mbox{\hyperlink{struct___d3_d_x_m_a_t_e_r_i_a_l}{D3DXMATERIAL}}* pMaterials,}
\DoxyCodeLine{793         CONST \mbox{\hyperlink{struct___d3_d_x_e_f_f_e_c_t_i_n_s_t_a_n_c_e}{D3DXEFFECTINSTANCE}}* pEffectInstances, }
\DoxyCodeLine{794         DWORD NumMaterials,}
\DoxyCodeLine{795         DWORD Format}
\DoxyCodeLine{796         );}
\DoxyCodeLine{797 }
\DoxyCodeLine{798 HRESULT WINAPI }
\DoxyCodeLine{799     D3DXSaveMeshToXW(}
\DoxyCodeLine{800         LPCWSTR pFilename,}
\DoxyCodeLine{801         LPD3DXMESH pMesh,}
\DoxyCodeLine{802         CONST DWORD* pAdjacency,}
\DoxyCodeLine{803         CONST \mbox{\hyperlink{struct___d3_d_x_m_a_t_e_r_i_a_l}{D3DXMATERIAL}}* pMaterials,}
\DoxyCodeLine{804         CONST \mbox{\hyperlink{struct___d3_d_x_e_f_f_e_c_t_i_n_s_t_a_n_c_e}{D3DXEFFECTINSTANCE}}* pEffectInstances, }
\DoxyCodeLine{805         DWORD NumMaterials,}
\DoxyCodeLine{806         DWORD Format}
\DoxyCodeLine{807         );}
\DoxyCodeLine{808         }
\DoxyCodeLine{809 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{810 \textcolor{preprocessor}{\#define D3DXSaveMeshToX D3DXSaveMeshToXW}}
\DoxyCodeLine{811 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{812 \textcolor{preprocessor}{\#define D3DXSaveMeshToX D3DXSaveMeshToXA}}
\DoxyCodeLine{813 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{814         }
\DoxyCodeLine{815 }
\DoxyCodeLine{816 HRESULT WINAPI }
\DoxyCodeLine{817     D3DXCreatePMeshFromStream(}
\DoxyCodeLine{818         IStream *pStream, }
\DoxyCodeLine{819         DWORD Options,}
\DoxyCodeLine{820         LPDIRECT3DDEVICE9 pD3DDevice, }
\DoxyCodeLine{821         LPD3DXBUFFER *ppMaterials,}
\DoxyCodeLine{822         LPD3DXBUFFER *ppEffectInstances, }
\DoxyCodeLine{823         DWORD* pNumMaterials,}
\DoxyCodeLine{824         LPD3DXPMESH *ppPMesh);}
\DoxyCodeLine{825 }
\DoxyCodeLine{826 \textcolor{comment}{// Creates a skin info object based on the number of vertices, number of bones, and a declaration describing the vertex layout of the target vertices}}
\DoxyCodeLine{827 \textcolor{comment}{// The bone names and initial bone transforms are not filled in the skin info object by this method.}}
\DoxyCodeLine{828 HRESULT WINAPI}
\DoxyCodeLine{829     D3DXCreateSkinInfo(}
\DoxyCodeLine{830         DWORD NumVertices,}
\DoxyCodeLine{831         CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pDeclaration, }
\DoxyCodeLine{832         DWORD NumBones,}
\DoxyCodeLine{833         LPD3DXSKININFO* ppSkinInfo);}
\DoxyCodeLine{834         }
\DoxyCodeLine{835 \textcolor{comment}{// Creates a skin info object based on the number of vertices, number of bones, and a FVF describing the vertex layout of the target vertices}}
\DoxyCodeLine{836 \textcolor{comment}{// The bone names and initial bone transforms are not filled in the skin info object by this method.}}
\DoxyCodeLine{837 HRESULT WINAPI}
\DoxyCodeLine{838     D3DXCreateSkinInfoFVF(}
\DoxyCodeLine{839         DWORD NumVertices,}
\DoxyCodeLine{840         DWORD FVF,}
\DoxyCodeLine{841         DWORD NumBones,}
\DoxyCodeLine{842         LPD3DXSKININFO* ppSkinInfo);}
\DoxyCodeLine{843         }
\DoxyCodeLine{844 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{845 \}}
\DoxyCodeLine{846 }
\DoxyCodeLine{847 \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \{}
\DoxyCodeLine{848 \textcolor{preprocessor}{\#endif }\textcolor{comment}{//\_\_cplusplus}}
\DoxyCodeLine{849 }
\DoxyCodeLine{850 HRESULT WINAPI }
\DoxyCodeLine{851     D3DXLoadMeshFromXof(}
\DoxyCodeLine{852         LPD3DXFILEDATA pxofMesh, }
\DoxyCodeLine{853         DWORD Options, }
\DoxyCodeLine{854         LPDIRECT3DDEVICE9 pD3DDevice, }
\DoxyCodeLine{855         LPD3DXBUFFER *ppAdjacency,}
\DoxyCodeLine{856         LPD3DXBUFFER *ppMaterials, }
\DoxyCodeLine{857         LPD3DXBUFFER *ppEffectInstances, }
\DoxyCodeLine{858         DWORD *pNumMaterials,}
\DoxyCodeLine{859         LPD3DXMESH *ppMesh);}
\DoxyCodeLine{860 }
\DoxyCodeLine{861 \textcolor{comment}{// This similar to D3DXLoadMeshFromXof, except also returns skinning info if present in the file}}
\DoxyCodeLine{862 \textcolor{comment}{// If skinning info is not present, ppSkinInfo will be NULL     }}
\DoxyCodeLine{863 HRESULT WINAPI}
\DoxyCodeLine{864     D3DXLoadSkinMeshFromXof(}
\DoxyCodeLine{865         LPD3DXFILEDATA pxofMesh, }
\DoxyCodeLine{866         DWORD Options,}
\DoxyCodeLine{867         LPDIRECT3DDEVICE9 pD3DDevice,}
\DoxyCodeLine{868         LPD3DXBUFFER* ppAdjacency,}
\DoxyCodeLine{869         LPD3DXBUFFER* ppMaterials,}
\DoxyCodeLine{870         LPD3DXBUFFER *ppEffectInstances, }
\DoxyCodeLine{871         DWORD *pMatOut,}
\DoxyCodeLine{872         LPD3DXSKININFO* ppSkinInfo,}
\DoxyCodeLine{873         LPD3DXMESH* ppMesh);}
\DoxyCodeLine{874 }
\DoxyCodeLine{875 }
\DoxyCodeLine{876 \textcolor{comment}{// The inverse of D3DXConvertTo\{Indexed\}BlendedMesh() functions. It figures out the skinning info from}}
\DoxyCodeLine{877 \textcolor{comment}{// the mesh and the bone combination table and populates a skin info object with that data. The bone}}
\DoxyCodeLine{878 \textcolor{comment}{// names and initial bone transforms are not filled in the skin info object by this method. This works}}
\DoxyCodeLine{879 \textcolor{comment}{// with either a non-\/indexed or indexed blended mesh. It examines the FVF or declarator of the mesh to}}
\DoxyCodeLine{880 \textcolor{comment}{// determine what type it is.}}
\DoxyCodeLine{881 HRESULT WINAPI}
\DoxyCodeLine{882     D3DXCreateSkinInfoFromBlendedMesh(}
\DoxyCodeLine{883         LPD3DXBASEMESH pMesh,}
\DoxyCodeLine{884         DWORD NumBones,}
\DoxyCodeLine{885         CONST \mbox{\hyperlink{struct___d3_d_x_b_o_n_e_c_o_m_b_i_n_a_t_i_o_n}{D3DXBONECOMBINATION}} *pBoneCombinationTable,}
\DoxyCodeLine{886         LPD3DXSKININFO* ppSkinInfo);}
\DoxyCodeLine{887         }
\DoxyCodeLine{888 HRESULT WINAPI}
\DoxyCodeLine{889     D3DXTessellateNPatches(}
\DoxyCodeLine{890         LPD3DXMESH pMeshIn,             }
\DoxyCodeLine{891         CONST DWORD* pAdjacencyIn,             }
\DoxyCodeLine{892         FLOAT NumSegs,                    }
\DoxyCodeLine{893         BOOL  QuadraticInterpNormals,     \textcolor{comment}{// if false use linear intrep for normals, if true use quadratic}}
\DoxyCodeLine{894         LPD3DXMESH *ppMeshOut,}
\DoxyCodeLine{895         LPD3DXBUFFER *ppAdjacencyOut);}
\DoxyCodeLine{896 }
\DoxyCodeLine{897 }
\DoxyCodeLine{898 \textcolor{comment}{//generates implied outputdecl from input decl}}
\DoxyCodeLine{899 \textcolor{comment}{//the decl generated from this should be used to generate the output decl for}}
\DoxyCodeLine{900 \textcolor{comment}{//the tessellator subroutines. }}
\DoxyCodeLine{901 }
\DoxyCodeLine{902 HRESULT WINAPI}
\DoxyCodeLine{903     D3DXGenerateOutputDecl(}
\DoxyCodeLine{904         \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pOutput,}
\DoxyCodeLine{905         CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pInput);}
\DoxyCodeLine{906 }
\DoxyCodeLine{907 \textcolor{comment}{//loads patches from an XFileData}}
\DoxyCodeLine{908 \textcolor{comment}{//since an X file can have up to 6 different patch meshes in it,}}
\DoxyCodeLine{909 \textcolor{comment}{//returns them in an array -\/ pNumPatches will contain the number of}}
\DoxyCodeLine{910 \textcolor{comment}{//meshes in the actual file. }}
\DoxyCodeLine{911 HRESULT WINAPI}
\DoxyCodeLine{912     D3DXLoadPatchMeshFromXof(}
\DoxyCodeLine{913         LPD3DXFILEDATA pXofObjMesh,}
\DoxyCodeLine{914         DWORD Options,}
\DoxyCodeLine{915         LPDIRECT3DDEVICE9 pD3DDevice,}
\DoxyCodeLine{916         LPD3DXBUFFER *ppMaterials,}
\DoxyCodeLine{917         LPD3DXBUFFER *ppEffectInstances, }
\DoxyCodeLine{918         PDWORD pNumMaterials,}
\DoxyCodeLine{919         LPD3DXPATCHMESH *ppMesh);}
\DoxyCodeLine{920 }
\DoxyCodeLine{921 \textcolor{comment}{//computes the size a single rect patch.}}
\DoxyCodeLine{922 HRESULT WINAPI}
\DoxyCodeLine{923     D3DXRectPatchSize(}
\DoxyCodeLine{924         CONST FLOAT *pfNumSegs, \textcolor{comment}{//segments for each edge (4)}}
\DoxyCodeLine{925         DWORD *pdwTriangles,    \textcolor{comment}{//output number of triangles}}
\DoxyCodeLine{926         DWORD *pdwVertices);    \textcolor{comment}{//output number of vertices}}
\DoxyCodeLine{927 }
\DoxyCodeLine{928 \textcolor{comment}{//computes the size of a single triangle patch      }}
\DoxyCodeLine{929 HRESULT WINAPI}
\DoxyCodeLine{930     D3DXTriPatchSize(}
\DoxyCodeLine{931         CONST FLOAT *pfNumSegs, \textcolor{comment}{//segments for each edge (3)    }}
\DoxyCodeLine{932         DWORD *pdwTriangles,    \textcolor{comment}{//output number of triangles}}
\DoxyCodeLine{933         DWORD *pdwVertices);    \textcolor{comment}{//output number of vertices}}
\DoxyCodeLine{934 }
\DoxyCodeLine{935 }
\DoxyCodeLine{936 \textcolor{comment}{//tessellates a patch into a created mesh}}
\DoxyCodeLine{937 \textcolor{comment}{//similar to D3D RT patch}}
\DoxyCodeLine{938 HRESULT WINAPI}
\DoxyCodeLine{939     D3DXTessellateRectPatch(}
\DoxyCodeLine{940         LPDIRECT3DVERTEXBUFFER9 pVB,}
\DoxyCodeLine{941         CONST FLOAT *pNumSegs,}
\DoxyCodeLine{942         CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pdwInDecl,}
\DoxyCodeLine{943         CONST \mbox{\hyperlink{struct___d3_d_r_e_c_t_p_a_t_c_h___i_n_f_o}{D3DRECTPATCH\_INFO}} *pRectPatchInfo,}
\DoxyCodeLine{944         LPD3DXMESH pMesh);}
\DoxyCodeLine{945 }
\DoxyCodeLine{946 }
\DoxyCodeLine{947 HRESULT WINAPI}
\DoxyCodeLine{948     D3DXTessellateTriPatch(}
\DoxyCodeLine{949       LPDIRECT3DVERTEXBUFFER9 pVB,}
\DoxyCodeLine{950       CONST FLOAT *pNumSegs,}
\DoxyCodeLine{951       CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pInDecl,}
\DoxyCodeLine{952       CONST \mbox{\hyperlink{struct___d3_d_t_r_i_p_a_t_c_h___i_n_f_o}{D3DTRIPATCH\_INFO}} *pTriPatchInfo,}
\DoxyCodeLine{953       LPD3DXMESH pMesh);}
\DoxyCodeLine{954 }
\DoxyCodeLine{955 }
\DoxyCodeLine{956 }
\DoxyCodeLine{957 \textcolor{comment}{//creates an NPatch PatchMesh from a D3DXMESH }}
\DoxyCodeLine{958 HRESULT WINAPI}
\DoxyCodeLine{959     D3DXCreateNPatchMesh(}
\DoxyCodeLine{960         LPD3DXMESH pMeshSysMem,}
\DoxyCodeLine{961         LPD3DXPATCHMESH *pPatchMesh);}
\DoxyCodeLine{962 }
\DoxyCodeLine{963       }
\DoxyCodeLine{964 \textcolor{comment}{//creates a patch mesh}}
\DoxyCodeLine{965 HRESULT WINAPI}
\DoxyCodeLine{966     D3DXCreatePatchMesh(}
\DoxyCodeLine{967         CONST \mbox{\hyperlink{struct___d3_d_x_p_a_t_c_h_i_n_f_o}{D3DXPATCHINFO}} *pInfo,     \textcolor{comment}{//patch type}}
\DoxyCodeLine{968         DWORD dwNumPatches,             \textcolor{comment}{//number of patches}}
\DoxyCodeLine{969         DWORD dwNumVertices,            \textcolor{comment}{//number of control vertices}}
\DoxyCodeLine{970         DWORD dwOptions,                \textcolor{comment}{//options }}
\DoxyCodeLine{971         CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pDecl, \textcolor{comment}{//format of control vertices}}
\DoxyCodeLine{972         LPDIRECT3DDEVICE9 pD3DDevice, }
\DoxyCodeLine{973         LPD3DXPATCHMESH *pPatchMesh);}
\DoxyCodeLine{974 }
\DoxyCodeLine{975         }
\DoxyCodeLine{976 \textcolor{comment}{//returns the number of degenerates in a patch mesh -\/}}
\DoxyCodeLine{977 \textcolor{comment}{//text output put in string.}}
\DoxyCodeLine{978 HRESULT WINAPI}
\DoxyCodeLine{979     D3DXValidPatchMesh(LPD3DXPATCHMESH pMesh,}
\DoxyCodeLine{980                         DWORD *dwcDegenerateVertices,}
\DoxyCodeLine{981                         DWORD *dwcDegeneratePatches,}
\DoxyCodeLine{982                         LPD3DXBUFFER *ppErrorsAndWarnings);}
\DoxyCodeLine{983 }
\DoxyCodeLine{984 UINT WINAPI}
\DoxyCodeLine{985     D3DXGetFVFVertexSize(DWORD FVF);}
\DoxyCodeLine{986 }
\DoxyCodeLine{987 UINT WINAPI }
\DoxyCodeLine{988     D3DXGetDeclVertexSize(CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pDecl,DWORD Stream);}
\DoxyCodeLine{989 }
\DoxyCodeLine{990 UINT WINAPI }
\DoxyCodeLine{991     D3DXGetDeclLength(CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pDecl);}
\DoxyCodeLine{992 }
\DoxyCodeLine{993 HRESULT WINAPI}
\DoxyCodeLine{994     D3DXDeclaratorFromFVF(}
\DoxyCodeLine{995         DWORD FVF,}
\DoxyCodeLine{996         \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} pDeclarator[MAX\_FVF\_DECL\_SIZE]);}
\DoxyCodeLine{997 }
\DoxyCodeLine{998 HRESULT WINAPI}
\DoxyCodeLine{999     D3DXFVFFromDeclarator(}
\DoxyCodeLine{1000         CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pDeclarator,}
\DoxyCodeLine{1001         DWORD *pFVF);}
\DoxyCodeLine{1002 }
\DoxyCodeLine{1003 HRESULT WINAPI }
\DoxyCodeLine{1004     D3DXWeldVertices(}
\DoxyCodeLine{1005         LPD3DXMESH pMesh,         }
\DoxyCodeLine{1006         DWORD Flags,}
\DoxyCodeLine{1007         CONST \mbox{\hyperlink{struct___d3_d_x_w_e_l_d_e_p_s_i_l_o_n_s}{D3DXWELDEPSILONS}} *pEpsilons,                 }
\DoxyCodeLine{1008         CONST DWORD *pAdjacencyIn, }
\DoxyCodeLine{1009         DWORD *pAdjacencyOut,}
\DoxyCodeLine{1010         DWORD *pFaceRemap, }
\DoxyCodeLine{1011         LPD3DXBUFFER *ppVertexRemap);}
\DoxyCodeLine{1012 }
\DoxyCodeLine{1013 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{struct___d3_d_x_i_n_t_e_r_s_e_c_t_i_n_f_o}{\_D3DXINTERSECTINFO}}}
\DoxyCodeLine{1014 \{}
\DoxyCodeLine{1015     DWORD FaceIndex;                \textcolor{comment}{// index of face intersected}}
\DoxyCodeLine{1016     FLOAT U;                        \textcolor{comment}{// Barycentric Hit Coordinates    }}
\DoxyCodeLine{1017     FLOAT V;                        \textcolor{comment}{// Barycentric Hit Coordinates}}
\DoxyCodeLine{1018     FLOAT Dist;                     \textcolor{comment}{// Ray-\/Intersection Parameter Distance}}
\DoxyCodeLine{1019 \} \mbox{\hyperlink{struct___d3_d_x_i_n_t_e_r_s_e_c_t_i_n_f_o}{D3DXINTERSECTINFO}}, *\mbox{\hyperlink{struct___d3_d_x_i_n_t_e_r_s_e_c_t_i_n_f_o}{LPD3DXINTERSECTINFO}};}
\DoxyCodeLine{1020 }
\DoxyCodeLine{1021 }
\DoxyCodeLine{1022 HRESULT WINAPI}
\DoxyCodeLine{1023     D3DXIntersect(}
\DoxyCodeLine{1024         LPD3DXBASEMESH pMesh,}
\DoxyCodeLine{1025         CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pRayPos,}
\DoxyCodeLine{1026         CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pRayDir, }
\DoxyCodeLine{1027         BOOL    *pHit,              \textcolor{comment}{// True if any faces were intersected}}
\DoxyCodeLine{1028         DWORD   *pFaceIndex,        \textcolor{comment}{// index of closest face intersected}}
\DoxyCodeLine{1029         FLOAT   *pU,                \textcolor{comment}{// Barycentric Hit Coordinates    }}
\DoxyCodeLine{1030         FLOAT   *pV,                \textcolor{comment}{// Barycentric Hit Coordinates}}
\DoxyCodeLine{1031         FLOAT   *pDist,             \textcolor{comment}{// Ray-\/Intersection Parameter Distance}}
\DoxyCodeLine{1032         LPD3DXBUFFER *ppAllHits,    \textcolor{comment}{// Array of D3DXINTERSECTINFOs for all hits (not just closest) }}
\DoxyCodeLine{1033         DWORD   *pCountOfHits);     \textcolor{comment}{// Number of entries in AllHits array}}
\DoxyCodeLine{1034 }
\DoxyCodeLine{1035 HRESULT WINAPI}
\DoxyCodeLine{1036     D3DXIntersectSubset(}
\DoxyCodeLine{1037         LPD3DXBASEMESH pMesh,}
\DoxyCodeLine{1038         DWORD AttribId,}
\DoxyCodeLine{1039         CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pRayPos,}
\DoxyCodeLine{1040         CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pRayDir, }
\DoxyCodeLine{1041         BOOL    *pHit,              \textcolor{comment}{// True if any faces were intersected}}
\DoxyCodeLine{1042         DWORD   *pFaceIndex,        \textcolor{comment}{// index of closest face intersected}}
\DoxyCodeLine{1043         FLOAT   *pU,                \textcolor{comment}{// Barycentric Hit Coordinates    }}
\DoxyCodeLine{1044         FLOAT   *pV,                \textcolor{comment}{// Barycentric Hit Coordinates}}
\DoxyCodeLine{1045         FLOAT   *pDist,             \textcolor{comment}{// Ray-\/Intersection Parameter Distance}}
\DoxyCodeLine{1046         LPD3DXBUFFER *ppAllHits,    \textcolor{comment}{// Array of D3DXINTERSECTINFOs for all hits (not just closest) }}
\DoxyCodeLine{1047         DWORD   *pCountOfHits);     \textcolor{comment}{// Number of entries in AllHits array}}
\DoxyCodeLine{1048 }
\DoxyCodeLine{1049 }
\DoxyCodeLine{1050 HRESULT WINAPI D3DXSplitMesh}
\DoxyCodeLine{1051     (}
\DoxyCodeLine{1052     LPD3DXMESH pMeshIn,         }
\DoxyCodeLine{1053     CONST DWORD *pAdjacencyIn, }
\DoxyCodeLine{1054     CONST DWORD MaxSize,}
\DoxyCodeLine{1055     CONST DWORD Options,}
\DoxyCodeLine{1056     DWORD *pMeshesOut,}
\DoxyCodeLine{1057     LPD3DXBUFFER *ppMeshArrayOut,}
\DoxyCodeLine{1058     LPD3DXBUFFER *ppAdjacencyArrayOut,}
\DoxyCodeLine{1059     LPD3DXBUFFER *ppFaceRemapArrayOut,}
\DoxyCodeLine{1060     LPD3DXBUFFER *ppVertRemapArrayOut}
\DoxyCodeLine{1061     );}
\DoxyCodeLine{1062 }
\DoxyCodeLine{1063 BOOL WINAPI D3DXIntersectTri }
\DoxyCodeLine{1064 (}
\DoxyCodeLine{1065     CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *p0,           \textcolor{comment}{// Triangle vertex 0 position}}
\DoxyCodeLine{1066     CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *p1,           \textcolor{comment}{// Triangle vertex 1 position}}
\DoxyCodeLine{1067     CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *p2,           \textcolor{comment}{// Triangle vertex 2 position}}
\DoxyCodeLine{1068     CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pRayPos,      \textcolor{comment}{// Ray origin}}
\DoxyCodeLine{1069     CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pRayDir,      \textcolor{comment}{// Ray direction}}
\DoxyCodeLine{1070     FLOAT *pU,                       \textcolor{comment}{// Barycentric Hit Coordinates}}
\DoxyCodeLine{1071     FLOAT *pV,                       \textcolor{comment}{// Barycentric Hit Coordinates}}
\DoxyCodeLine{1072     FLOAT *pDist);                   \textcolor{comment}{// Ray-\/Intersection Parameter Distance}}
\DoxyCodeLine{1073 }
\DoxyCodeLine{1074 BOOL WINAPI}
\DoxyCodeLine{1075     D3DXSphereBoundProbe(}
\DoxyCodeLine{1076         CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pCenter,}
\DoxyCodeLine{1077         FLOAT Radius,}
\DoxyCodeLine{1078         CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pRayPosition,}
\DoxyCodeLine{1079         CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pRayDirection);}
\DoxyCodeLine{1080 }
\DoxyCodeLine{1081 BOOL WINAPI }
\DoxyCodeLine{1082     D3DXBoxBoundProbe(}
\DoxyCodeLine{1083         CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pMin, }
\DoxyCodeLine{1084         CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pMax,}
\DoxyCodeLine{1085         CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pRayPosition,}
\DoxyCodeLine{1086         CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pRayDirection);}
\DoxyCodeLine{1087 }
\DoxyCodeLine{1088 }
\DoxyCodeLine{1089 HRESULT WINAPI D3DXComputeTangentFrame(ID3DXMesh *pMesh,}
\DoxyCodeLine{1090                                        DWORD dwOptions);}
\DoxyCodeLine{1091 }
\DoxyCodeLine{1092 HRESULT WINAPI D3DXComputeTangentFrameEx(ID3DXMesh *pMesh,}
\DoxyCodeLine{1093                                          DWORD dwTextureInSemantic,}
\DoxyCodeLine{1094                                          DWORD dwTextureInIndex,}
\DoxyCodeLine{1095                                          DWORD dwUPartialOutSemantic,}
\DoxyCodeLine{1096                                          DWORD dwUPartialOutIndex,}
\DoxyCodeLine{1097                                          DWORD dwVPartialOutSemantic,}
\DoxyCodeLine{1098                                          DWORD dwVPartialOutIndex,}
\DoxyCodeLine{1099                                          DWORD dwNormalOutSemantic,}
\DoxyCodeLine{1100                                          DWORD dwNormalOutIndex,}
\DoxyCodeLine{1101                                          DWORD dwOptions,}
\DoxyCodeLine{1102                                          CONST DWORD *pdwAdjacency,}
\DoxyCodeLine{1103                                          FLOAT fPartialEdgeThreshold,}
\DoxyCodeLine{1104                                          FLOAT fSingularPointThreshold,}
\DoxyCodeLine{1105                                          FLOAT fNormalEdgeThreshold,}
\DoxyCodeLine{1106                                          ID3DXMesh **ppMeshOut,}
\DoxyCodeLine{1107                                          ID3DXBuffer **ppVertexMapping);}
\DoxyCodeLine{1108 }
\DoxyCodeLine{1109 }
\DoxyCodeLine{1110 \textcolor{comment}{//D3DXComputeTangent}}
\DoxyCodeLine{1111 \textcolor{comment}{//}}
\DoxyCodeLine{1112 \textcolor{comment}{//Computes the Tangent vectors for the TexStage texture coordinates}}
\DoxyCodeLine{1113 \textcolor{comment}{//and places the results in the TANGENT[TangentIndex] specified in the meshes' DECL}}
\DoxyCodeLine{1114 \textcolor{comment}{//puts the binorm in BINORM[BinormIndex] also specified in the decl.}}
\DoxyCodeLine{1115 \textcolor{comment}{//}}
\DoxyCodeLine{1116 \textcolor{comment}{//If neither the binorm or the tangnet are in the meshes declaration,}}
\DoxyCodeLine{1117 \textcolor{comment}{//the function will fail. }}
\DoxyCodeLine{1118 \textcolor{comment}{//}}
\DoxyCodeLine{1119 \textcolor{comment}{//If a tangent or Binorm field is in the Decl, but the user does not}}
\DoxyCodeLine{1120 \textcolor{comment}{//wish D3DXComputeTangent to replace them, then D3DX\_DEFAULT specified}}
\DoxyCodeLine{1121 \textcolor{comment}{//in the TangentIndex or BinormIndex will cause it to ignore the specified }}
\DoxyCodeLine{1122 \textcolor{comment}{//semantic.}}
\DoxyCodeLine{1123 \textcolor{comment}{//}}
\DoxyCodeLine{1124 \textcolor{comment}{//Wrap should be specified if the texture coordinates wrap.}}
\DoxyCodeLine{1125 }
\DoxyCodeLine{1126 HRESULT WINAPI D3DXComputeTangent(LPD3DXMESH Mesh,}
\DoxyCodeLine{1127                                  DWORD TexStage,}
\DoxyCodeLine{1128                                  DWORD TangentIndex,}
\DoxyCodeLine{1129                                  DWORD BinormIndex,}
\DoxyCodeLine{1130                                  DWORD Wrap,}
\DoxyCodeLine{1131                                  CONST DWORD *pAdjacency);}
\DoxyCodeLine{1132 }
\DoxyCodeLine{1133 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{1134 \textcolor{comment}{//}}
\DoxyCodeLine{1135 \textcolor{comment}{// UVAtlas apis}}
\DoxyCodeLine{1136 \textcolor{comment}{//}}
\DoxyCodeLine{1137 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{1138 \textcolor{keyword}{typedef} HRESULT (WINAPI *LPD3DXUVATLASCB)(FLOAT fPercentDone,  LPVOID lpUserContext);}
\DoxyCodeLine{1139 }
\DoxyCodeLine{1140 \textcolor{comment}{// This function creates atlases for meshes. There are two modes of operation,}}
\DoxyCodeLine{1141 \textcolor{comment}{// either based on the number of charts, or the maximum allowed stretch. If the}}
\DoxyCodeLine{1142 \textcolor{comment}{// maximum allowed stretch is 0, then each triangle will likely be in its own}}
\DoxyCodeLine{1143 \textcolor{comment}{// chart.}}
\DoxyCodeLine{1144 }
\DoxyCodeLine{1145 \textcolor{comment}{//}}
\DoxyCodeLine{1146 \textcolor{comment}{// The parameters are as follows:}}
\DoxyCodeLine{1147 \textcolor{comment}{//  pMesh -\/ Input mesh to calculate an atlas for. This must have a position}}
\DoxyCodeLine{1148 \textcolor{comment}{//          channel and at least a 2-\/d texture channel.}}
\DoxyCodeLine{1149 \textcolor{comment}{//  uMaxChartNumber -\/ The maximum number of charts required for the atlas.}}
\DoxyCodeLine{1150 \textcolor{comment}{//                    If this is 0, it will be parameterized based solely on}}
\DoxyCodeLine{1151 \textcolor{comment}{//                    stretch.}}
\DoxyCodeLine{1152 \textcolor{comment}{//  fMaxStretch -\/ The maximum amount of stretch, if 0, no stretching is allowed,}}
\DoxyCodeLine{1153 \textcolor{comment}{//                if 1, then any amount of stretching is allowed.}}
\DoxyCodeLine{1154 \textcolor{comment}{//  uWidth -\/ The width of the texture the atlas will be used on.}}
\DoxyCodeLine{1155 \textcolor{comment}{//  uHeight -\/ The height of the texture the atlas will be used on.}}
\DoxyCodeLine{1156 \textcolor{comment}{//  fGutter -\/ The minimum distance, in texels between two charts on the atlas.}}
\DoxyCodeLine{1157 \textcolor{comment}{//            this gets scaled by the width, so if fGutter is 2.5, and it is}}
\DoxyCodeLine{1158 \textcolor{comment}{//            used on a 512x512 texture, then the minimum distance will be}}
\DoxyCodeLine{1159 \textcolor{comment}{//            2.5 / 512 in u-\/v space.}}
\DoxyCodeLine{1160 \textcolor{comment}{//  dwTextureIndex -\/ Specifies which texture coordinate to write to in the}}
\DoxyCodeLine{1161 \textcolor{comment}{//                   output mesh (which is cloned from the input mesh). Useful}}
\DoxyCodeLine{1162 \textcolor{comment}{//                   if your vertex has multiple texture coordinates.}}
\DoxyCodeLine{1163 \textcolor{comment}{//  pdwAdjacency -\/ a pointer to an array with 3 DWORDs per face, indicating}}
\DoxyCodeLine{1164 \textcolor{comment}{//                 which triangles are adjacent to each other.}}
\DoxyCodeLine{1165 \textcolor{comment}{//  pfIMTArray -\/ a pointer to an array with 3 FLOATs per face, describing the}}
\DoxyCodeLine{1166 \textcolor{comment}{//               integrated metric tensor for that face. This lets you control}}
\DoxyCodeLine{1167 \textcolor{comment}{//               the way this triangle may be stretched in the atlas. The IMT}}
\DoxyCodeLine{1168 \textcolor{comment}{//               passed in will be 3 floats (a,b,c) and specify a symmetric}}
\DoxyCodeLine{1169 \textcolor{comment}{//               matrix (a b) that, given a vector (s,t), specifies the }}
\DoxyCodeLine{1170 \textcolor{comment}{//                      (b c)}}
\DoxyCodeLine{1171 \textcolor{comment}{//               distance between a vector v1 and a vector v2 = v1 + (s,t) as}}
\DoxyCodeLine{1172 \textcolor{comment}{//               sqrt((s, t) * M * (s, t)\string^T).}}
\DoxyCodeLine{1173 \textcolor{comment}{//               In other words, this lets one specify the magnitude of the}}
\DoxyCodeLine{1174 \textcolor{comment}{//               stretch in an arbitrary direction in u-\/v space. For example}}
\DoxyCodeLine{1175 \textcolor{comment}{//               if a = b = c = 1, then this scales the vector (1,1) by 2, and}}
\DoxyCodeLine{1176 \textcolor{comment}{//               the vector (1,-\/1) by 0. Note that this is multiplying the edge}}
\DoxyCodeLine{1177 \textcolor{comment}{//               length by the square of the matrix, so if you want the face to}}
\DoxyCodeLine{1178 \textcolor{comment}{//               stretch to twice its}}
\DoxyCodeLine{1179 \textcolor{comment}{//               size with no shearing, the IMT value should be (2, 0, 2), which}}
\DoxyCodeLine{1180 \textcolor{comment}{//               is just the identity matrix times 2.}}
\DoxyCodeLine{1181 \textcolor{comment}{//               Note that this assumes you have an orientation for the triangle}}
\DoxyCodeLine{1182 \textcolor{comment}{//               in some 2-\/D space. For D3DXUVAtlas, this space is created by}}
\DoxyCodeLine{1183 \textcolor{comment}{//               letting S be the direction from the first to the second}}
\DoxyCodeLine{1184 \textcolor{comment}{//               vertex, and T be the cross product between the normal and S.}}
\DoxyCodeLine{1185 \textcolor{comment}{//               }}
\DoxyCodeLine{1186 \textcolor{comment}{//  pCallback -\/ Since the atlas creation process can be very CPU intensive,}}
\DoxyCodeLine{1187 \textcolor{comment}{//              this allows the programmer to specify a function to be called}}
\DoxyCodeLine{1188 \textcolor{comment}{//              periodically, similarly to how it is done in the PRT simulation}}
\DoxyCodeLine{1189 \textcolor{comment}{//              engine.}}
\DoxyCodeLine{1190 \textcolor{comment}{//  fCallbackFrequency -\/ This lets you specify how often the callback will be}}
\DoxyCodeLine{1191 \textcolor{comment}{//                       called. A decent default should be 0.0001f.}}
\DoxyCodeLine{1192 \textcolor{comment}{//  pUserContext -\/ a void pointer to be passed back to the callback function}}
\DoxyCodeLine{1193 \textcolor{comment}{//  ppMeshOut -\/ A pointer to a location to store a pointer for the newly created}}
\DoxyCodeLine{1194 \textcolor{comment}{//              mesh.}}
\DoxyCodeLine{1195 \textcolor{comment}{//  ppFacePartitioning -\/ A pointer to a location to store a pointer for an array,}}
\DoxyCodeLine{1196 \textcolor{comment}{//                       one DWORD per face, giving the final partitioning}}
\DoxyCodeLine{1197 \textcolor{comment}{//                       created by the atlasing algorithm.}}
\DoxyCodeLine{1198 \textcolor{comment}{//  ppVertexRemapArray -\/ A pointer to a location to store a pointer for an array,}}
\DoxyCodeLine{1199 \textcolor{comment}{//                       one DWORD per vertex, giving the vertex it was copied}}
\DoxyCodeLine{1200 \textcolor{comment}{//                       from, if any vertices needed to be split.}}
\DoxyCodeLine{1201 \textcolor{comment}{//  pfMaxStretchOut -\/ A location to store the maximum stretch resulting from the}}
\DoxyCodeLine{1202 \textcolor{comment}{//                    atlasing algorithm.}}
\DoxyCodeLine{1203 \textcolor{comment}{//  puNumChartsOut -\/ A location to store the number of charts created, or if the}}
\DoxyCodeLine{1204 \textcolor{comment}{//                   maximum number of charts was too low, this gives the minimum}}
\DoxyCodeLine{1205 \textcolor{comment}{//                    number of charts needed to create an atlas.}}
\DoxyCodeLine{1206 }
\DoxyCodeLine{1207 HRESULT WINAPI D3DXUVAtlasCreate(LPD3DXMESH pMesh,}
\DoxyCodeLine{1208                                  UINT uMaxChartNumber,}
\DoxyCodeLine{1209                                  FLOAT fMaxStretch,}
\DoxyCodeLine{1210                                  UINT uWidth,}
\DoxyCodeLine{1211                                  UINT uHeight,}
\DoxyCodeLine{1212                                  FLOAT fGutter,}
\DoxyCodeLine{1213                                  DWORD dwTextureIndex,}
\DoxyCodeLine{1214                                  CONST DWORD *pdwAdjacency,}
\DoxyCodeLine{1215                                  FLOAT *pfIMTArray,}
\DoxyCodeLine{1216                                  LPD3DXUVATLASCB pCallback,}
\DoxyCodeLine{1217                                  FLOAT fCallbackFrequency,}
\DoxyCodeLine{1218                                  LPVOID pUserContext,}
\DoxyCodeLine{1219                                  LPD3DXMESH *ppMeshOut,}
\DoxyCodeLine{1220                                  LPD3DXBUFFER *ppFacePartitioning,}
\DoxyCodeLine{1221                                  LPD3DXBUFFER *ppVertexRemapArray,}
\DoxyCodeLine{1222                                  FLOAT *pfMaxStretchOut,}
\DoxyCodeLine{1223                                  UINT *puNumChartsOut);}
\DoxyCodeLine{1224 }
\DoxyCodeLine{1225 \textcolor{comment}{// This has the same exact arguments as Create, except that it does not perform the}}
\DoxyCodeLine{1226 \textcolor{comment}{// final packing step. This method allows one to get a partitioning out, and possibly}}
\DoxyCodeLine{1227 \textcolor{comment}{// modify it before sending it to be repacked. Note that if you change the}}
\DoxyCodeLine{1228 \textcolor{comment}{// partitioning, you'll also need to calculate new texture coordinates for any faces}}
\DoxyCodeLine{1229 \textcolor{comment}{// that have switched charts.}}
\DoxyCodeLine{1230 HRESULT WINAPI D3DXUVAtlasPartition(LPD3DXMESH pMesh,}
\DoxyCodeLine{1231                                     UINT uMaxChartNumber,}
\DoxyCodeLine{1232                                     FLOAT fMaxStretch,}
\DoxyCodeLine{1233                                     DWORD dwTextureIndex,}
\DoxyCodeLine{1234                                     CONST DWORD *pdwAdjacency,}
\DoxyCodeLine{1235                                     FLOAT *pfIMTArray,}
\DoxyCodeLine{1236                                     LPD3DXUVATLASCB pCallback,}
\DoxyCodeLine{1237                                     FLOAT fCallbackFrequency,}
\DoxyCodeLine{1238                                     LPVOID pUserContext,}
\DoxyCodeLine{1239                                     LPD3DXMESH *ppMeshOut,}
\DoxyCodeLine{1240                                     LPD3DXBUFFER *ppFacePartitioning,}
\DoxyCodeLine{1241                                     LPD3DXBUFFER *ppVertexRemapArray,}
\DoxyCodeLine{1242                                     FLOAT *pfMaxStretchOut,}
\DoxyCodeLine{1243                                     UINT *puNumChartsOut);}
\DoxyCodeLine{1244 }
\DoxyCodeLine{1245 \textcolor{comment}{// This takes the face partitioning result from Partition and packs it into an}}
\DoxyCodeLine{1246 \textcolor{comment}{// atlas of the given size.}}
\DoxyCodeLine{1247 HRESULT WINAPI D3DXUVAtlasPack(ID3DXMesh *pMesh,}
\DoxyCodeLine{1248                                UINT uWidth,}
\DoxyCodeLine{1249                                UINT uHeight,}
\DoxyCodeLine{1250                                FLOAT fGutter,}
\DoxyCodeLine{1251                                DWORD dwTextureIndex,}
\DoxyCodeLine{1252                                LPD3DXUVATLASCB pCallback,}
\DoxyCodeLine{1253                                FLOAT fCallbackFrequency,}
\DoxyCodeLine{1254                                LPVOID pUserContext,}
\DoxyCodeLine{1255                                LPD3DXBUFFER pFacePartitioning);}
\DoxyCodeLine{1256 }
\DoxyCodeLine{1257 }
\DoxyCodeLine{1258 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{1259 \textcolor{comment}{//}}
\DoxyCodeLine{1260 \textcolor{comment}{// IMT Calculation apis}}
\DoxyCodeLine{1261 \textcolor{comment}{//}}
\DoxyCodeLine{1262 \textcolor{comment}{// These functions all compute the Integrated Metric Tensor for use in the}}
\DoxyCodeLine{1263 \textcolor{comment}{// UVAtlas API. They all calculate the IMT with respect to the canonical}}
\DoxyCodeLine{1264 \textcolor{comment}{// triangle, where the coordinate system is set up so that the u axis goes}}
\DoxyCodeLine{1265 \textcolor{comment}{// from vertex 0 to 1 and the v axis is N x u. So, for example, the second}}
\DoxyCodeLine{1266 \textcolor{comment}{// vertex's canonical uv coordinates are (d,0) where d is the distance between}}
\DoxyCodeLine{1267 \textcolor{comment}{// vertices 0 and 1. This way the IMT does not depend on the parameterization}}
\DoxyCodeLine{1268 \textcolor{comment}{// of the mesh, and if the signal over the surface doesn't change, then}}
\DoxyCodeLine{1269 \textcolor{comment}{// the IMT doesn't need to be recalculated.}}
\DoxyCodeLine{1270 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{1271 }
\DoxyCodeLine{1272 \textcolor{comment}{// This callback is used by D3DXComputeIMTFromSignal.}}
\DoxyCodeLine{1273 \textcolor{comment}{//}}
\DoxyCodeLine{1274 \textcolor{comment}{// uv               -\/ The texture coordinate for the vertex}}
\DoxyCodeLine{1275 \textcolor{comment}{// uSignalDimension -\/ The number of floats to store in pfSignalOut}}
\DoxyCodeLine{1276 \textcolor{comment}{// pUserData        -\/ The pUserData pointer passed in to ComputeIMTFromSignal}}
\DoxyCodeLine{1277 \textcolor{comment}{// pfSignalOut      -\/ A pointer to where to store the signal data.}}
\DoxyCodeLine{1278 \textcolor{keyword}{typedef} HRESULT (WINAPI* LPD3DXIMTSIGNALCALLBACK)}
\DoxyCodeLine{1279      (CONST \mbox{\hyperlink{struct_d3_d_x_v_e_c_t_o_r2}{D3DXVECTOR2}} *uv,}
\DoxyCodeLine{1280       UINT uSignalDimension,}
\DoxyCodeLine{1281       VOID *pUserData,}
\DoxyCodeLine{1282       FLOAT *pfSignalOut);}
\DoxyCodeLine{1283 }
\DoxyCodeLine{1284 \textcolor{comment}{// This function is used to calculate the IMT from per vertex data. It sets}}
\DoxyCodeLine{1285 \textcolor{comment}{// up a linear system over the triangle, solves for the jacobian J, then}}
\DoxyCodeLine{1286 \textcolor{comment}{// constructs the IMT from that (J\string^TJ).}}
\DoxyCodeLine{1287 \textcolor{comment}{// This function allows you to calculate the IMT based off of any value in a}}
\DoxyCodeLine{1288 \textcolor{comment}{// mesh (color, normal, etc) by specifying the correct stride of the array.}}
\DoxyCodeLine{1289 \textcolor{comment}{// The IMT computed will cause areas of the mesh that have similar values to}}
\DoxyCodeLine{1290 \textcolor{comment}{// take up less space in the texture.}}
\DoxyCodeLine{1291 \textcolor{comment}{//}}
\DoxyCodeLine{1292 \textcolor{comment}{// pMesh            -\/ The mesh to calculate the IMT for.}}
\DoxyCodeLine{1293 \textcolor{comment}{// pVertexSignal    -\/ A float array of size uSignalStride * v, where v is the}}
\DoxyCodeLine{1294 \textcolor{comment}{//                    number of vertices in the mesh.}}
\DoxyCodeLine{1295 \textcolor{comment}{// uSignalDimension -\/ How many floats per vertex to use in calculating the IMT.}}
\DoxyCodeLine{1296 \textcolor{comment}{// uSignalStride    -\/ The number of bytes per vertex in the array. This must be}}
\DoxyCodeLine{1297 \textcolor{comment}{//                    a multiple of sizeof(float)}}
\DoxyCodeLine{1298 \textcolor{comment}{// ppIMTData        -\/ Where to store the buffer holding the IMT data}}
\DoxyCodeLine{1299 }
\DoxyCodeLine{1300 HRESULT WINAPI D3DXComputeIMTFromPerVertexSignal (}
\DoxyCodeLine{1301     LPD3DXMESH pMesh,}
\DoxyCodeLine{1302     CONST FLOAT *pfVertexSignal, \textcolor{comment}{// uSignalDimension floats per vertex}}
\DoxyCodeLine{1303     UINT uSignalDimension,}
\DoxyCodeLine{1304     UINT uSignalStride,         \textcolor{comment}{// stride of signal in bytes}}
\DoxyCodeLine{1305     DWORD dwOptions,            \textcolor{comment}{// reserved for future use}}
\DoxyCodeLine{1306     LPD3DXBUFFER *ppIMTData);}
\DoxyCodeLine{1307 }
\DoxyCodeLine{1308 \textcolor{comment}{// This function is used to calculate the IMT from data that varies over the}}
\DoxyCodeLine{1309 \textcolor{comment}{// surface of the mesh (generally at a higher frequency than vertex data).}}
\DoxyCodeLine{1310 \textcolor{comment}{// This function requires the mesh to already be parameterized (so it already}}
\DoxyCodeLine{1311 \textcolor{comment}{// has texture coordinates). It allows the user to define a signal arbitrarily}}
\DoxyCodeLine{1312 \textcolor{comment}{// over the surface of the mesh.}}
\DoxyCodeLine{1313 \textcolor{comment}{//}}
\DoxyCodeLine{1314 \textcolor{comment}{// pMesh            -\/ The mesh to calculate the IMT for.}}
\DoxyCodeLine{1315 \textcolor{comment}{// dwTextureIndex   -\/ This describes which set of texture coordinates in the}}
\DoxyCodeLine{1316 \textcolor{comment}{//                    mesh to use.}}
\DoxyCodeLine{1317 \textcolor{comment}{// uSignalDimension -\/ How many components there are in the signal.}}
\DoxyCodeLine{1318 \textcolor{comment}{// fMaxUVDistance   -\/ The subdivision will continue until the distance between}}
\DoxyCodeLine{1319 \textcolor{comment}{//                    all vertices is at most fMaxUVDistance.}}
\DoxyCodeLine{1320 \textcolor{comment}{// dwOptions        -\/ reserved for future use}}
\DoxyCodeLine{1321 \textcolor{comment}{// pSignalCallback  -\/ The callback to use to get the signal.}}
\DoxyCodeLine{1322 \textcolor{comment}{// pUserData        -\/ A pointer that will be passed in to the callback.}}
\DoxyCodeLine{1323 \textcolor{comment}{// ppIMTData        -\/ Where to store the buffer holding the IMT data}}
\DoxyCodeLine{1324 HRESULT WINAPI D3DXComputeIMTFromSignal(}
\DoxyCodeLine{1325      LPD3DXMESH pMesh,}
\DoxyCodeLine{1326      DWORD dwTextureIndex,}
\DoxyCodeLine{1327      UINT uSignalDimension,}
\DoxyCodeLine{1328      FLOAT fMaxUVDistance,}
\DoxyCodeLine{1329      DWORD dwOptions, \textcolor{comment}{// reserved for future use}}
\DoxyCodeLine{1330      LPD3DXIMTSIGNALCALLBACK pSignalCallback,}
\DoxyCodeLine{1331      VOID *pUserData,}
\DoxyCodeLine{1332      LPD3DXBUFFER *ppIMTData);}
\DoxyCodeLine{1333 }
\DoxyCodeLine{1334 \textcolor{comment}{// This function is used to calculate the IMT from texture data. Given a texture}}
\DoxyCodeLine{1335 \textcolor{comment}{// that maps over the surface of the mesh, the algorithm computes the IMT for}}
\DoxyCodeLine{1336 \textcolor{comment}{// each face. This will cause large areas that are very similar to take up less}}
\DoxyCodeLine{1337 \textcolor{comment}{// room when parameterized with UVAtlas. The texture is assumed to be}}
\DoxyCodeLine{1338 \textcolor{comment}{// interpolated over the mesh bilinearly.}}
\DoxyCodeLine{1339 \textcolor{comment}{//}}
\DoxyCodeLine{1340 \textcolor{comment}{// pMesh            -\/ The mesh to calculate the IMT for.}}
\DoxyCodeLine{1341 \textcolor{comment}{// pTexture         -\/ The texture to load data from.}}
\DoxyCodeLine{1342 \textcolor{comment}{// dwTextureIndex   -\/ This describes which set of texture coordinates in the}}
\DoxyCodeLine{1343 \textcolor{comment}{//                    mesh to use.}}
\DoxyCodeLine{1344 \textcolor{comment}{// dwOptions        -\/ Combination of one or more D3DXIMT flags.}}
\DoxyCodeLine{1345 \textcolor{comment}{// ppIMTData        -\/ Where to store the buffer holding the IMT data}}
\DoxyCodeLine{1346 HRESULT WINAPI D3DXComputeIMTFromTexture (}
\DoxyCodeLine{1347      LPD3DXMESH pMesh,}
\DoxyCodeLine{1348      LPDIRECT3DTEXTURE9 pTexture,}
\DoxyCodeLine{1349      DWORD dwTextureIndex,}
\DoxyCodeLine{1350      DWORD dwOptions,}
\DoxyCodeLine{1351      LPD3DXBUFFER *ppIMTData);}
\DoxyCodeLine{1352 }
\DoxyCodeLine{1353 \textcolor{comment}{// This function is very similar to ComputeIMTFromTexture, but it uses a}}
\DoxyCodeLine{1354 \textcolor{comment}{// float array to pass in the data, and it can calculate higher dimensional}}
\DoxyCodeLine{1355 \textcolor{comment}{// values than 4.}}
\DoxyCodeLine{1356 \textcolor{comment}{//}}
\DoxyCodeLine{1357 \textcolor{comment}{// pMesh            -\/ The mesh to calculate the IMT for.}}
\DoxyCodeLine{1358 \textcolor{comment}{// dwTextureIndex   -\/ This describes which set of texture coordinates in the}}
\DoxyCodeLine{1359 \textcolor{comment}{//                    mesh to use.}}
\DoxyCodeLine{1360 \textcolor{comment}{// pfFloatArray     -\/ a pointer to a float array of size}}
\DoxyCodeLine{1361 \textcolor{comment}{//                    uWidth*uHeight*uComponents}}
\DoxyCodeLine{1362 \textcolor{comment}{// uWidth           -\/ The width of the texture}}
\DoxyCodeLine{1363 \textcolor{comment}{// uHeight          -\/ The height of the texture}}
\DoxyCodeLine{1364 \textcolor{comment}{// uSignalDimension -\/ The number of floats per texel in the signal}}
\DoxyCodeLine{1365 \textcolor{comment}{// uComponents      -\/ The number of floats in each texel}}
\DoxyCodeLine{1366 \textcolor{comment}{// dwOptions        -\/ Combination of one or more D3DXIMT flags}}
\DoxyCodeLine{1367 \textcolor{comment}{// ppIMTData        -\/ Where to store the buffer holding the IMT data}}
\DoxyCodeLine{1368 HRESULT WINAPI D3DXComputeIMTFromPerTexelSignal(LPD3DXMESH pMesh,}
\DoxyCodeLine{1369                                                 DWORD dwTextureIndex,}
\DoxyCodeLine{1370                                                 FLOAT *pfTexelSignal,}
\DoxyCodeLine{1371                                                 UINT uWidth,}
\DoxyCodeLine{1372                                                 UINT uHeight,}
\DoxyCodeLine{1373                                                 UINT uSignalDimension,}
\DoxyCodeLine{1374                                                 UINT uComponents,}
\DoxyCodeLine{1375                                                 DWORD dwOptions,}
\DoxyCodeLine{1376                                                 LPD3DXBUFFER *ppIMTData);}
\DoxyCodeLine{1377 }
\DoxyCodeLine{1378 HRESULT WINAPI}
\DoxyCodeLine{1379     D3DXConvertMeshSubsetToSingleStrip(}
\DoxyCodeLine{1380         LPD3DXBASEMESH MeshIn,}
\DoxyCodeLine{1381         DWORD AttribId,}
\DoxyCodeLine{1382         DWORD IBOptions,}
\DoxyCodeLine{1383         LPDIRECT3DINDEXBUFFER9 *ppIndexBuffer,}
\DoxyCodeLine{1384         DWORD *pNumIndices);}
\DoxyCodeLine{1385 }
\DoxyCodeLine{1386 HRESULT WINAPI}
\DoxyCodeLine{1387     D3DXConvertMeshSubsetToStrips(}
\DoxyCodeLine{1388         LPD3DXBASEMESH MeshIn,}
\DoxyCodeLine{1389         DWORD AttribId,}
\DoxyCodeLine{1390         DWORD IBOptions,}
\DoxyCodeLine{1391         LPDIRECT3DINDEXBUFFER9 *ppIndexBuffer,}
\DoxyCodeLine{1392         DWORD *pNumIndices,}
\DoxyCodeLine{1393         LPD3DXBUFFER *ppStripLengths,}
\DoxyCodeLine{1394         DWORD *pNumStrips);}
\DoxyCodeLine{1395 }
\DoxyCodeLine{1396         }
\DoxyCodeLine{1397 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{1398 \textcolor{comment}{//}}
\DoxyCodeLine{1399 \textcolor{comment}{//  D3DXOptimizeFaces:}}
\DoxyCodeLine{1400 \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{1401 \textcolor{comment}{//  Generate a face remapping for a triangle list that more effectively utilizes}}
\DoxyCodeLine{1402 \textcolor{comment}{//    vertex caches.  This optimization is identical to the one provided}}
\DoxyCodeLine{1403 \textcolor{comment}{//    by ID3DXMesh::Optimize with the hardware independent option enabled.}}
\DoxyCodeLine{1404 \textcolor{comment}{//}}
\DoxyCodeLine{1405 \textcolor{comment}{//  Parameters:}}
\DoxyCodeLine{1406 \textcolor{comment}{//   pbIndices}}
\DoxyCodeLine{1407 \textcolor{comment}{//      Triangle list indices to use for generating a vertex ordering}}
\DoxyCodeLine{1408 \textcolor{comment}{//   NumFaces}}
\DoxyCodeLine{1409 \textcolor{comment}{//      Number of faces in the triangle list}}
\DoxyCodeLine{1410 \textcolor{comment}{//   NumVertices}}
\DoxyCodeLine{1411 \textcolor{comment}{//      Number of vertices referenced by the triangle list}}
\DoxyCodeLine{1412 \textcolor{comment}{//   b32BitIndices}}
\DoxyCodeLine{1413 \textcolor{comment}{//      TRUE if indices are 32 bit, FALSE if indices are 16 bit}}
\DoxyCodeLine{1414 \textcolor{comment}{//   pFaceRemap}}
\DoxyCodeLine{1415 \textcolor{comment}{//      Destination buffer to store face ordering}}
\DoxyCodeLine{1416 \textcolor{comment}{//      The number stored for a given element is where in the new ordering}}
\DoxyCodeLine{1417 \textcolor{comment}{//        the face will have come from.  See ID3DXMesh::Optimize for more info.}}
\DoxyCodeLine{1418 \textcolor{comment}{//}}
\DoxyCodeLine{1419 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{1420 HRESULT WINAPI}
\DoxyCodeLine{1421     D3DXOptimizeFaces(}
\DoxyCodeLine{1422         LPCVOID pbIndices, }
\DoxyCodeLine{1423         UINT cFaces, }
\DoxyCodeLine{1424         UINT cVertices, }
\DoxyCodeLine{1425         BOOL b32BitIndices, }
\DoxyCodeLine{1426         DWORD* pFaceRemap);}
\DoxyCodeLine{1427         }
\DoxyCodeLine{1428 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{1429 \textcolor{comment}{//}}
\DoxyCodeLine{1430 \textcolor{comment}{//  D3DXOptimizeVertices:}}
\DoxyCodeLine{1431 \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{1432 \textcolor{comment}{//  Generate a vertex remapping to optimize for in order use of vertices for }}
\DoxyCodeLine{1433 \textcolor{comment}{//    a given set of indices.  This is commonly used after applying the face}}
\DoxyCodeLine{1434 \textcolor{comment}{//    remap generated by D3DXOptimizeFaces}}
\DoxyCodeLine{1435 \textcolor{comment}{//}}
\DoxyCodeLine{1436 \textcolor{comment}{//  Parameters:}}
\DoxyCodeLine{1437 \textcolor{comment}{//   pbIndices}}
\DoxyCodeLine{1438 \textcolor{comment}{//      Triangle list indices to use for generating a vertex ordering}}
\DoxyCodeLine{1439 \textcolor{comment}{//   NumFaces}}
\DoxyCodeLine{1440 \textcolor{comment}{//      Number of faces in the triangle list}}
\DoxyCodeLine{1441 \textcolor{comment}{//   NumVertices}}
\DoxyCodeLine{1442 \textcolor{comment}{//      Number of vertices referenced by the triangle list}}
\DoxyCodeLine{1443 \textcolor{comment}{//   b32BitIndices}}
\DoxyCodeLine{1444 \textcolor{comment}{//      TRUE if indices are 32 bit, FALSE if indices are 16 bit}}
\DoxyCodeLine{1445 \textcolor{comment}{//   pVertexRemap}}
\DoxyCodeLine{1446 \textcolor{comment}{//      Destination buffer to store vertex ordering}}
\DoxyCodeLine{1447 \textcolor{comment}{//      The number stored for a given element is where in the new ordering}}
\DoxyCodeLine{1448 \textcolor{comment}{//        the vertex will have come from.  See ID3DXMesh::Optimize for more info.}}
\DoxyCodeLine{1449 \textcolor{comment}{//}}
\DoxyCodeLine{1450 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{1451 HRESULT WINAPI}
\DoxyCodeLine{1452     D3DXOptimizeVertices(}
\DoxyCodeLine{1453         LPCVOID pbIndices, }
\DoxyCodeLine{1454         UINT cFaces, }
\DoxyCodeLine{1455         UINT cVertices, }
\DoxyCodeLine{1456         BOOL b32BitIndices, }
\DoxyCodeLine{1457         DWORD* pVertexRemap);}
\DoxyCodeLine{1458 }
\DoxyCodeLine{1459 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{1460 \}}
\DoxyCodeLine{1461 \textcolor{preprocessor}{\#endif }\textcolor{comment}{//\_\_cplusplus}}
\DoxyCodeLine{1462 }
\DoxyCodeLine{1463 }
\DoxyCodeLine{1464 \textcolor{comment}{//===========================================================================}}
\DoxyCodeLine{1465 \textcolor{comment}{//}}
\DoxyCodeLine{1466 \textcolor{comment}{//  Data structures for Spherical Harmonic Precomputation}}
\DoxyCodeLine{1467 \textcolor{comment}{//}}
\DoxyCodeLine{1468 \textcolor{comment}{//}}
\DoxyCodeLine{1469 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{1470 }
\DoxyCodeLine{1471 \textcolor{keyword}{typedef} \textcolor{keyword}{enum} \_D3DXSHCOMPRESSQUALITYTYPE \{}
\DoxyCodeLine{1472     D3DXSHCQUAL\_FASTLOWQUALITY  = 1,}
\DoxyCodeLine{1473     D3DXSHCQUAL\_SLOWHIGHQUALITY = 2,}
\DoxyCodeLine{1474     D3DXSHCQUAL\_FORCE\_DWORD     = 0x7fffffff}
\DoxyCodeLine{1475 \} D3DXSHCOMPRESSQUALITYTYPE;}
\DoxyCodeLine{1476 }
\DoxyCodeLine{1477 \textcolor{keyword}{typedef} \textcolor{keyword}{enum} \_D3DXSHGPUSIMOPT \{}
\DoxyCodeLine{1478     D3DXSHGPUSIMOPT\_SHADOWRES256  = 1,}
\DoxyCodeLine{1479     D3DXSHGPUSIMOPT\_SHADOWRES512  = 0,}
\DoxyCodeLine{1480     D3DXSHGPUSIMOPT\_SHADOWRES1024 = 2,}
\DoxyCodeLine{1481     D3DXSHGPUSIMOPT\_SHADOWRES2048 = 3,}
\DoxyCodeLine{1482 }
\DoxyCodeLine{1483     D3DXSHGPUSIMOPT\_HIGHQUALITY = 4,    }
\DoxyCodeLine{1484     }
\DoxyCodeLine{1485     D3DXSHGPUSIMOPT\_FORCE\_DWORD = 0x7fffffff}
\DoxyCodeLine{1486 \} D3DXSHGPUSIMOPT;}
\DoxyCodeLine{1487 }
\DoxyCodeLine{1488 \textcolor{comment}{// for all properties that are colors the luminance is computed}}
\DoxyCodeLine{1489 \textcolor{comment}{// if the simulator is run with a single channel using the following}}
\DoxyCodeLine{1490 \textcolor{comment}{// formula:  R * 0.2125 + G * 0.7154 + B * 0.0721}}
\DoxyCodeLine{1491 }
\DoxyCodeLine{1492 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{struct___d3_d_x_s_h_m_a_t_e_r_i_a_l}{\_D3DXSHMATERIAL}} \{}
\DoxyCodeLine{1493     \mbox{\hyperlink{struct___d3_d_c_o_l_o_r_v_a_l_u_e}{D3DCOLORVALUE}} Diffuse;  \textcolor{comment}{// Diffuse albedo of the surface.  (Ignored if object is a Mirror)}}
\DoxyCodeLine{1494     BOOL          bMirror;  \textcolor{comment}{// Must be set to FALSE.  bMirror == TRUE not currently supported}}
\DoxyCodeLine{1495     BOOL          bSubSurf; \textcolor{comment}{// true if the object does subsurface scattering -\/ can't do this and be a mirror}}
\DoxyCodeLine{1496 }
\DoxyCodeLine{1497     \textcolor{comment}{// subsurface scattering parameters }}
\DoxyCodeLine{1498     FLOAT         RelativeIndexOfRefraction;}
\DoxyCodeLine{1499     \mbox{\hyperlink{struct___d3_d_c_o_l_o_r_v_a_l_u_e}{D3DCOLORVALUE}} Absorption;}
\DoxyCodeLine{1500     \mbox{\hyperlink{struct___d3_d_c_o_l_o_r_v_a_l_u_e}{D3DCOLORVALUE}} ReducedScattering;}
\DoxyCodeLine{1501 }
\DoxyCodeLine{1502 \} \mbox{\hyperlink{struct___d3_d_x_s_h_m_a_t_e_r_i_a_l}{D3DXSHMATERIAL}};}
\DoxyCodeLine{1503 }
\DoxyCodeLine{1504 \textcolor{comment}{// allocated in D3DXSHPRTCompSplitMeshSC}}
\DoxyCodeLine{1505 \textcolor{comment}{// vertices are duplicated into multiple super clusters but}}
\DoxyCodeLine{1506 \textcolor{comment}{// only have a valid status in one super cluster (fill in the rest)}}
\DoxyCodeLine{1507 }
\DoxyCodeLine{1508 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{struct___d3_d_x_s_h_p_r_t_s_p_l_i_t_m_e_s_h_v_e_r_t_d_a_t_a}{\_D3DXSHPRTSPLITMESHVERTDATA}} \{}
\DoxyCodeLine{1509     UINT  uVertRemap;   \textcolor{comment}{// vertex in original mesh this corresponds to}}
\DoxyCodeLine{1510     UINT  uSubCluster;  \textcolor{comment}{// cluster index relative to super cluster}}
\DoxyCodeLine{1511     UCHAR ucVertStatus; \textcolor{comment}{// 1 if vertex has valid data, 0 if it is "{}fill"{}}}
\DoxyCodeLine{1512 \} \mbox{\hyperlink{struct___d3_d_x_s_h_p_r_t_s_p_l_i_t_m_e_s_h_v_e_r_t_d_a_t_a}{D3DXSHPRTSPLITMESHVERTDATA}};}
\DoxyCodeLine{1513 }
\DoxyCodeLine{1514 \textcolor{comment}{// used in D3DXSHPRTCompSplitMeshSC}}
\DoxyCodeLine{1515 \textcolor{comment}{// information for each super cluster that maps into face/vert arrays}}
\DoxyCodeLine{1516 }
\DoxyCodeLine{1517 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{struct___d3_d_x_s_h_p_r_t_s_p_l_i_t_m_e_s_h_c_l_u_s_t_e_r_d_a_t_a}{\_D3DXSHPRTSPLITMESHCLUSTERDATA}} \{}
\DoxyCodeLine{1518     UINT uVertStart;     \textcolor{comment}{// initial index into remapped vertex array}}
\DoxyCodeLine{1519     UINT uVertLength;    \textcolor{comment}{// number of vertices in this super cluster}}
\DoxyCodeLine{1520     }
\DoxyCodeLine{1521     UINT uFaceStart;     \textcolor{comment}{// initial index into face array}}
\DoxyCodeLine{1522     UINT uFaceLength;    \textcolor{comment}{// number of faces in this super cluster}}
\DoxyCodeLine{1523     }
\DoxyCodeLine{1524     UINT uClusterStart;  \textcolor{comment}{// initial index into cluster array}}
\DoxyCodeLine{1525     UINT uClusterLength; \textcolor{comment}{// number of clusters in this super cluster}}
\DoxyCodeLine{1526 \} \mbox{\hyperlink{struct___d3_d_x_s_h_p_r_t_s_p_l_i_t_m_e_s_h_c_l_u_s_t_e_r_d_a_t_a}{D3DXSHPRTSPLITMESHCLUSTERDATA}};}
\DoxyCodeLine{1527 }
\DoxyCodeLine{1528 \textcolor{comment}{// call back function for simulator}}
\DoxyCodeLine{1529 \textcolor{comment}{// return S\_OK to keep running the simulator -\/ anything else represents}}
\DoxyCodeLine{1530 \textcolor{comment}{// failure and the simulator will abort.}}
\DoxyCodeLine{1531 }
\DoxyCodeLine{1532 \textcolor{keyword}{typedef} HRESULT (WINAPI *LPD3DXSHPRTSIMCB)(\textcolor{keywordtype}{float} fPercentDone,  LPVOID lpUserContext);}
\DoxyCodeLine{1533 }
\DoxyCodeLine{1534 \textcolor{comment}{// interfaces for PRT buffers/simulator}}
\DoxyCodeLine{1535 }
\DoxyCodeLine{1536 \textcolor{comment}{// GUIDs}}
\DoxyCodeLine{1537 \textcolor{comment}{// \{F1827E47-\/00A8-\/49cd-\/908C-\/9D11955F8728\}}}
\DoxyCodeLine{1538 DEFINE\_GUID(IID\_ID3DXPRTBuffer, }
\DoxyCodeLine{1539 0xf1827e47, 0xa8, 0x49cd, 0x90, 0x8c, 0x9d, 0x11, 0x95, 0x5f, 0x87, 0x28);}
\DoxyCodeLine{1540 }
\DoxyCodeLine{1541 \textcolor{comment}{// \{A758D465-\/FE8D-\/45ad-\/9CF0-\/D01E56266A07\}}}
\DoxyCodeLine{1542 DEFINE\_GUID(IID\_ID3DXPRTCompBuffer, }
\DoxyCodeLine{1543 0xa758d465, 0xfe8d, 0x45ad, 0x9c, 0xf0, 0xd0, 0x1e, 0x56, 0x26, 0x6a, 0x7);}
\DoxyCodeLine{1544 }
\DoxyCodeLine{1545 \textcolor{comment}{// \{838F01EC-\/9729-\/4527-\/AADB-\/DF70ADE7FEA9\}}}
\DoxyCodeLine{1546 DEFINE\_GUID(IID\_ID3DXTextureGutterHelper, }
\DoxyCodeLine{1547 0x838f01ec, 0x9729, 0x4527, 0xaa, 0xdb, 0xdf, 0x70, 0xad, 0xe7, 0xfe, 0xa9);}
\DoxyCodeLine{1548 }
\DoxyCodeLine{1549 \textcolor{comment}{// \{683A4278-\/CD5F-\/4d24-\/90AD-\/C4E1B6855D53\}}}
\DoxyCodeLine{1550 DEFINE\_GUID(IID\_ID3DXPRTEngine, }
\DoxyCodeLine{1551 0x683a4278, 0xcd5f, 0x4d24, 0x90, 0xad, 0xc4, 0xe1, 0xb6, 0x85, 0x5d, 0x53);}
\DoxyCodeLine{1552 }
\DoxyCodeLine{1553 \textcolor{comment}{// interface defenitions}}
\DoxyCodeLine{1554 }
\DoxyCodeLine{1555 \textcolor{keyword}{typedef} \textcolor{keyword}{interface }ID3DXTextureGutterHelper ID3DXTextureGutterHelper;}
\DoxyCodeLine{1556 \textcolor{keyword}{typedef} \textcolor{keyword}{interface }ID3DXPRTBuffer ID3DXPRTBuffer;}
\DoxyCodeLine{1557 }
\DoxyCodeLine{1558 \textcolor{preprocessor}{\#undef INTERFACE}}
\DoxyCodeLine{1559 \textcolor{preprocessor}{\#define INTERFACE ID3DXPRTBuffer}}
\DoxyCodeLine{1560 }
\DoxyCodeLine{1561 \textcolor{comment}{// Buffer interface -\/ contains "{}NumSamples"{} samples}}
\DoxyCodeLine{1562 \textcolor{comment}{// each sample in memory is stored as NumCoeffs scalars per channel (1 or 3)}}
\DoxyCodeLine{1563 \textcolor{comment}{// Same interface is used for both Vertex and Pixel PRT buffers}}
\DoxyCodeLine{1564 }
\DoxyCodeLine{1565 DECLARE\_INTERFACE\_(ID3DXPRTBuffer, IUnknown)}
\DoxyCodeLine{1566 \{}
\DoxyCodeLine{1567     \textcolor{comment}{// IUnknown}}
\DoxyCodeLine{1568     STDMETHOD(QueryInterface)(THIS\_ REFIID iid, LPVOID *ppv) PURE;}
\DoxyCodeLine{1569     STDMETHOD\_(ULONG, AddRef)(THIS) PURE;}
\DoxyCodeLine{1570     STDMETHOD\_(ULONG, Release)(THIS) PURE;}
\DoxyCodeLine{1571 }
\DoxyCodeLine{1572     \textcolor{comment}{// ID3DXPRTBuffer}}
\DoxyCodeLine{1573     STDMETHOD\_(UINT, GetNumSamples)(THIS) PURE;}
\DoxyCodeLine{1574     STDMETHOD\_(UINT, GetNumCoeffs)(THIS) PURE;}
\DoxyCodeLine{1575     STDMETHOD\_(UINT, GetNumChannels)(THIS) PURE;}
\DoxyCodeLine{1576 }
\DoxyCodeLine{1577     STDMETHOD\_(BOOL, IsTexture)(THIS) PURE;}
\DoxyCodeLine{1578     STDMETHOD\_(UINT, GetWidth)(THIS) PURE;}
\DoxyCodeLine{1579     STDMETHOD\_(UINT, GetHeight)(THIS) PURE;}
\DoxyCodeLine{1580 }
\DoxyCodeLine{1581     \textcolor{comment}{// changes the number of samples allocated in the buffer}}
\DoxyCodeLine{1582     STDMETHOD(Resize)(THIS\_ UINT NewSize) PURE;}
\DoxyCodeLine{1583 }
\DoxyCodeLine{1584     \textcolor{comment}{// ppData will point to the memory location where sample Start begins}}
\DoxyCodeLine{1585     \textcolor{comment}{// pointer is valid for at least NumSamples samples}}
\DoxyCodeLine{1586     STDMETHOD(LockBuffer)(THIS\_ UINT Start, UINT NumSamples, FLOAT **ppData) PURE;}
\DoxyCodeLine{1587     STDMETHOD(UnlockBuffer)(THIS) PURE;}
\DoxyCodeLine{1588 }
\DoxyCodeLine{1589     \textcolor{comment}{// every scalar in buffer is multiplied by Scale}}
\DoxyCodeLine{1590     STDMETHOD(ScaleBuffer)(THIS\_ FLOAT Scale) PURE;}
\DoxyCodeLine{1591     }
\DoxyCodeLine{1592     \textcolor{comment}{// every scalar contains the sum of this and pBuffers values}}
\DoxyCodeLine{1593     \textcolor{comment}{// pBuffer must have the same storage class/dimensions }}
\DoxyCodeLine{1594     STDMETHOD(AddBuffer)(THIS\_ LPD3DXPRTBUFFER pBuffer) PURE;}
\DoxyCodeLine{1595 }
\DoxyCodeLine{1596     \textcolor{comment}{// GutterHelper (described below) will fill in the gutter}}
\DoxyCodeLine{1597     \textcolor{comment}{// regions of a texture by interpolating "{}internal"{} values}}
\DoxyCodeLine{1598     STDMETHOD(AttachGH)(THIS\_ LPD3DXTEXTUREGUTTERHELPER) PURE;}
\DoxyCodeLine{1599     STDMETHOD(ReleaseGH)(THIS) PURE;}
\DoxyCodeLine{1600     }
\DoxyCodeLine{1601     \textcolor{comment}{// Evaluates attached gutter helper on the contents of this buffer}}
\DoxyCodeLine{1602     STDMETHOD(EvalGH)(THIS) PURE;}
\DoxyCodeLine{1603 }
\DoxyCodeLine{1604     \textcolor{comment}{// extracts a given channel into texture pTexture}}
\DoxyCodeLine{1605     \textcolor{comment}{// NumCoefficients starting from StartCoefficient are copied}}
\DoxyCodeLine{1606     STDMETHOD(ExtractTexture)(THIS\_ UINT Channel, UINT StartCoefficient, }
\DoxyCodeLine{1607                               UINT NumCoefficients, LPDIRECT3DTEXTURE9 pTexture) PURE;}
\DoxyCodeLine{1608 }
\DoxyCodeLine{1609     \textcolor{comment}{// extracts NumCoefficients coefficients into mesh -\/ only applicable on single channel}}
\DoxyCodeLine{1610     \textcolor{comment}{// buffers, otherwise just lockbuffer and copy data.  With SHPRT data NumCoefficients }}
\DoxyCodeLine{1611     \textcolor{comment}{// should be Order\string^2}}
\DoxyCodeLine{1612     STDMETHOD(ExtractToMesh)(THIS\_ UINT NumCoefficients, D3DDECLUSAGE Usage, UINT UsageIndexStart,}
\DoxyCodeLine{1613                              LPD3DXMESH pScene) PURE;}
\DoxyCodeLine{1614 }
\DoxyCodeLine{1615 \};}
\DoxyCodeLine{1616 }
\DoxyCodeLine{1617 \textcolor{keyword}{typedef} \textcolor{keyword}{interface }ID3DXPRTCompBuffer ID3DXPRTCompBuffer;}
\DoxyCodeLine{1618 \textcolor{keyword}{typedef} \textcolor{keyword}{interface }ID3DXPRTCompBuffer *LPD3DXPRTCOMPBUFFER;}
\DoxyCodeLine{1619 }
\DoxyCodeLine{1620 \textcolor{preprocessor}{\#undef INTERFACE}}
\DoxyCodeLine{1621 \textcolor{preprocessor}{\#define INTERFACE ID3DXPRTCompBuffer}}
\DoxyCodeLine{1622 }
\DoxyCodeLine{1623 \textcolor{comment}{// compressed buffers stored a compressed version of a PRTBuffer}}
\DoxyCodeLine{1624 }
\DoxyCodeLine{1625 DECLARE\_INTERFACE\_(ID3DXPRTCompBuffer, IUnknown)}
\DoxyCodeLine{1626 \{}
\DoxyCodeLine{1627     \textcolor{comment}{// IUnknown}}
\DoxyCodeLine{1628     STDMETHOD(QueryInterface)(THIS\_ REFIID iid, LPVOID *ppv) PURE;}
\DoxyCodeLine{1629     STDMETHOD\_(ULONG, AddRef)(THIS) PURE;}
\DoxyCodeLine{1630     STDMETHOD\_(ULONG, Release)(THIS) PURE;}
\DoxyCodeLine{1631 }
\DoxyCodeLine{1632     \textcolor{comment}{// ID3DPRTCompBuffer}}
\DoxyCodeLine{1633 }
\DoxyCodeLine{1634     \textcolor{comment}{// NumCoeffs and NumChannels are properties of input buffer}}
\DoxyCodeLine{1635     STDMETHOD\_(UINT, GetNumSamples)(THIS) PURE;}
\DoxyCodeLine{1636     STDMETHOD\_(UINT, GetNumCoeffs)(THIS) PURE;}
\DoxyCodeLine{1637     STDMETHOD\_(UINT, GetNumChannels)(THIS) PURE;}
\DoxyCodeLine{1638 }
\DoxyCodeLine{1639     STDMETHOD\_(BOOL, IsTexture)(THIS) PURE;}
\DoxyCodeLine{1640     STDMETHOD\_(UINT, GetWidth)(THIS) PURE;}
\DoxyCodeLine{1641     STDMETHOD\_(UINT, GetHeight)(THIS) PURE;}
\DoxyCodeLine{1642 }
\DoxyCodeLine{1643     \textcolor{comment}{// number of clusters, and PCA vectors per-\/cluster}}
\DoxyCodeLine{1644     STDMETHOD\_(UINT, GetNumClusters)(THIS) PURE;}
\DoxyCodeLine{1645     STDMETHOD\_(UINT, GetNumPCA)(THIS) PURE;}
\DoxyCodeLine{1646 }
\DoxyCodeLine{1647     \textcolor{comment}{// normalizes PCA weights so that they are between [-\/1,1]}}
\DoxyCodeLine{1648     \textcolor{comment}{// basis vectors are modified to reflect this}}
\DoxyCodeLine{1649     STDMETHOD(NormalizeData)(THIS) PURE;}
\DoxyCodeLine{1650 }
\DoxyCodeLine{1651     \textcolor{comment}{// copies basis vectors for cluster "{}Cluster"{} into pClusterBasis}}
\DoxyCodeLine{1652     \textcolor{comment}{// (NumPCA+1)*NumCoeffs*NumChannels floats}}
\DoxyCodeLine{1653     STDMETHOD(ExtractBasis)(THIS\_ UINT Cluster, FLOAT *pClusterBasis) PURE;}
\DoxyCodeLine{1654     }
\DoxyCodeLine{1655     \textcolor{comment}{// UINT per sample -\/ which cluster it belongs to}}
\DoxyCodeLine{1656     STDMETHOD(ExtractClusterIDs)(THIS\_ UINT *pClusterIDs) PURE;}
\DoxyCodeLine{1657     }
\DoxyCodeLine{1658     \textcolor{comment}{// copies NumExtract PCA projection coefficients starting at StartPCA}}
\DoxyCodeLine{1659     \textcolor{comment}{// into pPCACoefficients -\/ NumSamples*NumExtract floats copied}}
\DoxyCodeLine{1660     STDMETHOD(ExtractPCA)(THIS\_ UINT StartPCA, UINT NumExtract, FLOAT *pPCACoefficients) PURE;}
\DoxyCodeLine{1661 }
\DoxyCodeLine{1662     \textcolor{comment}{// copies NumPCA projection coefficients starting at StartPCA}}
\DoxyCodeLine{1663     \textcolor{comment}{// into pTexture -\/ should be able to cope with signed formats}}
\DoxyCodeLine{1664     STDMETHOD(ExtractTexture)(THIS\_ UINT StartPCA, UINT NumpPCA, }
\DoxyCodeLine{1665                               LPDIRECT3DTEXTURE9 pTexture) PURE;}
\DoxyCodeLine{1666                               }
\DoxyCodeLine{1667     \textcolor{comment}{// copies NumPCA projection coefficients into mesh pScene}}
\DoxyCodeLine{1668     \textcolor{comment}{// Usage is D3DDECLUSAGE where coefficients are to be stored}}
\DoxyCodeLine{1669     \textcolor{comment}{// UsageIndexStart is starting index}}
\DoxyCodeLine{1670     STDMETHOD(ExtractToMesh)(THIS\_ UINT NumPCA, D3DDECLUSAGE Usage, UINT UsageIndexStart,}
\DoxyCodeLine{1671                              LPD3DXMESH pScene) PURE;}
\DoxyCodeLine{1672 \};}
\DoxyCodeLine{1673 }
\DoxyCodeLine{1674 }
\DoxyCodeLine{1675 \textcolor{preprocessor}{\#undef INTERFACE}}
\DoxyCodeLine{1676 \textcolor{preprocessor}{\#define INTERFACE ID3DXTextureGutterHelper}}
\DoxyCodeLine{1677 }
\DoxyCodeLine{1678 \textcolor{comment}{// ID3DXTextureGutterHelper will build and manage}}
\DoxyCodeLine{1679 \textcolor{comment}{// "{}gutter"{} regions in a texture -\/ this will allow for}}
\DoxyCodeLine{1680 \textcolor{comment}{// bi-\/linear interpolation to not have artifacts when rendering}}
\DoxyCodeLine{1681 \textcolor{comment}{// It generates a map (in texture space) where each texel}}
\DoxyCodeLine{1682 \textcolor{comment}{// is in one of 3 states:}}
\DoxyCodeLine{1683 \textcolor{comment}{//   0  Invalid -\/ not used at all}}
\DoxyCodeLine{1684 \textcolor{comment}{//   1  Inside triangle}}
\DoxyCodeLine{1685 \textcolor{comment}{//   2  Gutter texel}}
\DoxyCodeLine{1686 \textcolor{comment}{//   4  represents a gutter texel that will be computed during PRT}}
\DoxyCodeLine{1687 \textcolor{comment}{// For each Inside/Gutter texel it stores the face it}}
\DoxyCodeLine{1688 \textcolor{comment}{// belongs to and barycentric coordinates for the 1st two}}
\DoxyCodeLine{1689 \textcolor{comment}{// vertices of that face.  Gutter vertices are assigned to}}
\DoxyCodeLine{1690 \textcolor{comment}{// the closest edge in texture space.}}
\DoxyCodeLine{1691 \textcolor{comment}{//}}
\DoxyCodeLine{1692 \textcolor{comment}{// When used with PRT this requires a unique parameterization}}
\DoxyCodeLine{1693 \textcolor{comment}{// of the model -\/ every texel must correspond to a single point}}
\DoxyCodeLine{1694 \textcolor{comment}{// on the surface of the model and vice versa}}
\DoxyCodeLine{1695 }
\DoxyCodeLine{1696 DECLARE\_INTERFACE\_(ID3DXTextureGutterHelper, IUnknown)}
\DoxyCodeLine{1697 \{}
\DoxyCodeLine{1698     \textcolor{comment}{// IUnknown}}
\DoxyCodeLine{1699     STDMETHOD(QueryInterface)(THIS\_ REFIID iid, LPVOID *ppv) PURE;}
\DoxyCodeLine{1700     STDMETHOD\_(ULONG, AddRef)(THIS) PURE;}
\DoxyCodeLine{1701     STDMETHOD\_(ULONG, Release)(THIS) PURE;}
\DoxyCodeLine{1702 }
\DoxyCodeLine{1703     \textcolor{comment}{// ID3DXTextureGutterHelper}}
\DoxyCodeLine{1704     }
\DoxyCodeLine{1705     \textcolor{comment}{// dimensions of texture this is bound too}}
\DoxyCodeLine{1706     STDMETHOD\_(UINT, GetWidth)(THIS) PURE;}
\DoxyCodeLine{1707     STDMETHOD\_(UINT, GetHeight)(THIS) PURE;}
\DoxyCodeLine{1708 }
\DoxyCodeLine{1709 }
\DoxyCodeLine{1710     \textcolor{comment}{// Applying gutters recomputes all of the gutter texels of class "{}2"{}}}
\DoxyCodeLine{1711     \textcolor{comment}{// based on texels of class "{}1"{} or "{}4"{}}}
\DoxyCodeLine{1712     }
\DoxyCodeLine{1713     \textcolor{comment}{// Applies gutters to a raw float buffer -\/ each texel is NumCoeffs floats}}
\DoxyCodeLine{1714     \textcolor{comment}{// Width and Height must match GutterHelper}}
\DoxyCodeLine{1715     STDMETHOD(ApplyGuttersFloat)(THIS\_ FLOAT *pDataIn, UINT NumCoeffs, UINT Width, UINT Height);}
\DoxyCodeLine{1716     }
\DoxyCodeLine{1717     \textcolor{comment}{// Applies gutters to pTexture}}
\DoxyCodeLine{1718     \textcolor{comment}{// Dimensions must match GutterHelper}}
\DoxyCodeLine{1719     STDMETHOD(ApplyGuttersTex)(THIS\_ LPDIRECT3DTEXTURE9 pTexture);}
\DoxyCodeLine{1720     }
\DoxyCodeLine{1721     \textcolor{comment}{// Applies gutters to a D3DXPRTBuffer}}
\DoxyCodeLine{1722     \textcolor{comment}{// Dimensions must match GutterHelper}}
\DoxyCodeLine{1723     STDMETHOD(ApplyGuttersPRT)(THIS\_ LPD3DXPRTBUFFER pBuffer);}
\DoxyCodeLine{1724        }
\DoxyCodeLine{1725     \textcolor{comment}{// Resamples a texture from a mesh onto this gutterhelpers}}
\DoxyCodeLine{1726     \textcolor{comment}{// parameterization.  It is assumed that the UV coordinates}}
\DoxyCodeLine{1727     \textcolor{comment}{// for this gutter helper are in TEXTURE 0 (usage/usage index)}}
\DoxyCodeLine{1728     \textcolor{comment}{// and the texture coordinates should all be within [0,1] for}}
\DoxyCodeLine{1729     \textcolor{comment}{// both sets.}}
\DoxyCodeLine{1730     \textcolor{comment}{//}}
\DoxyCodeLine{1731     \textcolor{comment}{// pTextureIn -\/ texture represented using parameterization in pMeshIn}}
\DoxyCodeLine{1732     \textcolor{comment}{// pMeshIn    -\/ Mesh with texture coordinates that represent pTextureIn}}
\DoxyCodeLine{1733     \textcolor{comment}{//              pTextureOut texture coordinates are assumed to be in}}
\DoxyCodeLine{1734     \textcolor{comment}{//              TEXTURE 0}}
\DoxyCodeLine{1735     \textcolor{comment}{// Usage      -\/ field in DECL for pMeshIn that stores texture coordinates}}
\DoxyCodeLine{1736     \textcolor{comment}{//              for pTextureIn}}
\DoxyCodeLine{1737     \textcolor{comment}{// UsageIndex -\/ which index for Usage above for pTextureIn}}
\DoxyCodeLine{1738     \textcolor{comment}{// pTextureOut-\/ Resampled texture}}
\DoxyCodeLine{1739     \textcolor{comment}{// }}
\DoxyCodeLine{1740     \textcolor{comment}{// Usage would generally be D3DDECLUSAGE\_TEXCOORD  and UsageIndex other than zero}}
\DoxyCodeLine{1741     STDMETHOD(ResampleTex)(THIS\_ LPDIRECT3DTEXTURE9 pTextureIn,}
\DoxyCodeLine{1742                                  LPD3DXMESH pMeshIn,}
\DoxyCodeLine{1743                                  D3DDECLUSAGE Usage, UINT UsageIndex,}
\DoxyCodeLine{1744                                  LPDIRECT3DTEXTURE9 pTextureOut);    }
\DoxyCodeLine{1745     }
\DoxyCodeLine{1746     \textcolor{comment}{// the routines below provide access to the data structures}}
\DoxyCodeLine{1747     \textcolor{comment}{// used by the Apply functions}}
\DoxyCodeLine{1748 }
\DoxyCodeLine{1749     \textcolor{comment}{// face map is a UINT per texel that represents the}}
\DoxyCodeLine{1750     \textcolor{comment}{// face of the mesh that texel belongs too -\/ }}
\DoxyCodeLine{1751     \textcolor{comment}{// only valid if same texel is valid in pGutterData}}
\DoxyCodeLine{1752     \textcolor{comment}{// pFaceData must be allocated by the user}}
\DoxyCodeLine{1753     STDMETHOD(GetFaceMap)(THIS\_ UINT *pFaceData) PURE;}
\DoxyCodeLine{1754     }
\DoxyCodeLine{1755     \textcolor{comment}{// BaryMap is a D3DXVECTOR2 per texel}}
\DoxyCodeLine{1756     \textcolor{comment}{// the 1st two barycentric coordinates for the corresponding}}
\DoxyCodeLine{1757     \textcolor{comment}{// face (3rd weight is always 1-\/sum of first two)}}
\DoxyCodeLine{1758     \textcolor{comment}{// only valid if same texel is valid in pGutterData}}
\DoxyCodeLine{1759     \textcolor{comment}{// pBaryData must be allocated by the user}}
\DoxyCodeLine{1760     STDMETHOD(GetBaryMap)(THIS\_ \mbox{\hyperlink{struct_d3_d_x_v_e_c_t_o_r2}{D3DXVECTOR2}} *pBaryData) PURE;}
\DoxyCodeLine{1761     }
\DoxyCodeLine{1762     \textcolor{comment}{// TexelMap is a D3DXVECTOR2 per texel that}}
\DoxyCodeLine{1763     \textcolor{comment}{// stores the location in pixel coordinates where the}}
\DoxyCodeLine{1764     \textcolor{comment}{// corresponding texel is mapped}}
\DoxyCodeLine{1765     \textcolor{comment}{// pTexelData must be allocated by the user}}
\DoxyCodeLine{1766     STDMETHOD(GetTexelMap)(THIS\_ \mbox{\hyperlink{struct_d3_d_x_v_e_c_t_o_r2}{D3DXVECTOR2}} *pTexelData) PURE;}
\DoxyCodeLine{1767     }
\DoxyCodeLine{1768     \textcolor{comment}{// GutterMap is a BYTE per texel}}
\DoxyCodeLine{1769     \textcolor{comment}{// 0/1/2 for Invalid/Internal/Gutter texels}}
\DoxyCodeLine{1770     \textcolor{comment}{// 4 represents a gutter texel that will be computed}}
\DoxyCodeLine{1771     \textcolor{comment}{// during PRT}}
\DoxyCodeLine{1772     \textcolor{comment}{// pGutterData must be allocated by the user}}
\DoxyCodeLine{1773     STDMETHOD(GetGutterMap)(THIS\_ BYTE *pGutterData) PURE;}
\DoxyCodeLine{1774     }
\DoxyCodeLine{1775     \textcolor{comment}{// face map is a UINT per texel that represents the}}
\DoxyCodeLine{1776     \textcolor{comment}{// face of the mesh that texel belongs too -\/ }}
\DoxyCodeLine{1777     \textcolor{comment}{// only valid if same texel is valid in pGutterData}}
\DoxyCodeLine{1778     STDMETHOD(SetFaceMap)(THIS\_ UINT *pFaceData) PURE;}
\DoxyCodeLine{1779     }
\DoxyCodeLine{1780     \textcolor{comment}{// BaryMap is a D3DXVECTOR2 per texel}}
\DoxyCodeLine{1781     \textcolor{comment}{// the 1st two barycentric coordinates for the corresponding}}
\DoxyCodeLine{1782     \textcolor{comment}{// face (3rd weight is always 1-\/sum of first two)}}
\DoxyCodeLine{1783     \textcolor{comment}{// only valid if same texel is valid in pGutterData}}
\DoxyCodeLine{1784     STDMETHOD(SetBaryMap)(THIS\_ \mbox{\hyperlink{struct_d3_d_x_v_e_c_t_o_r2}{D3DXVECTOR2}} *pBaryData) PURE;}
\DoxyCodeLine{1785     }
\DoxyCodeLine{1786     \textcolor{comment}{// TexelMap is a D3DXVECTOR2 per texel that}}
\DoxyCodeLine{1787     \textcolor{comment}{// stores the location in pixel coordinates where the}}
\DoxyCodeLine{1788     \textcolor{comment}{// corresponding texel is mapped}}
\DoxyCodeLine{1789     STDMETHOD(SetTexelMap)(THIS\_ \mbox{\hyperlink{struct_d3_d_x_v_e_c_t_o_r2}{D3DXVECTOR2}} *pTexelData) PURE;}
\DoxyCodeLine{1790     }
\DoxyCodeLine{1791     \textcolor{comment}{// GutterMap is a BYTE per texel}}
\DoxyCodeLine{1792     \textcolor{comment}{// 0/1/2 for Invalid/Internal/Gutter texels}}
\DoxyCodeLine{1793     \textcolor{comment}{// 4 represents a gutter texel that will be computed}}
\DoxyCodeLine{1794     \textcolor{comment}{// during PRT}}
\DoxyCodeLine{1795     STDMETHOD(SetGutterMap)(THIS\_ BYTE *pGutterData) PURE;    }
\DoxyCodeLine{1796 \};}
\DoxyCodeLine{1797 }
\DoxyCodeLine{1798 }
\DoxyCodeLine{1799 \textcolor{keyword}{typedef} \textcolor{keyword}{interface }ID3DXPRTEngine ID3DXPRTEngine;}
\DoxyCodeLine{1800 \textcolor{keyword}{typedef} \textcolor{keyword}{interface }ID3DXPRTEngine *LPD3DXPRTENGINE;}
\DoxyCodeLine{1801 }
\DoxyCodeLine{1802 \textcolor{preprocessor}{\#undef INTERFACE}}
\DoxyCodeLine{1803 \textcolor{preprocessor}{\#define INTERFACE ID3DXPRTEngine}}
\DoxyCodeLine{1804 }
\DoxyCodeLine{1805 \textcolor{comment}{// ID3DXPRTEngine is used to compute a PRT simulation}}
\DoxyCodeLine{1806 \textcolor{comment}{// Use the following steps to compute PRT for SH}}
\DoxyCodeLine{1807 \textcolor{comment}{// (1) create an interface (which includes a scene)}}
\DoxyCodeLine{1808 \textcolor{comment}{// (2) call SetSamplingInfo}}
\DoxyCodeLine{1809 \textcolor{comment}{// (3) [optional] Set MeshMaterials/albedo's (required if doing bounces)}}
\DoxyCodeLine{1810 \textcolor{comment}{// (4) call ComputeDirectLightingSH}}
\DoxyCodeLine{1811 \textcolor{comment}{// (5) [optional] call ComputeBounce}}
\DoxyCodeLine{1812 \textcolor{comment}{// repeat step 5 for as many bounces as wanted.}}
\DoxyCodeLine{1813 \textcolor{comment}{// if you want to model subsurface scattering you}}
\DoxyCodeLine{1814 \textcolor{comment}{// need to call ComputeSS after direct lighting and}}
\DoxyCodeLine{1815 \textcolor{comment}{// each bounce.}}
\DoxyCodeLine{1816 \textcolor{comment}{// If you want to bake the albedo into the PRT signal, you}}
\DoxyCodeLine{1817 \textcolor{comment}{// must call MutliplyAlbedo, otherwise the user has to multiply}}
\DoxyCodeLine{1818 \textcolor{comment}{// the albedo themselves.  Not multiplying the albedo allows you}}
\DoxyCodeLine{1819 \textcolor{comment}{// to model albedo variation at a finer scale then illumination, and}}
\DoxyCodeLine{1820 \textcolor{comment}{// can result in better compression results.}}
\DoxyCodeLine{1821 \textcolor{comment}{// Luminance values are computed from RGB values using the following}}
\DoxyCodeLine{1822 \textcolor{comment}{// formula:  R * 0.2125 + G * 0.7154 + B * 0.0721}}
\DoxyCodeLine{1823 }
\DoxyCodeLine{1824 DECLARE\_INTERFACE\_(ID3DXPRTEngine, IUnknown)}
\DoxyCodeLine{1825 \{}
\DoxyCodeLine{1826     \textcolor{comment}{// IUnknown}}
\DoxyCodeLine{1827     STDMETHOD(QueryInterface)(THIS\_ REFIID iid, LPVOID *ppv) PURE;}
\DoxyCodeLine{1828     STDMETHOD\_(ULONG, AddRef)(THIS) PURE;}
\DoxyCodeLine{1829     STDMETHOD\_(ULONG, Release)(THIS) PURE;}
\DoxyCodeLine{1830 }
\DoxyCodeLine{1831     \textcolor{comment}{// ID3DXPRTEngine}}
\DoxyCodeLine{1832     }
\DoxyCodeLine{1833     \textcolor{comment}{// This sets a material per attribute in the scene mesh and it is}}
\DoxyCodeLine{1834     \textcolor{comment}{// the only way to specify subsurface scattering parameters.  if}}
\DoxyCodeLine{1835     \textcolor{comment}{// bSetAlbedo is FALSE, NumChannels must match the current}}
\DoxyCodeLine{1836     \textcolor{comment}{// configuration of the PRTEngine.  If you intend to change}}
\DoxyCodeLine{1837     \textcolor{comment}{// NumChannels (through some other SetAlbedo function) it must}}
\DoxyCodeLine{1838     \textcolor{comment}{// happen before SetMeshMaterials is called.}}
\DoxyCodeLine{1839     \textcolor{comment}{//}}
\DoxyCodeLine{1840     \textcolor{comment}{// NumChannels 1 implies "{}grayscale"{} materials, set this to 3 to enable}}
\DoxyCodeLine{1841     \textcolor{comment}{//  color bleeding effects}}
\DoxyCodeLine{1842     \textcolor{comment}{// bSetAlbedo sets albedo from material if TRUE -\/ which clobbers per texel/vertex}}
\DoxyCodeLine{1843     \textcolor{comment}{//  albedo that might have been set before.  FALSE won't clobber.}}
\DoxyCodeLine{1844     \textcolor{comment}{// fLengthScale is used for subsurface scattering -\/ scene is mapped into a 1mm unit cube}}
\DoxyCodeLine{1845     \textcolor{comment}{//  and scaled by this amount}}
\DoxyCodeLine{1846     STDMETHOD(SetMeshMaterials)(THIS\_ CONST \mbox{\hyperlink{struct___d3_d_x_s_h_m_a_t_e_r_i_a_l}{D3DXSHMATERIAL}} **ppMaterials, UINT NumMeshes, }
\DoxyCodeLine{1847                                 UINT NumChannels, BOOL bSetAlbedo, FLOAT fLengthScale) PURE;}
\DoxyCodeLine{1848     }
\DoxyCodeLine{1849     \textcolor{comment}{// setting albedo per-\/vertex or per-\/texel over rides the albedos stored per mesh}}
\DoxyCodeLine{1850     \textcolor{comment}{// but it does not over ride any other settings}}
\DoxyCodeLine{1851     }
\DoxyCodeLine{1852     \textcolor{comment}{// sets an albedo to be used per vertex -\/ the albedo is represented as a float}}
\DoxyCodeLine{1853     \textcolor{comment}{// pDataIn input pointer (pointint to albedo of 1st sample)}}
\DoxyCodeLine{1854     \textcolor{comment}{// NumChannels 1 implies "{}grayscale"{} materials, set this to 3 to enable}}
\DoxyCodeLine{1855     \textcolor{comment}{//  color bleeding effects}}
\DoxyCodeLine{1856     \textcolor{comment}{// Stride -\/ stride in bytes to get to next samples albedo}}
\DoxyCodeLine{1857     STDMETHOD(SetPerVertexAlbedo)(THIS\_ CONST VOID *pDataIn, UINT NumChannels, UINT Stride) PURE;}
\DoxyCodeLine{1858     }
\DoxyCodeLine{1859     \textcolor{comment}{// represents the albedo per-\/texel instead of per-\/vertex (even if per-\/vertex PRT is used)}}
\DoxyCodeLine{1860     \textcolor{comment}{// pAlbedoTexture -\/ texture that stores the albedo (dimension arbitrary)}}
\DoxyCodeLine{1861     \textcolor{comment}{// NumChannels 1 implies "{}grayscale"{} materials, set this to 3 to enable}}
\DoxyCodeLine{1862     \textcolor{comment}{//  color bleeding effects}}
\DoxyCodeLine{1863     \textcolor{comment}{// pGH -\/ optional gutter helper, otherwise one is constructed in computation routines and}}
\DoxyCodeLine{1864     \textcolor{comment}{//  destroyed (if not attached to buffers)}}
\DoxyCodeLine{1865     STDMETHOD(SetPerTexelAlbedo)(THIS\_ LPDIRECT3DTEXTURE9 pAlbedoTexture, }
\DoxyCodeLine{1866                                  UINT NumChannels, }
\DoxyCodeLine{1867                                  LPD3DXTEXTUREGUTTERHELPER pGH) PURE;}
\DoxyCodeLine{1868                                  }
\DoxyCodeLine{1869     \textcolor{comment}{// gets the per-\/vertex albedo}}
\DoxyCodeLine{1870     STDMETHOD(GetVertexAlbedo)(THIS\_ \mbox{\hyperlink{struct_d3_d_x_c_o_l_o_r}{D3DXCOLOR}} *pVertColors, UINT NumVerts) PURE;                                 }
\DoxyCodeLine{1871                                  }
\DoxyCodeLine{1872     \textcolor{comment}{// If pixel PRT is being computed normals default to ones that are interpolated}}
\DoxyCodeLine{1873     \textcolor{comment}{// from the vertex normals.  This specifies a texture that stores an object}}
\DoxyCodeLine{1874     \textcolor{comment}{// space normal map instead (must use a texture format that can represent signed values)}}
\DoxyCodeLine{1875     \textcolor{comment}{// pNormalTexture -\/ normal map, must be same dimensions as PRTBuffers, signed                                }}
\DoxyCodeLine{1876     STDMETHOD(SetPerTexelNormal)(THIS\_ LPDIRECT3DTEXTURE9 pNormalTexture) PURE;}
\DoxyCodeLine{1877                                  }
\DoxyCodeLine{1878     \textcolor{comment}{// Copies per-\/vertex albedo from mesh}}
\DoxyCodeLine{1879     \textcolor{comment}{// pMesh -\/ mesh that represents the scene.  It must have the same}}
\DoxyCodeLine{1880     \textcolor{comment}{//  properties as the mesh used to create the PRTEngine}}
\DoxyCodeLine{1881     \textcolor{comment}{// Usage -\/ D3DDECLUSAGE to extract albedos from}}
\DoxyCodeLine{1882     \textcolor{comment}{// NumChannels 1 implies "{}grayscale"{} materials, set this to 3 to enable}}
\DoxyCodeLine{1883     \textcolor{comment}{//  color bleeding effects}}
\DoxyCodeLine{1884     STDMETHOD(ExtractPerVertexAlbedo)(THIS\_ LPD3DXMESH pMesh, }
\DoxyCodeLine{1885                                       D3DDECLUSAGE Usage, }
\DoxyCodeLine{1886                                       UINT NumChannels) PURE;}
\DoxyCodeLine{1887 }
\DoxyCodeLine{1888     \textcolor{comment}{// Resamples the input buffer into the output buffer}}
\DoxyCodeLine{1889     \textcolor{comment}{// can be used to move between per-\/vertex and per-\/texel buffers.  This can also be used}}
\DoxyCodeLine{1890     \textcolor{comment}{// to convert single channel buffers to 3-\/channel buffers and vice-\/versa.}}
\DoxyCodeLine{1891     STDMETHOD(ResampleBuffer)(THIS\_ LPD3DXPRTBUFFER pBufferIn, LPD3DXPRTBUFFER pBufferOut) PURE;}
\DoxyCodeLine{1892     }
\DoxyCodeLine{1893     \textcolor{comment}{// Returns the scene mesh -\/ including modifications from adaptive spatial sampling}}
\DoxyCodeLine{1894     \textcolor{comment}{// The returned mesh only has positions, normals and texture coordinates (if defined)}}
\DoxyCodeLine{1895     \textcolor{comment}{// pD3DDevice -\/ d3d device that will be used to allocate the mesh}}
\DoxyCodeLine{1896     \textcolor{comment}{// pFaceRemap -\/ each face has a pointer back to the face on the original mesh that it comes from}}
\DoxyCodeLine{1897     \textcolor{comment}{//  if the face hasn't been subdivided this will be an identity mapping}}
\DoxyCodeLine{1898     \textcolor{comment}{// pVertRemap -\/ each vertex contains 3 vertices that this is a linear combination of}}
\DoxyCodeLine{1899     \textcolor{comment}{// pVertWeights -\/ weights for each of above indices (sum to 1.0f)}}
\DoxyCodeLine{1900     \textcolor{comment}{// ppMesh -\/ mesh that will be allocated and filled}}
\DoxyCodeLine{1901     STDMETHOD(GetAdaptedMesh)(THIS\_ LPDIRECT3DDEVICE9 pD3DDevice,UINT *pFaceRemap, UINT *pVertRemap, FLOAT *pfVertWeights, LPD3DXMESH *ppMesh) PURE;}
\DoxyCodeLine{1902 }
\DoxyCodeLine{1903     \textcolor{comment}{// Number of vertices currently allocated (includes new vertices from adaptive sampling)}}
\DoxyCodeLine{1904     STDMETHOD\_(UINT, GetNumVerts)(THIS) PURE;}
\DoxyCodeLine{1905     \textcolor{comment}{// Number of faces currently allocated (includes new faces)}}
\DoxyCodeLine{1906     STDMETHOD\_(UINT, GetNumFaces)(THIS) PURE;}
\DoxyCodeLine{1907 }
\DoxyCodeLine{1908     \textcolor{comment}{// Sets the Minimum/Maximum intersection distances, this can be used to control}}
\DoxyCodeLine{1909     \textcolor{comment}{// maximum distance that objects can shadow/reflect light, and help with "{}bad"{}}}
\DoxyCodeLine{1910     \textcolor{comment}{// art that might have near features that you don't want to shadow.  This does not}}
\DoxyCodeLine{1911     \textcolor{comment}{// apply for GPU simulations.}}
\DoxyCodeLine{1912     \textcolor{comment}{//  fMin -\/ minimum intersection distance, must be positive and less than fMax}}
\DoxyCodeLine{1913     \textcolor{comment}{//  fMax -\/ maximum intersection distance, if 0.0f use the previous value, otherwise}}
\DoxyCodeLine{1914     \textcolor{comment}{//      must be strictly greater than fMin}}
\DoxyCodeLine{1915     STDMETHOD(SetMinMaxIntersection)(THIS\_ FLOAT fMin, FLOAT fMax) PURE;}
\DoxyCodeLine{1916 }
\DoxyCodeLine{1917     \textcolor{comment}{// This will subdivide faces on a mesh so that adaptively simulations can}}
\DoxyCodeLine{1918     \textcolor{comment}{// use a more conservative threshold (it won't miss features.)}}
\DoxyCodeLine{1919     \textcolor{comment}{// MinEdgeLength -\/ minimum edge length that will be generated, if 0.0f a}}
\DoxyCodeLine{1920     \textcolor{comment}{//  reasonable default will be used}}
\DoxyCodeLine{1921     \textcolor{comment}{// MaxSubdiv -\/ maximum level of subdivision, if 0 is specified a default}}
\DoxyCodeLine{1922     \textcolor{comment}{//  value will be used (5)}}
\DoxyCodeLine{1923     STDMETHOD(RobustMeshRefine)(THIS\_ FLOAT MinEdgeLength, UINT MaxSubdiv) PURE;}
\DoxyCodeLine{1924 }
\DoxyCodeLine{1925     \textcolor{comment}{// This sets to sampling information used by the simulator.  Adaptive sampling}}
\DoxyCodeLine{1926     \textcolor{comment}{// parameters are currently ignored.}}
\DoxyCodeLine{1927     \textcolor{comment}{// NumRays -\/ number of rays to shoot per sample}}
\DoxyCodeLine{1928     \textcolor{comment}{// UseSphere -\/ if TRUE uses spherical samples, otherwise samples over}}
\DoxyCodeLine{1929     \textcolor{comment}{//  the hemisphere.  Should only be used with GPU and Vol computations}}
\DoxyCodeLine{1930     \textcolor{comment}{// UseCosine -\/ if TRUE uses a cosine weighting -\/ not used for Vol computations}}
\DoxyCodeLine{1931     \textcolor{comment}{//  or if only the visiblity function is desired}}
\DoxyCodeLine{1932     \textcolor{comment}{// Adaptive -\/ if TRUE adaptive sampling (angular) is used}}
\DoxyCodeLine{1933     \textcolor{comment}{// AdaptiveThresh -\/ threshold used to terminate adaptive angular sampling}}
\DoxyCodeLine{1934     \textcolor{comment}{//  ignored if adaptive sampling is not set}}
\DoxyCodeLine{1935     STDMETHOD(SetSamplingInfo)(THIS\_ UINT NumRays, }
\DoxyCodeLine{1936                                BOOL UseSphere, }
\DoxyCodeLine{1937                                BOOL UseCosine, }
\DoxyCodeLine{1938                                BOOL Adaptive, }
\DoxyCodeLine{1939                                FLOAT AdaptiveThresh) PURE;}
\DoxyCodeLine{1940 }
\DoxyCodeLine{1941     \textcolor{comment}{// Methods that compute the direct lighting contribution for objects}}
\DoxyCodeLine{1942     \textcolor{comment}{// always represente light using spherical harmonics (SH)}}
\DoxyCodeLine{1943     \textcolor{comment}{// the albedo is not multiplied by the signal -\/ it just integrates}}
\DoxyCodeLine{1944     \textcolor{comment}{// incoming light.  If NumChannels is not 1 the vector is replicated}}
\DoxyCodeLine{1945     \textcolor{comment}{//}}
\DoxyCodeLine{1946     \textcolor{comment}{// SHOrder -\/ order of SH to use}}
\DoxyCodeLine{1947     \textcolor{comment}{// pDataOut -\/ PRT buffer that is generated.  Can be single channel}}
\DoxyCodeLine{1948     STDMETHOD(ComputeDirectLightingSH)(THIS\_ UINT SHOrder, }
\DoxyCodeLine{1949                                        LPD3DXPRTBUFFER pDataOut) PURE;}
\DoxyCodeLine{1950                                        }
\DoxyCodeLine{1951     \textcolor{comment}{// Adaptive variant of above function.  This will refine the mesh}}
\DoxyCodeLine{1952     \textcolor{comment}{// generating new vertices/faces to approximate the PRT signal}}
\DoxyCodeLine{1953     \textcolor{comment}{// more faithfully.}}
\DoxyCodeLine{1954     \textcolor{comment}{// SHOrder -\/ order of SH to use}}
\DoxyCodeLine{1955     \textcolor{comment}{// AdaptiveThresh -\/ threshold for adaptive subdivision (in PRT vector error)}}
\DoxyCodeLine{1956     \textcolor{comment}{//  if value is less then 1e-\/6f, 1e-\/6f is specified}}
\DoxyCodeLine{1957     \textcolor{comment}{// MinEdgeLength -\/ minimum edge length that will be generated}}
\DoxyCodeLine{1958     \textcolor{comment}{//  if value is too small a fairly conservative model dependent value}}
\DoxyCodeLine{1959     \textcolor{comment}{//  is used}}
\DoxyCodeLine{1960     \textcolor{comment}{// MaxSubdiv -\/ maximum subdivision level, if 0 is specified it }}
\DoxyCodeLine{1961     \textcolor{comment}{//  will default to 4}}
\DoxyCodeLine{1962     \textcolor{comment}{// pDataOut -\/ PRT buffer that is generated.  Can be single channel.}}
\DoxyCodeLine{1963     STDMETHOD(ComputeDirectLightingSHAdaptive)(THIS\_ UINT SHOrder, }
\DoxyCodeLine{1964                                                FLOAT AdaptiveThresh,}
\DoxyCodeLine{1965                                                FLOAT MinEdgeLength,}
\DoxyCodeLine{1966                                                UINT MaxSubdiv,}
\DoxyCodeLine{1967                                                LPD3DXPRTBUFFER pDataOut) PURE;}
\DoxyCodeLine{1968                                        }
\DoxyCodeLine{1969     \textcolor{comment}{// Function that computes the direct lighting contribution for objects}}
\DoxyCodeLine{1970     \textcolor{comment}{// light is always represented using spherical harmonics (SH)}}
\DoxyCodeLine{1971     \textcolor{comment}{// This is done on the GPU and is much faster then using the CPU.}}
\DoxyCodeLine{1972     \textcolor{comment}{// The albedo is not multiplied by the signal -\/ it just integrates}}
\DoxyCodeLine{1973     \textcolor{comment}{// incoming light.  If NumChannels is not 1 the vector is replicated.}}
\DoxyCodeLine{1974     \textcolor{comment}{// ZBias/ZAngleBias are akin to parameters used with shadow zbuffers.}}
\DoxyCodeLine{1975     \textcolor{comment}{// A reasonable default for both values is 0.005, but the user should}}
\DoxyCodeLine{1976     \textcolor{comment}{// experiment (ZAngleBias can be zero, ZBias should not be.)}}
\DoxyCodeLine{1977     \textcolor{comment}{// Callbacks should not use the Direct3D9Device the simulator is using.}}
\DoxyCodeLine{1978     \textcolor{comment}{// SetSamplingInfo must be called with TRUE for UseSphere and}}
\DoxyCodeLine{1979     \textcolor{comment}{// FALSE for UseCosine before this method is called.}}
\DoxyCodeLine{1980     \textcolor{comment}{//}}
\DoxyCodeLine{1981     \textcolor{comment}{// pD3DDevice -\/ device used to run GPU simulator -\/ must support PS2.0}}
\DoxyCodeLine{1982     \textcolor{comment}{//  and FP render targets}}
\DoxyCodeLine{1983     \textcolor{comment}{// Flags -\/ parameters for the GPU simulator, combination of one or more}}
\DoxyCodeLine{1984     \textcolor{comment}{//  D3DXSHGPUSIMOPT flags.  Only one SHADOWRES setting should be set and}}
\DoxyCodeLine{1985     \textcolor{comment}{//  the defaults is 512}}
\DoxyCodeLine{1986     \textcolor{comment}{// SHOrder -\/ order of SH to use}}
\DoxyCodeLine{1987     \textcolor{comment}{// ZBias -\/ bias in normal direction (for depth test)}}
\DoxyCodeLine{1988     \textcolor{comment}{// ZAngleBias -\/ scaled by one minus cosine of angle with light (offset in depth)}}
\DoxyCodeLine{1989     \textcolor{comment}{// pDataOut -\/ PRT buffer that is filled in.  Can be single channel}}
\DoxyCodeLine{1990     STDMETHOD(ComputeDirectLightingSHGPU)(THIS\_ LPDIRECT3DDEVICE9 pD3DDevice,}
\DoxyCodeLine{1991                                           UINT Flags,}
\DoxyCodeLine{1992                                           UINT SHOrder,}
\DoxyCodeLine{1993                                           FLOAT ZBias,}
\DoxyCodeLine{1994                                           FLOAT ZAngleBias,}
\DoxyCodeLine{1995                                           LPD3DXPRTBUFFER pDataOut) PURE;}
\DoxyCodeLine{1996 }
\DoxyCodeLine{1997 }
\DoxyCodeLine{1998     \textcolor{comment}{// Functions that computes subsurface scattering (using material properties)}}
\DoxyCodeLine{1999     \textcolor{comment}{// Albedo is not multiplied by result.  This only works for per-\/vertex data}}
\DoxyCodeLine{2000     \textcolor{comment}{// use ResampleBuffer to move per-\/vertex data into a texture and back.}}
\DoxyCodeLine{2001     \textcolor{comment}{//}}
\DoxyCodeLine{2002     \textcolor{comment}{// pDataIn -\/ input data (previous bounce)}}
\DoxyCodeLine{2003     \textcolor{comment}{// pDataOut -\/ result of subsurface scattering simulation}}
\DoxyCodeLine{2004     \textcolor{comment}{// pDataTotal -\/ [optional] results can be summed into this buffer}}
\DoxyCodeLine{2005     STDMETHOD(ComputeSS)(THIS\_ LPD3DXPRTBUFFER pDataIn, }
\DoxyCodeLine{2006                          LPD3DXPRTBUFFER pDataOut, LPD3DXPRTBUFFER pDataTotal) PURE;}
\DoxyCodeLine{2007 }
\DoxyCodeLine{2008     \textcolor{comment}{// Adaptive version of ComputeSS.}}
\DoxyCodeLine{2009     \textcolor{comment}{//}}
\DoxyCodeLine{2010     \textcolor{comment}{// pDataIn -\/ input data (previous bounce)}}
\DoxyCodeLine{2011     \textcolor{comment}{// AdaptiveThresh -\/ threshold for adaptive subdivision (in PRT vector error)}}
\DoxyCodeLine{2012     \textcolor{comment}{//  if value is less then 1e-\/6f, 1e-\/6f is specified}}
\DoxyCodeLine{2013     \textcolor{comment}{// MinEdgeLength -\/ minimum edge length that will be generated}}
\DoxyCodeLine{2014     \textcolor{comment}{//  if value is too small a fairly conservative model dependent value}}
\DoxyCodeLine{2015     \textcolor{comment}{//  is used}}
\DoxyCodeLine{2016     \textcolor{comment}{// MaxSubdiv -\/ maximum subdivision level, if 0 is specified it }}
\DoxyCodeLine{2017     \textcolor{comment}{//  will default to 4    }}
\DoxyCodeLine{2018     \textcolor{comment}{// pDataOut -\/ result of subsurface scattering simulation}}
\DoxyCodeLine{2019     \textcolor{comment}{// pDataTotal -\/ [optional] results can be summed into this buffer}}
\DoxyCodeLine{2020     STDMETHOD(ComputeSSAdaptive)(THIS\_ LPD3DXPRTBUFFER pDataIn, }
\DoxyCodeLine{2021                                  FLOAT AdaptiveThresh,}
\DoxyCodeLine{2022                                  FLOAT MinEdgeLength,}
\DoxyCodeLine{2023                                  UINT MaxSubdiv,}
\DoxyCodeLine{2024                                  LPD3DXPRTBUFFER pDataOut, LPD3DXPRTBUFFER pDataTotal) PURE;}
\DoxyCodeLine{2025 }
\DoxyCodeLine{2026     \textcolor{comment}{// computes a single bounce of inter-\/reflected light}}
\DoxyCodeLine{2027     \textcolor{comment}{// works for SH based PRT or generic lighting}}
\DoxyCodeLine{2028     \textcolor{comment}{// Albedo is not multiplied by result}}
\DoxyCodeLine{2029     \textcolor{comment}{//}}
\DoxyCodeLine{2030     \textcolor{comment}{// pDataIn -\/ previous bounces data }}
\DoxyCodeLine{2031     \textcolor{comment}{// pDataOut -\/ PRT buffer that is generated}}
\DoxyCodeLine{2032     \textcolor{comment}{// pDataTotal -\/ [optional] can be used to keep a running sum}}
\DoxyCodeLine{2033     STDMETHOD(ComputeBounce)(THIS\_ LPD3DXPRTBUFFER pDataIn,}
\DoxyCodeLine{2034                              LPD3DXPRTBUFFER pDataOut,}
\DoxyCodeLine{2035                              LPD3DXPRTBUFFER pDataTotal) PURE;}
\DoxyCodeLine{2036 }
\DoxyCodeLine{2037     \textcolor{comment}{// Adaptive version of above function.}}
\DoxyCodeLine{2038     \textcolor{comment}{//}}
\DoxyCodeLine{2039     \textcolor{comment}{// pDataIn -\/ previous bounces data, can be single channel }}
\DoxyCodeLine{2040     \textcolor{comment}{// AdaptiveThresh -\/ threshold for adaptive subdivision (in PRT vector error)}}
\DoxyCodeLine{2041     \textcolor{comment}{//  if value is less then 1e-\/6f, 1e-\/6f is specified}}
\DoxyCodeLine{2042     \textcolor{comment}{// MinEdgeLength -\/ minimum edge length that will be generated}}
\DoxyCodeLine{2043     \textcolor{comment}{//  if value is too small a fairly conservative model dependent value}}
\DoxyCodeLine{2044     \textcolor{comment}{//  is used}}
\DoxyCodeLine{2045     \textcolor{comment}{// MaxSubdiv -\/ maximum subdivision level, if 0 is specified it }}
\DoxyCodeLine{2046     \textcolor{comment}{//  will default to 4}}
\DoxyCodeLine{2047     \textcolor{comment}{// pDataOut -\/ PRT buffer that is generated}}
\DoxyCodeLine{2048     \textcolor{comment}{// pDataTotal -\/ [optional] can be used to keep a running sum    }}
\DoxyCodeLine{2049     STDMETHOD(ComputeBounceAdaptive)(THIS\_ LPD3DXPRTBUFFER pDataIn,}
\DoxyCodeLine{2050                                      FLOAT AdaptiveThresh,}
\DoxyCodeLine{2051                                      FLOAT MinEdgeLength,}
\DoxyCodeLine{2052                                      UINT MaxSubdiv,}
\DoxyCodeLine{2053                                      LPD3DXPRTBUFFER pDataOut,}
\DoxyCodeLine{2054                                      LPD3DXPRTBUFFER pDataTotal) PURE;}
\DoxyCodeLine{2055 }
\DoxyCodeLine{2056     \textcolor{comment}{// Computes projection of distant SH radiance into a local SH radiance}}
\DoxyCodeLine{2057     \textcolor{comment}{// function.  This models how direct lighting is attenuated by the }}
\DoxyCodeLine{2058     \textcolor{comment}{// scene and is a form of "{}neighborhood transfer."{}  The result is}}
\DoxyCodeLine{2059     \textcolor{comment}{// a linear operator (matrix) at every sample point, if you multiply}}
\DoxyCodeLine{2060     \textcolor{comment}{// this matrix by the distant SH lighting coefficients you get an}}
\DoxyCodeLine{2061     \textcolor{comment}{// approximation of the local incident radiance function from}}
\DoxyCodeLine{2062     \textcolor{comment}{// direct lighting.  These resulting lighting coefficients can}}
\DoxyCodeLine{2063     \textcolor{comment}{// than be projected into another basis or used with any rendering}}
\DoxyCodeLine{2064     \textcolor{comment}{// technique that uses spherical harmonics as input.}}
\DoxyCodeLine{2065     \textcolor{comment}{// SetSamplingInfo must be called with TRUE for UseSphere and}}
\DoxyCodeLine{2066     \textcolor{comment}{// FALSE for UseCosine before this method is called.  }}
\DoxyCodeLine{2067     \textcolor{comment}{// Generates SHOrderIn*SHOrderIn*SHOrderOut*SHOrderOut scalars }}
\DoxyCodeLine{2068     \textcolor{comment}{// per channel at each sample location.}}
\DoxyCodeLine{2069     \textcolor{comment}{//}}
\DoxyCodeLine{2070     \textcolor{comment}{// SHOrderIn  -\/ Order of the SH representation of distant lighting}}
\DoxyCodeLine{2071     \textcolor{comment}{// SHOrderOut -\/ Order of the SH representation of local lighting}}
\DoxyCodeLine{2072     \textcolor{comment}{// NumVolSamples  -\/ Number of sample locations}}
\DoxyCodeLine{2073     \textcolor{comment}{// pSampleLocs    -\/ position of sample locations}}
\DoxyCodeLine{2074     \textcolor{comment}{// pDataOut       -\/ PRT Buffer that will store output results    }}
\DoxyCodeLine{2075     STDMETHOD(ComputeVolumeSamplesDirectSH)(THIS\_ UINT SHOrderIn, }
\DoxyCodeLine{2076                                             UINT SHOrderOut, }
\DoxyCodeLine{2077                                             UINT NumVolSamples,}
\DoxyCodeLine{2078                                             CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pSampleLocs,}
\DoxyCodeLine{2079                                             LPD3DXPRTBUFFER pDataOut) PURE;}
\DoxyCodeLine{2080                                     }
\DoxyCodeLine{2081     \textcolor{comment}{// At each sample location computes a linear operator (matrix) that maps}}
\DoxyCodeLine{2082     \textcolor{comment}{// the representation of source radiance (NumCoeffs in pSurfDataIn)}}
\DoxyCodeLine{2083     \textcolor{comment}{// into a local incident radiance function approximated with spherical }}
\DoxyCodeLine{2084     \textcolor{comment}{// harmonics.  For example if a light map data is specified in pSurfDataIn}}
\DoxyCodeLine{2085     \textcolor{comment}{// the result is an SH representation of the flow of light at each sample}}
\DoxyCodeLine{2086     \textcolor{comment}{// point.  If PRT data for an outdoor scene is used, each sample point}}
\DoxyCodeLine{2087     \textcolor{comment}{// contains a matrix that models how distant lighting bounces of the objects}}
\DoxyCodeLine{2088     \textcolor{comment}{// in the scene and arrives at the given sample point.  Combined with}}
\DoxyCodeLine{2089     \textcolor{comment}{// ComputeVolumeSamplesDirectSH this gives the complete representation for}}
\DoxyCodeLine{2090     \textcolor{comment}{// how light arrives at each sample point parameterized by distant lighting.}}
\DoxyCodeLine{2091     \textcolor{comment}{// SetSamplingInfo must be called with TRUE for UseSphere and}}
\DoxyCodeLine{2092     \textcolor{comment}{// FALSE for UseCosine before this method is called.    }}
\DoxyCodeLine{2093     \textcolor{comment}{// Generates pSurfDataIn-\/>NumCoeffs()*SHOrder*SHOrder scalars}}
\DoxyCodeLine{2094     \textcolor{comment}{// per channel at each sample location.}}
\DoxyCodeLine{2095     \textcolor{comment}{//}}
\DoxyCodeLine{2096     \textcolor{comment}{// pSurfDataIn    -\/ previous bounce data}}
\DoxyCodeLine{2097     \textcolor{comment}{// SHOrder        -\/ order of SH to generate projection with}}
\DoxyCodeLine{2098     \textcolor{comment}{// NumVolSamples  -\/ Number of sample locations}}
\DoxyCodeLine{2099     \textcolor{comment}{// pSampleLocs    -\/ position of sample locations}}
\DoxyCodeLine{2100     \textcolor{comment}{// pDataOut       -\/ PRT Buffer that will store output results}}
\DoxyCodeLine{2101     STDMETHOD(ComputeVolumeSamples)(THIS\_ LPD3DXPRTBUFFER pSurfDataIn, }
\DoxyCodeLine{2102                                     UINT SHOrder, }
\DoxyCodeLine{2103                                     UINT NumVolSamples,}
\DoxyCodeLine{2104                                     CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pSampleLocs,}
\DoxyCodeLine{2105                                     LPD3DXPRTBUFFER pDataOut) PURE;}
\DoxyCodeLine{2106 }
\DoxyCodeLine{2107     \textcolor{comment}{// Computes direct lighting (SH) for a point not on the mesh}}
\DoxyCodeLine{2108     \textcolor{comment}{// with a given normal -\/ cannot use texture buffers.}}
\DoxyCodeLine{2109     \textcolor{comment}{//}}
\DoxyCodeLine{2110     \textcolor{comment}{// SHOrder      -\/ order of SH to use}}
\DoxyCodeLine{2111     \textcolor{comment}{// NumSamples   -\/ number of sample locations}}
\DoxyCodeLine{2112     \textcolor{comment}{// pSampleLocs  -\/ position for each sample}}
\DoxyCodeLine{2113     \textcolor{comment}{// pSampleNorms -\/ normal for each sample}}
\DoxyCodeLine{2114     \textcolor{comment}{// pDataOut     -\/ PRT Buffer that will store output results}}
\DoxyCodeLine{2115     STDMETHOD(ComputeSurfSamplesDirectSH)(THIS\_ UINT SHOrder,}
\DoxyCodeLine{2116                                           UINT NumSamples,}
\DoxyCodeLine{2117                                           CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pSampleLocs,}
\DoxyCodeLine{2118                                           CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pSampleNorms,}
\DoxyCodeLine{2119                                           LPD3DXPRTBUFFER pDataOut) PURE;}
\DoxyCodeLine{2120 }
\DoxyCodeLine{2121 }
\DoxyCodeLine{2122     \textcolor{comment}{// given the solution for PRT or light maps, computes transfer vector at arbitrary }}
\DoxyCodeLine{2123     \textcolor{comment}{// position/normal pairs in space}}
\DoxyCodeLine{2124     \textcolor{comment}{//}}
\DoxyCodeLine{2125     \textcolor{comment}{// pSurfDataIn  -\/ input data}}
\DoxyCodeLine{2126     \textcolor{comment}{// NumSamples   -\/ number of sample locations}}
\DoxyCodeLine{2127     \textcolor{comment}{// pSampleLocs  -\/ position for each sample}}
\DoxyCodeLine{2128     \textcolor{comment}{// pSampleNorms -\/ normal for each sample}}
\DoxyCodeLine{2129     \textcolor{comment}{// pDataOut     -\/ PRT Buffer that will store output results}}
\DoxyCodeLine{2130     \textcolor{comment}{// pDataTotal   -\/ optional buffer to sum results into -\/ can be NULL}}
\DoxyCodeLine{2131     STDMETHOD(ComputeSurfSamplesBounce)(THIS\_ LPD3DXPRTBUFFER pSurfDataIn,}
\DoxyCodeLine{2132                                         UINT NumSamples,}
\DoxyCodeLine{2133                                         CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pSampleLocs,}
\DoxyCodeLine{2134                                         CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pSampleNorms,}
\DoxyCodeLine{2135                                         LPD3DXPRTBUFFER pDataOut,}
\DoxyCodeLine{2136                                         LPD3DXPRTBUFFER pDataTotal) PURE;}
\DoxyCodeLine{2137 }
\DoxyCodeLine{2138     \textcolor{comment}{// Frees temporary data structures that can be created for subsurface scattering}}
\DoxyCodeLine{2139     \textcolor{comment}{// this data is freed when the PRTComputeEngine is freed and is lazily created}}
\DoxyCodeLine{2140     STDMETHOD(FreeSSData)(THIS) PURE;}
\DoxyCodeLine{2141     }
\DoxyCodeLine{2142     \textcolor{comment}{// Frees temporary data structures that can be created for bounce simulations}}
\DoxyCodeLine{2143     \textcolor{comment}{// this data is freed when the PRTComputeEngine is freed and is lazily created}}
\DoxyCodeLine{2144     STDMETHOD(FreeBounceData)(THIS) PURE;}
\DoxyCodeLine{2145 }
\DoxyCodeLine{2146     \textcolor{comment}{// This computes the Local Deformable PRT (LDPRT) coefficients relative to the }}
\DoxyCodeLine{2147     \textcolor{comment}{// per sample normals that minimize error in a least squares sense with respect }}
\DoxyCodeLine{2148     \textcolor{comment}{// to the input PRT data set.  These coefficients can be used with skinned/transformed }}
\DoxyCodeLine{2149     \textcolor{comment}{// normals to model global effects with dynamic objects.  Shading normals can }}
\DoxyCodeLine{2150     \textcolor{comment}{// optionally be solved for -\/ these normals (along with the LDPRT coefficients) can}}
\DoxyCodeLine{2151     \textcolor{comment}{// more accurately represent the PRT signal.  The coefficients are for zonal}}
\DoxyCodeLine{2152     \textcolor{comment}{// harmonics oriented in the normal/shading normal direction.}}
\DoxyCodeLine{2153     \textcolor{comment}{//}}
\DoxyCodeLine{2154     \textcolor{comment}{// pDataIn  -\/ SH PRT dataset that is input}}
\DoxyCodeLine{2155     \textcolor{comment}{// SHOrder  -\/ Order of SH to compute conv coefficients for }}
\DoxyCodeLine{2156     \textcolor{comment}{// pNormOut -\/ Optional array of vectors (passed in) that will be filled with}}
\DoxyCodeLine{2157     \textcolor{comment}{//             "{}shading normals"{}, LDPRT coefficients are optimized for}}
\DoxyCodeLine{2158     \textcolor{comment}{//             these normals.  This array must be the same size as the number of}}
\DoxyCodeLine{2159     \textcolor{comment}{//             samples in pDataIn}}
\DoxyCodeLine{2160     \textcolor{comment}{// pDataOut -\/ Output buffer (SHOrder zonal harmonic coefficients per channel per sample)}}
\DoxyCodeLine{2161     STDMETHOD(ComputeLDPRTCoeffs)(THIS\_ LPD3DXPRTBUFFER pDataIn,}
\DoxyCodeLine{2162                                   UINT SHOrder,}
\DoxyCodeLine{2163                                   \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pNormOut,}
\DoxyCodeLine{2164                                   LPD3DXPRTBUFFER pDataOut) PURE;}
\DoxyCodeLine{2165 }
\DoxyCodeLine{2166     \textcolor{comment}{// scales all the samples associated with a given sub mesh}}
\DoxyCodeLine{2167     \textcolor{comment}{// can be useful when using subsurface scattering}}
\DoxyCodeLine{2168     \textcolor{comment}{// fScale -\/ value to scale each vector in submesh by}}
\DoxyCodeLine{2169     STDMETHOD(ScaleMeshChunk)(THIS\_ UINT uMeshChunk, FLOAT fScale, LPD3DXPRTBUFFER pDataOut) PURE;}
\DoxyCodeLine{2170     }
\DoxyCodeLine{2171     \textcolor{comment}{// mutliplies each PRT vector by the albedo -\/ can be used if you want to have the albedo}}
\DoxyCodeLine{2172     \textcolor{comment}{// burned into the dataset, often better not to do this.  If this is not done the user}}
\DoxyCodeLine{2173     \textcolor{comment}{// must mutliply the albedo themselves when rendering -\/ just multiply the albedo times}}
\DoxyCodeLine{2174     \textcolor{comment}{// the result of the PRT dot product.}}
\DoxyCodeLine{2175     \textcolor{comment}{// If pDataOut is a texture simulation result and there is an albedo texture it}}
\DoxyCodeLine{2176     \textcolor{comment}{// must be represented at the same resolution as the simulation buffer.  You can use}}
\DoxyCodeLine{2177     \textcolor{comment}{// LoadSurfaceFromSurface and set a new albedo texture if this is an issue -\/ but must}}
\DoxyCodeLine{2178     \textcolor{comment}{// be careful about how the gutters are handled.}}
\DoxyCodeLine{2179     \textcolor{comment}{//}}
\DoxyCodeLine{2180     \textcolor{comment}{// pDataOut -\/ dataset that will get albedo pushed into it}}
\DoxyCodeLine{2181     STDMETHOD(MultiplyAlbedo)(THIS\_ LPD3DXPRTBUFFER pDataOut) PURE;}
\DoxyCodeLine{2182     }
\DoxyCodeLine{2183     \textcolor{comment}{// Sets a pointer to an optional call back function that reports back to the}}
\DoxyCodeLine{2184     \textcolor{comment}{// user percentage done and gives them the option of quitting}}
\DoxyCodeLine{2185     \textcolor{comment}{// pCB -\/ pointer to call back function, return S\_OK for the simulation}}
\DoxyCodeLine{2186     \textcolor{comment}{//  to continue}}
\DoxyCodeLine{2187     \textcolor{comment}{// Frequency -\/ 1/Frequency is roughly the number of times the call back}}
\DoxyCodeLine{2188     \textcolor{comment}{//  will be invoked}}
\DoxyCodeLine{2189     \textcolor{comment}{// lpUserContext -\/ will be passed back to the users call back}}
\DoxyCodeLine{2190     STDMETHOD(SetCallBack)(THIS\_ LPD3DXSHPRTSIMCB pCB, FLOAT Frequency,  LPVOID lpUserContext) PURE;}
\DoxyCodeLine{2191     }
\DoxyCodeLine{2192     \textcolor{comment}{// Returns TRUE if the ray intersects the mesh, FALSE if it does not.  This function}}
\DoxyCodeLine{2193     \textcolor{comment}{// takes into account settings from SetMinMaxIntersection.  If the closest intersection}}
\DoxyCodeLine{2194     \textcolor{comment}{// is not needed this function is more efficient compared to the ClosestRayIntersection}}
\DoxyCodeLine{2195     \textcolor{comment}{// method.}}
\DoxyCodeLine{2196     \textcolor{comment}{// pRayPos -\/ origin of ray}}
\DoxyCodeLine{2197     \textcolor{comment}{// pRayDir -\/ normalized ray direction (normalization required for SetMinMax to be meaningful)}}
\DoxyCodeLine{2198     }
\DoxyCodeLine{2199     STDMETHOD\_(BOOL, ShadowRayIntersects)(THIS\_ CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pRayPos, CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pRayDir) PURE;}
\DoxyCodeLine{2200     }
\DoxyCodeLine{2201     \textcolor{comment}{// Returns TRUE if the ray intersects the mesh, FALSE if it does not.  If there is an}}
\DoxyCodeLine{2202     \textcolor{comment}{// intersection the closest face that was intersected and its first two barycentric coordinates}}
\DoxyCodeLine{2203     \textcolor{comment}{// are returned.  This function takes into account settings from SetMinMaxIntersection.}}
\DoxyCodeLine{2204     \textcolor{comment}{// This is a slower function compared to ShadowRayIntersects and should only be used where}}
\DoxyCodeLine{2205     \textcolor{comment}{// needed.  The third vertices barycentric coordinates will be 1 -\/ pU -\/ pV.}}
\DoxyCodeLine{2206     \textcolor{comment}{// pRayPos     -\/ origin of ray}}
\DoxyCodeLine{2207     \textcolor{comment}{// pRayDir     -\/ normalized ray direction (normalization required for SetMinMax to be meaningful)}}
\DoxyCodeLine{2208     \textcolor{comment}{// pFaceIndex  -\/ Closest face that intersects.  This index is based on stacking the pBlockerMesh}}
\DoxyCodeLine{2209     \textcolor{comment}{//  faces before the faces from pMesh}}
\DoxyCodeLine{2210     \textcolor{comment}{// pU          -\/ Barycentric coordinate for vertex 0}}
\DoxyCodeLine{2211     \textcolor{comment}{// pV          -\/ Barycentric coordinate for vertex 1}}
\DoxyCodeLine{2212     \textcolor{comment}{// pDist       -\/ Distance along ray where the intersection occured}}
\DoxyCodeLine{2213     }
\DoxyCodeLine{2214     STDMETHOD\_(BOOL, ClosestRayIntersects)(THIS\_ CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pRayPos, CONST \mbox{\hyperlink{struct___d3_d_v_e_c_t_o_r}{D3DXVECTOR3}} *pRayDir,}
\DoxyCodeLine{2215                                            DWORD *pFaceIndex, FLOAT *pU, FLOAT *pV, FLOAT *pDist) PURE;}
\DoxyCodeLine{2216 \};}
\DoxyCodeLine{2217 }
\DoxyCodeLine{2218 }
\DoxyCodeLine{2219 \textcolor{comment}{// API functions for creating interfaces}}
\DoxyCodeLine{2220 }
\DoxyCodeLine{2221 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{2222 \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \{}
\DoxyCodeLine{2223 \textcolor{preprocessor}{\#endif }\textcolor{comment}{//\_\_cplusplus}}
\DoxyCodeLine{2224 }
\DoxyCodeLine{2225 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2226 \textcolor{comment}{//}}
\DoxyCodeLine{2227 \textcolor{comment}{//  D3DXCreatePRTBuffer:}}
\DoxyCodeLine{2228 \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{2229 \textcolor{comment}{//  Generates a PRT Buffer that can be compressed or filled by a simulator}}
\DoxyCodeLine{2230 \textcolor{comment}{//  This function should be used to create per-\/vertex or volume buffers.}}
\DoxyCodeLine{2231 \textcolor{comment}{//  When buffers are created all values are initialized to zero.}}
\DoxyCodeLine{2232 \textcolor{comment}{//}}
\DoxyCodeLine{2233 \textcolor{comment}{//  Parameters:}}
\DoxyCodeLine{2234 \textcolor{comment}{//    NumSamples}}
\DoxyCodeLine{2235 \textcolor{comment}{//      Number of sample locations represented}}
\DoxyCodeLine{2236 \textcolor{comment}{//    NumCoeffs}}
\DoxyCodeLine{2237 \textcolor{comment}{//      Number of coefficients per sample location (order\string^2 for SH)}}
\DoxyCodeLine{2238 \textcolor{comment}{//    NumChannels}}
\DoxyCodeLine{2239 \textcolor{comment}{//      Number of color channels to represent (1 or 3)}}
\DoxyCodeLine{2240 \textcolor{comment}{//    ppBuffer}}
\DoxyCodeLine{2241 \textcolor{comment}{//      Buffer that will be allocated}}
\DoxyCodeLine{2242 \textcolor{comment}{//}}
\DoxyCodeLine{2243 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2244 }
\DoxyCodeLine{2245 HRESULT WINAPI }
\DoxyCodeLine{2246     D3DXCreatePRTBuffer( }
\DoxyCodeLine{2247         UINT NumSamples,}
\DoxyCodeLine{2248         UINT NumCoeffs,}
\DoxyCodeLine{2249         UINT NumChannels,}
\DoxyCodeLine{2250         LPD3DXPRTBUFFER* ppBuffer);}
\DoxyCodeLine{2251 }
\DoxyCodeLine{2252 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2253 \textcolor{comment}{//}}
\DoxyCodeLine{2254 \textcolor{comment}{//  D3DXCreatePRTBufferTex:}}
\DoxyCodeLine{2255 \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{2256 \textcolor{comment}{//  Generates a PRT Buffer that can be compressed or filled by a simulator}}
\DoxyCodeLine{2257 \textcolor{comment}{//  This function should be used to create per-\/pixel buffers.}}
\DoxyCodeLine{2258 \textcolor{comment}{//  When buffers are created all values are initialized to zero.}}
\DoxyCodeLine{2259 \textcolor{comment}{//}}
\DoxyCodeLine{2260 \textcolor{comment}{//  Parameters:}}
\DoxyCodeLine{2261 \textcolor{comment}{//    Width}}
\DoxyCodeLine{2262 \textcolor{comment}{//      Width of texture}}
\DoxyCodeLine{2263 \textcolor{comment}{//    Height}}
\DoxyCodeLine{2264 \textcolor{comment}{//      Height of texture}}
\DoxyCodeLine{2265 \textcolor{comment}{//    NumCoeffs}}
\DoxyCodeLine{2266 \textcolor{comment}{//      Number of coefficients per sample location (order\string^2 for SH)}}
\DoxyCodeLine{2267 \textcolor{comment}{//    NumChannels}}
\DoxyCodeLine{2268 \textcolor{comment}{//      Number of color channels to represent (1 or 3)}}
\DoxyCodeLine{2269 \textcolor{comment}{//    ppBuffer}}
\DoxyCodeLine{2270 \textcolor{comment}{//      Buffer that will be allocated}}
\DoxyCodeLine{2271 \textcolor{comment}{//}}
\DoxyCodeLine{2272 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2273 }
\DoxyCodeLine{2274 HRESULT WINAPI}
\DoxyCodeLine{2275     D3DXCreatePRTBufferTex( }
\DoxyCodeLine{2276         UINT Width,}
\DoxyCodeLine{2277         UINT Height,}
\DoxyCodeLine{2278         UINT NumCoeffs,}
\DoxyCodeLine{2279         UINT NumChannels,}
\DoxyCodeLine{2280         LPD3DXPRTBUFFER* ppBuffer);}
\DoxyCodeLine{2281 }
\DoxyCodeLine{2282 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2283 \textcolor{comment}{//}}
\DoxyCodeLine{2284 \textcolor{comment}{//  D3DXLoadPRTBufferFromFile:}}
\DoxyCodeLine{2285 \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{2286 \textcolor{comment}{//  Loads a PRT buffer that has been saved to disk.}}
\DoxyCodeLine{2287 \textcolor{comment}{//}}
\DoxyCodeLine{2288 \textcolor{comment}{//  Parameters:}}
\DoxyCodeLine{2289 \textcolor{comment}{//    pFilename}}
\DoxyCodeLine{2290 \textcolor{comment}{//      Name of the file to load}}
\DoxyCodeLine{2291 \textcolor{comment}{//    ppBuffer}}
\DoxyCodeLine{2292 \textcolor{comment}{//      Buffer that will be allocated}}
\DoxyCodeLine{2293 \textcolor{comment}{//}}
\DoxyCodeLine{2294 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2295 }
\DoxyCodeLine{2296 HRESULT WINAPI}
\DoxyCodeLine{2297     D3DXLoadPRTBufferFromFileA(}
\DoxyCodeLine{2298         LPCSTR pFilename, }
\DoxyCodeLine{2299         LPD3DXPRTBUFFER*       ppBuffer);}
\DoxyCodeLine{2300         }
\DoxyCodeLine{2301 HRESULT WINAPI}
\DoxyCodeLine{2302     D3DXLoadPRTBufferFromFileW(}
\DoxyCodeLine{2303         LPCWSTR pFilename, }
\DoxyCodeLine{2304         LPD3DXPRTBUFFER*       ppBuffer);}
\DoxyCodeLine{2305 }
\DoxyCodeLine{2306 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{2307 \textcolor{preprocessor}{\#define D3DXLoadPRTBufferFromFile D3DXLoadPRTBufferFromFileW}}
\DoxyCodeLine{2308 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2309 \textcolor{preprocessor}{\#define D3DXLoadPRTBufferFromFile D3DXLoadPRTBufferFromFileA}}
\DoxyCodeLine{2310 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2311 }
\DoxyCodeLine{2312 }
\DoxyCodeLine{2313 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2314 \textcolor{comment}{//}}
\DoxyCodeLine{2315 \textcolor{comment}{//  D3DXSavePRTBufferToFile:}}
\DoxyCodeLine{2316 \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{2317 \textcolor{comment}{//  Saves a PRTBuffer to disk.}}
\DoxyCodeLine{2318 \textcolor{comment}{//}}
\DoxyCodeLine{2319 \textcolor{comment}{//  Parameters:}}
\DoxyCodeLine{2320 \textcolor{comment}{//    pFilename}}
\DoxyCodeLine{2321 \textcolor{comment}{//      Name of the file to save}}
\DoxyCodeLine{2322 \textcolor{comment}{//    pBuffer}}
\DoxyCodeLine{2323 \textcolor{comment}{//      Buffer that will be saved}}
\DoxyCodeLine{2324 \textcolor{comment}{//}}
\DoxyCodeLine{2325 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2326 }
\DoxyCodeLine{2327 HRESULT WINAPI}
\DoxyCodeLine{2328     D3DXSavePRTBufferToFileA(}
\DoxyCodeLine{2329         LPCSTR pFileName,}
\DoxyCodeLine{2330         LPD3DXPRTBUFFER pBuffer);}
\DoxyCodeLine{2331         }
\DoxyCodeLine{2332 HRESULT WINAPI}
\DoxyCodeLine{2333     D3DXSavePRTBufferToFileW(}
\DoxyCodeLine{2334         LPCWSTR pFileName,}
\DoxyCodeLine{2335         LPD3DXPRTBUFFER pBuffer);}
\DoxyCodeLine{2336 }
\DoxyCodeLine{2337 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{2338 \textcolor{preprocessor}{\#define D3DXSavePRTBufferToFile D3DXSavePRTBufferToFileW}}
\DoxyCodeLine{2339 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2340 \textcolor{preprocessor}{\#define D3DXSavePRTBufferToFile D3DXSavePRTBufferToFileA}}
\DoxyCodeLine{2341 \textcolor{preprocessor}{\#endif                }}
\DoxyCodeLine{2342 }
\DoxyCodeLine{2343 }
\DoxyCodeLine{2344 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2345 \textcolor{comment}{//}}
\DoxyCodeLine{2346 \textcolor{comment}{//  D3DXLoadPRTCompBufferFromFile:}}
\DoxyCodeLine{2347 \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{2348 \textcolor{comment}{//  Loads a PRTComp buffer that has been saved to disk.}}
\DoxyCodeLine{2349 \textcolor{comment}{//}}
\DoxyCodeLine{2350 \textcolor{comment}{//  Parameters:}}
\DoxyCodeLine{2351 \textcolor{comment}{//    pFilename}}
\DoxyCodeLine{2352 \textcolor{comment}{//      Name of the file to load}}
\DoxyCodeLine{2353 \textcolor{comment}{//    ppBuffer}}
\DoxyCodeLine{2354 \textcolor{comment}{//      Buffer that will be allocated}}
\DoxyCodeLine{2355 \textcolor{comment}{//}}
\DoxyCodeLine{2356 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2357 }
\DoxyCodeLine{2358 HRESULT WINAPI}
\DoxyCodeLine{2359     D3DXLoadPRTCompBufferFromFileA(}
\DoxyCodeLine{2360         LPCSTR pFilename, }
\DoxyCodeLine{2361         LPD3DXPRTCOMPBUFFER*       ppBuffer);}
\DoxyCodeLine{2362         }
\DoxyCodeLine{2363 HRESULT WINAPI}
\DoxyCodeLine{2364     D3DXLoadPRTCompBufferFromFileW(}
\DoxyCodeLine{2365         LPCWSTR pFilename, }
\DoxyCodeLine{2366         LPD3DXPRTCOMPBUFFER*       ppBuffer);}
\DoxyCodeLine{2367 }
\DoxyCodeLine{2368 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{2369 \textcolor{preprocessor}{\#define D3DXLoadPRTCompBufferFromFile D3DXLoadPRTCompBufferFromFileW}}
\DoxyCodeLine{2370 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2371 \textcolor{preprocessor}{\#define D3DXLoadPRTCompBufferFromFile D3DXLoadPRTCompBufferFromFileA}}
\DoxyCodeLine{2372 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2373 }
\DoxyCodeLine{2374 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2375 \textcolor{comment}{//}}
\DoxyCodeLine{2376 \textcolor{comment}{//  D3DXSavePRTCompBufferToFile:}}
\DoxyCodeLine{2377 \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{2378 \textcolor{comment}{//  Saves a PRTCompBuffer to disk.}}
\DoxyCodeLine{2379 \textcolor{comment}{//}}
\DoxyCodeLine{2380 \textcolor{comment}{//  Parameters:}}
\DoxyCodeLine{2381 \textcolor{comment}{//    pFilename}}
\DoxyCodeLine{2382 \textcolor{comment}{//      Name of the file to save}}
\DoxyCodeLine{2383 \textcolor{comment}{//    pBuffer}}
\DoxyCodeLine{2384 \textcolor{comment}{//      Buffer that will be saved}}
\DoxyCodeLine{2385 \textcolor{comment}{//}}
\DoxyCodeLine{2386 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2387 }
\DoxyCodeLine{2388 HRESULT WINAPI}
\DoxyCodeLine{2389     D3DXSavePRTCompBufferToFileA(}
\DoxyCodeLine{2390         LPCSTR pFileName,}
\DoxyCodeLine{2391         LPD3DXPRTCOMPBUFFER pBuffer);}
\DoxyCodeLine{2392         }
\DoxyCodeLine{2393 HRESULT WINAPI}
\DoxyCodeLine{2394     D3DXSavePRTCompBufferToFileW(}
\DoxyCodeLine{2395         LPCWSTR pFileName,}
\DoxyCodeLine{2396         LPD3DXPRTCOMPBUFFER pBuffer);}
\DoxyCodeLine{2397 }
\DoxyCodeLine{2398 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{2399 \textcolor{preprocessor}{\#define D3DXSavePRTCompBufferToFile D3DXSavePRTCompBufferToFileW}}
\DoxyCodeLine{2400 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2401 \textcolor{preprocessor}{\#define D3DXSavePRTCompBufferToFile D3DXSavePRTCompBufferToFileA}}
\DoxyCodeLine{2402 \textcolor{preprocessor}{\#endif }}
\DoxyCodeLine{2403 }
\DoxyCodeLine{2404 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2405 \textcolor{comment}{//}}
\DoxyCodeLine{2406 \textcolor{comment}{//  D3DXCreatePRTCompBuffer:}}
\DoxyCodeLine{2407 \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{2408 \textcolor{comment}{//  Compresses a PRT buffer (vertex or texel)}}
\DoxyCodeLine{2409 \textcolor{comment}{//}}
\DoxyCodeLine{2410 \textcolor{comment}{//  Parameters:}}
\DoxyCodeLine{2411 \textcolor{comment}{//    D3DXSHCOMPRESSQUALITYTYPE}}
\DoxyCodeLine{2412 \textcolor{comment}{//      Quality of compression -\/ low is faster (computes PCA per voronoi cluster)}}
\DoxyCodeLine{2413 \textcolor{comment}{//      high is slower but better quality (clusters based on distance to affine subspace)}}
\DoxyCodeLine{2414 \textcolor{comment}{//    NumClusters}}
\DoxyCodeLine{2415 \textcolor{comment}{//      Number of clusters to compute}}
\DoxyCodeLine{2416 \textcolor{comment}{//    NumPCA}}
\DoxyCodeLine{2417 \textcolor{comment}{//      Number of basis vectors to compute}}
\DoxyCodeLine{2418 \textcolor{comment}{//    pCB}}
\DoxyCodeLine{2419 \textcolor{comment}{//      Optional Callback function}}
\DoxyCodeLine{2420 \textcolor{comment}{//    lpUserContext}}
\DoxyCodeLine{2421 \textcolor{comment}{//      Optional user context}}
\DoxyCodeLine{2422 \textcolor{comment}{//    pBufferIn}}
\DoxyCodeLine{2423 \textcolor{comment}{//      Buffer that will be compressed}}
\DoxyCodeLine{2424 \textcolor{comment}{//    ppBufferOut}}
\DoxyCodeLine{2425 \textcolor{comment}{//      Compressed buffer that will be created}}
\DoxyCodeLine{2426 \textcolor{comment}{//}}
\DoxyCodeLine{2427 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2428 }
\DoxyCodeLine{2429 }
\DoxyCodeLine{2430 HRESULT WINAPI}
\DoxyCodeLine{2431     D3DXCreatePRTCompBuffer(}
\DoxyCodeLine{2432         D3DXSHCOMPRESSQUALITYTYPE Quality,}
\DoxyCodeLine{2433         UINT NumClusters, }
\DoxyCodeLine{2434         UINT NumPCA,}
\DoxyCodeLine{2435         LPD3DXSHPRTSIMCB pCB,}
\DoxyCodeLine{2436         LPVOID lpUserContext,        }
\DoxyCodeLine{2437         LPD3DXPRTBUFFER  pBufferIn,}
\DoxyCodeLine{2438         LPD3DXPRTCOMPBUFFER *ppBufferOut}
\DoxyCodeLine{2439     );}
\DoxyCodeLine{2440 }
\DoxyCodeLine{2441 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2442 \textcolor{comment}{//}}
\DoxyCodeLine{2443 \textcolor{comment}{//  D3DXCreateTextureGutterHelper:}}
\DoxyCodeLine{2444 \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{2445 \textcolor{comment}{//  Generates a "{}GutterHelper"{} for a given set of meshes and texture}}
\DoxyCodeLine{2446 \textcolor{comment}{//  resolution}}
\DoxyCodeLine{2447 \textcolor{comment}{//}}
\DoxyCodeLine{2448 \textcolor{comment}{//  Parameters:}}
\DoxyCodeLine{2449 \textcolor{comment}{//    Width}}
\DoxyCodeLine{2450 \textcolor{comment}{//      Width of texture}}
\DoxyCodeLine{2451 \textcolor{comment}{//    Height}}
\DoxyCodeLine{2452 \textcolor{comment}{//      Height of texture}}
\DoxyCodeLine{2453 \textcolor{comment}{//    pMesh}}
\DoxyCodeLine{2454 \textcolor{comment}{//      Mesh that represents the scene}}
\DoxyCodeLine{2455 \textcolor{comment}{//    GutterSize}}
\DoxyCodeLine{2456 \textcolor{comment}{//      Number of texels to over rasterize in texture space}}
\DoxyCodeLine{2457 \textcolor{comment}{//      this should be at least 1.0}}
\DoxyCodeLine{2458 \textcolor{comment}{//    ppBuffer}}
\DoxyCodeLine{2459 \textcolor{comment}{//      GutterHelper that will be created}}
\DoxyCodeLine{2460 \textcolor{comment}{//}}
\DoxyCodeLine{2461 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2462 }
\DoxyCodeLine{2463 }
\DoxyCodeLine{2464 HRESULT WINAPI }
\DoxyCodeLine{2465     D3DXCreateTextureGutterHelper( }
\DoxyCodeLine{2466         UINT Width,}
\DoxyCodeLine{2467         UINT Height,}
\DoxyCodeLine{2468         LPD3DXMESH pMesh, }
\DoxyCodeLine{2469         FLOAT GutterSize,}
\DoxyCodeLine{2470         LPD3DXTEXTUREGUTTERHELPER* ppBuffer);}
\DoxyCodeLine{2471 }
\DoxyCodeLine{2472 }
\DoxyCodeLine{2473 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2474 \textcolor{comment}{//}}
\DoxyCodeLine{2475 \textcolor{comment}{//  D3DXCreatePRTEngine:}}
\DoxyCodeLine{2476 \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{2477 \textcolor{comment}{//  Computes a PRTEngine which can efficiently generate PRT simulations}}
\DoxyCodeLine{2478 \textcolor{comment}{//  of a scene}}
\DoxyCodeLine{2479 \textcolor{comment}{//}}
\DoxyCodeLine{2480 \textcolor{comment}{//  Parameters:}}
\DoxyCodeLine{2481 \textcolor{comment}{//    pMesh}}
\DoxyCodeLine{2482 \textcolor{comment}{//      Mesh that represents the scene -\/ must have an AttributeTable}}
\DoxyCodeLine{2483 \textcolor{comment}{//      where vertices are in a unique attribute.}}
\DoxyCodeLine{2484 \textcolor{comment}{//    pAdjacency}}
\DoxyCodeLine{2485 \textcolor{comment}{//      Optional adjacency information}}
\DoxyCodeLine{2486 \textcolor{comment}{//    ExtractUVs}}
\DoxyCodeLine{2487 \textcolor{comment}{//      Set this to true if textures are going to be used for albedos}}
\DoxyCodeLine{2488 \textcolor{comment}{//      or to store PRT vectors}}
\DoxyCodeLine{2489 \textcolor{comment}{//    pBlockerMesh}}
\DoxyCodeLine{2490 \textcolor{comment}{//      Optional mesh that just blocks the scene}}
\DoxyCodeLine{2491 \textcolor{comment}{//    ppEngine}}
\DoxyCodeLine{2492 \textcolor{comment}{//      PRTEngine that will be created}}
\DoxyCodeLine{2493 \textcolor{comment}{//}}
\DoxyCodeLine{2494 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2495 }
\DoxyCodeLine{2496 }
\DoxyCodeLine{2497 HRESULT WINAPI }
\DoxyCodeLine{2498     D3DXCreatePRTEngine( }
\DoxyCodeLine{2499         LPD3DXMESH pMesh,}
\DoxyCodeLine{2500         DWORD *pAdjacency,}
\DoxyCodeLine{2501         BOOL ExtractUVs,}
\DoxyCodeLine{2502         LPD3DXMESH pBlockerMesh, }
\DoxyCodeLine{2503         LPD3DXPRTENGINE* ppEngine);}
\DoxyCodeLine{2504 }
\DoxyCodeLine{2505 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2506 \textcolor{comment}{//}}
\DoxyCodeLine{2507 \textcolor{comment}{//  D3DXConcatenateMeshes:}}
\DoxyCodeLine{2508 \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{2509 \textcolor{comment}{//  Concatenates a group of meshes into one common mesh.  This can optionaly transform}}
\DoxyCodeLine{2510 \textcolor{comment}{//  each sub mesh or its texture coordinates.  If no DECL is given it will}}
\DoxyCodeLine{2511 \textcolor{comment}{//  generate a union of all of the DECL's of the sub meshes, promoting channels}}
\DoxyCodeLine{2512 \textcolor{comment}{//  and types if neccesary.  It will create an AttributeTable if possible, one can}}
\DoxyCodeLine{2513 \textcolor{comment}{//  call OptimizeMesh with attribute sort and compacting enabled to ensure this.}}
\DoxyCodeLine{2514 \textcolor{comment}{//}}
\DoxyCodeLine{2515 \textcolor{comment}{//  Parameters:}}
\DoxyCodeLine{2516 \textcolor{comment}{//    ppMeshes}}
\DoxyCodeLine{2517 \textcolor{comment}{//      Array of pointers to meshes that can store PRT vectors}}
\DoxyCodeLine{2518 \textcolor{comment}{//    NumMeshes}}
\DoxyCodeLine{2519 \textcolor{comment}{//      Number of meshes}}
\DoxyCodeLine{2520 \textcolor{comment}{//    Options}}
\DoxyCodeLine{2521 \textcolor{comment}{//      Passed through to D3DXCreateMesh}}
\DoxyCodeLine{2522 \textcolor{comment}{//    pGeomXForms}}
\DoxyCodeLine{2523 \textcolor{comment}{//      [optional] Each sub mesh is transformed by the corresponding}}
\DoxyCodeLine{2524 \textcolor{comment}{//      matrix if this array is supplied}}
\DoxyCodeLine{2525 \textcolor{comment}{//    pTextureXForms}}
\DoxyCodeLine{2526 \textcolor{comment}{//      [optional] UV coordinates for each sub mesh are transformed}}
\DoxyCodeLine{2527 \textcolor{comment}{//      by corresponding matrix if supplied}}
\DoxyCodeLine{2528 \textcolor{comment}{//    pDecl}}
\DoxyCodeLine{2529 \textcolor{comment}{//      [optional] Only information in this DECL is used when merging}}
\DoxyCodeLine{2530 \textcolor{comment}{//      data}}
\DoxyCodeLine{2531 \textcolor{comment}{//    pD3DDevice}}
\DoxyCodeLine{2532 \textcolor{comment}{//      D3D device that is used to create the new mesh}}
\DoxyCodeLine{2533 \textcolor{comment}{//    ppMeshOut}}
\DoxyCodeLine{2534 \textcolor{comment}{//      Mesh that will be created}}
\DoxyCodeLine{2535 \textcolor{comment}{//}}
\DoxyCodeLine{2536 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2537 }
\DoxyCodeLine{2538 }
\DoxyCodeLine{2539 HRESULT WINAPI }
\DoxyCodeLine{2540     D3DXConcatenateMeshes(}
\DoxyCodeLine{2541         LPD3DXMESH *ppMeshes, }
\DoxyCodeLine{2542         UINT NumMeshes, }
\DoxyCodeLine{2543         DWORD Options, }
\DoxyCodeLine{2544         CONST \mbox{\hyperlink{struct___d3_d_m_a_t_r_i_x}{D3DXMATRIX}} *pGeomXForms, }
\DoxyCodeLine{2545         CONST \mbox{\hyperlink{struct___d3_d_m_a_t_r_i_x}{D3DXMATRIX}} *pTextureXForms, }
\DoxyCodeLine{2546         CONST \mbox{\hyperlink{struct___d3_d_v_e_r_t_e_x_e_l_e_m_e_n_t9}{D3DVERTEXELEMENT9}} *pDecl,}
\DoxyCodeLine{2547         LPDIRECT3DDEVICE9 pD3DDevice, }
\DoxyCodeLine{2548         LPD3DXMESH *ppMeshOut);}
\DoxyCodeLine{2549 }
\DoxyCodeLine{2550 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2551 \textcolor{comment}{//}}
\DoxyCodeLine{2552 \textcolor{comment}{//  D3DXSHPRTCompSuperCluster:}}
\DoxyCodeLine{2553 \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{2554 \textcolor{comment}{//  Used with compressed results of D3DXSHPRTSimulation.}}
\DoxyCodeLine{2555 \textcolor{comment}{//  Generates "{}super clusters"{} -\/ groups of clusters that can be drawn in}}
\DoxyCodeLine{2556 \textcolor{comment}{//  the same draw call.  A greedy algorithm that minimizes overdraw is used}}
\DoxyCodeLine{2557 \textcolor{comment}{//  to group the clusters.}}
\DoxyCodeLine{2558 \textcolor{comment}{//}}
\DoxyCodeLine{2559 \textcolor{comment}{//  Parameters:}}
\DoxyCodeLine{2560 \textcolor{comment}{//   pClusterIDs}}
\DoxyCodeLine{2561 \textcolor{comment}{//      NumVerts cluster ID's (extracted from a compressed buffer)}}
\DoxyCodeLine{2562 \textcolor{comment}{//   pScene}}
\DoxyCodeLine{2563 \textcolor{comment}{//      Mesh that represents composite scene passed to the simulator}}
\DoxyCodeLine{2564 \textcolor{comment}{//   MaxNumClusters}}
\DoxyCodeLine{2565 \textcolor{comment}{//      Maximum number of clusters allocated per super cluster}}
\DoxyCodeLine{2566 \textcolor{comment}{//   NumClusters}}
\DoxyCodeLine{2567 \textcolor{comment}{//      Number of clusters computed in the simulator}}
\DoxyCodeLine{2568 \textcolor{comment}{//   pSuperClusterIDs}}
\DoxyCodeLine{2569 \textcolor{comment}{//      Array of length NumClusters, contains index of super cluster}}
\DoxyCodeLine{2570 \textcolor{comment}{//      that corresponding cluster was assigned to}}
\DoxyCodeLine{2571 \textcolor{comment}{//   pNumSuperClusters}}
\DoxyCodeLine{2572 \textcolor{comment}{//      Returns the number of super clusters allocated}}
\DoxyCodeLine{2573 \textcolor{comment}{//      }}
\DoxyCodeLine{2574 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2575 }
\DoxyCodeLine{2576 HRESULT WINAPI }
\DoxyCodeLine{2577     D3DXSHPRTCompSuperCluster(}
\DoxyCodeLine{2578         UINT *pClusterIDs, }
\DoxyCodeLine{2579         LPD3DXMESH pScene, }
\DoxyCodeLine{2580         UINT MaxNumClusters, }
\DoxyCodeLine{2581         UINT NumClusters,}
\DoxyCodeLine{2582         UINT *pSuperClusterIDs, }
\DoxyCodeLine{2583         UINT *pNumSuperClusters);}
\DoxyCodeLine{2584 }
\DoxyCodeLine{2585 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2586 \textcolor{comment}{//}}
\DoxyCodeLine{2587 \textcolor{comment}{//  D3DXSHPRTCompSplitMeshSC:}}
\DoxyCodeLine{2588 \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{2589 \textcolor{comment}{//  Used with compressed results of the vertex version of the PRT simulator.}}
\DoxyCodeLine{2590 \textcolor{comment}{//  After D3DXSHRTCompSuperCluster has been called this function can be used}}
\DoxyCodeLine{2591 \textcolor{comment}{//  to split the mesh into a group of faces/vertices per super cluster.}}
\DoxyCodeLine{2592 \textcolor{comment}{//  Each super cluster contains all of the faces that contain any vertex}}
\DoxyCodeLine{2593 \textcolor{comment}{//  classified in one of its clusters.  All of the vertices connected to this}}
\DoxyCodeLine{2594 \textcolor{comment}{//  set of faces are also included with the returned array ppVertStatus }}
\DoxyCodeLine{2595 \textcolor{comment}{//  indicating whether or not the vertex belongs to the supercluster.}}
\DoxyCodeLine{2596 \textcolor{comment}{//}}
\DoxyCodeLine{2597 \textcolor{comment}{//  Parameters:}}
\DoxyCodeLine{2598 \textcolor{comment}{//   pClusterIDs}}
\DoxyCodeLine{2599 \textcolor{comment}{//      NumVerts cluster ID's (extracted from a compressed buffer)}}
\DoxyCodeLine{2600 \textcolor{comment}{//   NumVertices}}
\DoxyCodeLine{2601 \textcolor{comment}{//      Number of vertices in original mesh}}
\DoxyCodeLine{2602 \textcolor{comment}{//   NumClusters}}
\DoxyCodeLine{2603 \textcolor{comment}{//      Number of clusters (input parameter to compression)}}
\DoxyCodeLine{2604 \textcolor{comment}{//   pSuperClusterIDs}}
\DoxyCodeLine{2605 \textcolor{comment}{//      Array of size NumClusters that will contain super cluster ID's (from}}
\DoxyCodeLine{2606 \textcolor{comment}{//      D3DXSHCompSuerCluster)}}
\DoxyCodeLine{2607 \textcolor{comment}{//   NumSuperClusters}}
\DoxyCodeLine{2608 \textcolor{comment}{//      Number of superclusters allocated in D3DXSHCompSuerCluster}}
\DoxyCodeLine{2609 \textcolor{comment}{//   pInputIB}}
\DoxyCodeLine{2610 \textcolor{comment}{//      Raw index buffer for mesh -\/ format depends on bInputIBIs32Bit}}
\DoxyCodeLine{2611 \textcolor{comment}{//   InputIBIs32Bit}}
\DoxyCodeLine{2612 \textcolor{comment}{//      Indicates whether the input index buffer is 32-\/bit (otherwise 16-\/bit}}
\DoxyCodeLine{2613 \textcolor{comment}{//      is assumed)}}
\DoxyCodeLine{2614 \textcolor{comment}{//   NumFaces}}
\DoxyCodeLine{2615 \textcolor{comment}{//      Number of faces in the original mesh (pInputIB is 3 times this length)}}
\DoxyCodeLine{2616 \textcolor{comment}{//   ppIBData}}
\DoxyCodeLine{2617 \textcolor{comment}{//      LPD3DXBUFFER holds raw index buffer that will contain the resulting split faces.  }}
\DoxyCodeLine{2618 \textcolor{comment}{//      Format determined by bIBIs32Bit.  Allocated by function}}
\DoxyCodeLine{2619 \textcolor{comment}{//   pIBDataLength}}
\DoxyCodeLine{2620 \textcolor{comment}{//      Length of ppIBData, assigned in function}}
\DoxyCodeLine{2621 \textcolor{comment}{//   OutputIBIs32Bit}}
\DoxyCodeLine{2622 \textcolor{comment}{//      Indicates whether the output index buffer is to be 32-\/bit (otherwise }}
\DoxyCodeLine{2623 \textcolor{comment}{//      16-\/bit is assumed)}}
\DoxyCodeLine{2624 \textcolor{comment}{//   ppFaceRemap}}
\DoxyCodeLine{2625 \textcolor{comment}{//      LPD3DXBUFFER mapping of each face in ppIBData to original faces.  Length is}}
\DoxyCodeLine{2626 \textcolor{comment}{//      *pIBDataLength/3.  Optional paramter, allocated in function}}
\DoxyCodeLine{2627 \textcolor{comment}{//   ppVertData}}
\DoxyCodeLine{2628 \textcolor{comment}{//      LPD3DXBUFFER contains new vertex data structure.  Size of pVertDataLength}}
\DoxyCodeLine{2629 \textcolor{comment}{//   pVertDataLength}}
\DoxyCodeLine{2630 \textcolor{comment}{//      Number of new vertices in split mesh.  Assigned in function}}
\DoxyCodeLine{2631 \textcolor{comment}{//   pSCClusterList}}
\DoxyCodeLine{2632 \textcolor{comment}{//      Array of length NumClusters which pSCData indexes into (Cluster* fields)}}
\DoxyCodeLine{2633 \textcolor{comment}{//      for each SC, contains clusters sorted by super cluster}}
\DoxyCodeLine{2634 \textcolor{comment}{//   pSCData}}
\DoxyCodeLine{2635 \textcolor{comment}{//      Structure per super cluster -\/ contains indices into ppIBData,}}
\DoxyCodeLine{2636 \textcolor{comment}{//      pSCClusterList and ppVertData}}
\DoxyCodeLine{2637 \textcolor{comment}{//}}
\DoxyCodeLine{2638 \textcolor{comment}{//============================================================================}}
\DoxyCodeLine{2639 }
\DoxyCodeLine{2640 HRESULT WINAPI }
\DoxyCodeLine{2641     D3DXSHPRTCompSplitMeshSC(}
\DoxyCodeLine{2642         UINT *pClusterIDs, }
\DoxyCodeLine{2643         UINT NumVertices, }
\DoxyCodeLine{2644         UINT NumClusters, }
\DoxyCodeLine{2645         UINT *pSuperClusterIDs, }
\DoxyCodeLine{2646         UINT NumSuperClusters,}
\DoxyCodeLine{2647         LPVOID pInputIB, }
\DoxyCodeLine{2648         BOOL InputIBIs32Bit, }
\DoxyCodeLine{2649         UINT NumFaces,}
\DoxyCodeLine{2650         LPD3DXBUFFER *ppIBData, }
\DoxyCodeLine{2651         UINT *pIBDataLength, }
\DoxyCodeLine{2652         BOOL OutputIBIs32Bit, }
\DoxyCodeLine{2653         LPD3DXBUFFER *ppFaceRemap, }
\DoxyCodeLine{2654         LPD3DXBUFFER *ppVertData, }
\DoxyCodeLine{2655         UINT *pVertDataLength, }
\DoxyCodeLine{2656         UINT *pSCClusterList,}
\DoxyCodeLine{2657         \mbox{\hyperlink{struct___d3_d_x_s_h_p_r_t_s_p_l_i_t_m_e_s_h_c_l_u_s_t_e_r_d_a_t_a}{D3DXSHPRTSPLITMESHCLUSTERDATA}} *pSCData);}
\DoxyCodeLine{2658         }
\DoxyCodeLine{2659         }
\DoxyCodeLine{2660 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{2661 \}}
\DoxyCodeLine{2662 \textcolor{preprocessor}{\#endif }\textcolor{comment}{//\_\_cplusplus}}
\DoxyCodeLine{2663 }
\DoxyCodeLine{2665 \textcolor{comment}{//}}
\DoxyCodeLine{2666 \textcolor{comment}{//  Definitions of .X file templates used by mesh load/save functions }}
\DoxyCodeLine{2667 \textcolor{comment}{//    that are not RM standard}}
\DoxyCodeLine{2668 \textcolor{comment}{//}}
\DoxyCodeLine{2670 \textcolor{comment}{}}
\DoxyCodeLine{2671 \textcolor{comment}{// \{3CF169CE-\/FF7C-\/44ab-\/93C0-\/F78F62D172E2\}}}
\DoxyCodeLine{2672 DEFINE\_GUID(DXFILEOBJ\_XSkinMeshHeader,}
\DoxyCodeLine{2673 0x3cf169ce, 0xff7c, 0x44ab, 0x93, 0xc0, 0xf7, 0x8f, 0x62, 0xd1, 0x72, 0xe2);}
\DoxyCodeLine{2674 }
\DoxyCodeLine{2675 \textcolor{comment}{// \{B8D65549-\/D7C9-\/4995-\/89CF-\/53A9A8B031E3\}}}
\DoxyCodeLine{2676 DEFINE\_GUID(DXFILEOBJ\_VertexDuplicationIndices, }
\DoxyCodeLine{2677 0xb8d65549, 0xd7c9, 0x4995, 0x89, 0xcf, 0x53, 0xa9, 0xa8, 0xb0, 0x31, 0xe3);}
\DoxyCodeLine{2678 }
\DoxyCodeLine{2679 \textcolor{comment}{// \{A64C844A-\/E282-\/4756-\/8B80-\/250CDE04398C\}}}
\DoxyCodeLine{2680 DEFINE\_GUID(DXFILEOBJ\_FaceAdjacency, }
\DoxyCodeLine{2681 0xa64c844a, 0xe282, 0x4756, 0x8b, 0x80, 0x25, 0xc, 0xde, 0x4, 0x39, 0x8c);}
\DoxyCodeLine{2682 }
\DoxyCodeLine{2683 \textcolor{comment}{// \{6F0D123B-\/BAD2-\/4167-\/A0D0-\/80224F25FABB\}}}
\DoxyCodeLine{2684 DEFINE\_GUID(DXFILEOBJ\_SkinWeights, }
\DoxyCodeLine{2685 0x6f0d123b, 0xbad2, 0x4167, 0xa0, 0xd0, 0x80, 0x22, 0x4f, 0x25, 0xfa, 0xbb);}
\DoxyCodeLine{2686 }
\DoxyCodeLine{2687 \textcolor{comment}{// \{A3EB5D44-\/FC22-\/429d-\/9AFB-\/3221CB9719A6\}}}
\DoxyCodeLine{2688 DEFINE\_GUID(DXFILEOBJ\_Patch, }
\DoxyCodeLine{2689 0xa3eb5d44, 0xfc22, 0x429d, 0x9a, 0xfb, 0x32, 0x21, 0xcb, 0x97, 0x19, 0xa6);}
\DoxyCodeLine{2690 }
\DoxyCodeLine{2691 \textcolor{comment}{// \{D02C95CC-\/EDBA-\/4305-\/9B5D-\/1820D7704BBF\}}}
\DoxyCodeLine{2692 DEFINE\_GUID(DXFILEOBJ\_PatchMesh, }
\DoxyCodeLine{2693 0xd02c95cc, 0xedba, 0x4305, 0x9b, 0x5d, 0x18, 0x20, 0xd7, 0x70, 0x4b, 0xbf);}
\DoxyCodeLine{2694 }
\DoxyCodeLine{2695 \textcolor{comment}{// \{B9EC94E1-\/B9A6-\/4251-\/BA18-\/94893F02C0EA\}}}
\DoxyCodeLine{2696 DEFINE\_GUID(DXFILEOBJ\_PatchMesh9, }
\DoxyCodeLine{2697 0xb9ec94e1, 0xb9a6, 0x4251, 0xba, 0x18, 0x94, 0x89, 0x3f, 0x2, 0xc0, 0xea);}
\DoxyCodeLine{2698 }
\DoxyCodeLine{2699 \textcolor{comment}{// \{B6C3E656-\/EC8B-\/4b92-\/9B62-\/681659522947\}}}
\DoxyCodeLine{2700 DEFINE\_GUID(DXFILEOBJ\_PMInfo, }
\DoxyCodeLine{2701 0xb6c3e656, 0xec8b, 0x4b92, 0x9b, 0x62, 0x68, 0x16, 0x59, 0x52, 0x29, 0x47);}
\DoxyCodeLine{2702 }
\DoxyCodeLine{2703 \textcolor{comment}{// \{917E0427-\/C61E-\/4a14-\/9C64-\/AFE65F9E9844\}}}
\DoxyCodeLine{2704 DEFINE\_GUID(DXFILEOBJ\_PMAttributeRange, }
\DoxyCodeLine{2705 0x917e0427, 0xc61e, 0x4a14, 0x9c, 0x64, 0xaf, 0xe6, 0x5f, 0x9e, 0x98, 0x44);}
\DoxyCodeLine{2706 }
\DoxyCodeLine{2707 \textcolor{comment}{// \{574CCC14-\/F0B3-\/4333-\/822D-\/93E8A8A08E4C\}}}
\DoxyCodeLine{2708 DEFINE\_GUID(DXFILEOBJ\_PMVSplitRecord,}
\DoxyCodeLine{2709 0x574ccc14, 0xf0b3, 0x4333, 0x82, 0x2d, 0x93, 0xe8, 0xa8, 0xa0, 0x8e, 0x4c);}
\DoxyCodeLine{2710 }
\DoxyCodeLine{2711 \textcolor{comment}{// \{B6E70A0E-\/8EF9-\/4e83-\/94AD-\/ECC8B0C04897\}}}
\DoxyCodeLine{2712 DEFINE\_GUID(DXFILEOBJ\_FVFData, }
\DoxyCodeLine{2713 0xb6e70a0e, 0x8ef9, 0x4e83, 0x94, 0xad, 0xec, 0xc8, 0xb0, 0xc0, 0x48, 0x97);}
\DoxyCodeLine{2714 }
\DoxyCodeLine{2715 \textcolor{comment}{// \{F752461C-\/1E23-\/48f6-\/B9F8-\/8350850F336F\}}}
\DoxyCodeLine{2716 DEFINE\_GUID(DXFILEOBJ\_VertexElement, }
\DoxyCodeLine{2717 0xf752461c, 0x1e23, 0x48f6, 0xb9, 0xf8, 0x83, 0x50, 0x85, 0xf, 0x33, 0x6f);}
\DoxyCodeLine{2718 }
\DoxyCodeLine{2719 \textcolor{comment}{// \{BF22E553-\/292C-\/4781-\/9FEA-\/62BD554BDD93\}}}
\DoxyCodeLine{2720 DEFINE\_GUID(DXFILEOBJ\_DeclData, }
\DoxyCodeLine{2721 0xbf22e553, 0x292c, 0x4781, 0x9f, 0xea, 0x62, 0xbd, 0x55, 0x4b, 0xdd, 0x93);}
\DoxyCodeLine{2722 }
\DoxyCodeLine{2723 \textcolor{comment}{// \{F1CFE2B3-\/0DE3-\/4e28-\/AFA1-\/155A750A282D\}}}
\DoxyCodeLine{2724 DEFINE\_GUID(DXFILEOBJ\_EffectFloats, }
\DoxyCodeLine{2725 0xf1cfe2b3, 0xde3, 0x4e28, 0xaf, 0xa1, 0x15, 0x5a, 0x75, 0xa, 0x28, 0x2d);}
\DoxyCodeLine{2726 }
\DoxyCodeLine{2727 \textcolor{comment}{// \{D55B097E-\/BDB6-\/4c52-\/B03D-\/6051C89D0E42\}}}
\DoxyCodeLine{2728 DEFINE\_GUID(DXFILEOBJ\_EffectString, }
\DoxyCodeLine{2729 0xd55b097e, 0xbdb6, 0x4c52, 0xb0, 0x3d, 0x60, 0x51, 0xc8, 0x9d, 0xe, 0x42);}
\DoxyCodeLine{2730 }
\DoxyCodeLine{2731 \textcolor{comment}{// \{622C0ED0-\/956E-\/4da9-\/908A-\/2AF94F3CE716\}}}
\DoxyCodeLine{2732 DEFINE\_GUID(DXFILEOBJ\_EffectDWord, }
\DoxyCodeLine{2733 0x622c0ed0, 0x956e, 0x4da9, 0x90, 0x8a, 0x2a, 0xf9, 0x4f, 0x3c, 0xe7, 0x16);}
\DoxyCodeLine{2734 }
\DoxyCodeLine{2735 \textcolor{comment}{// \{3014B9A0-\/62F5-\/478c-\/9B86-\/E4AC9F4E418B\}}}
\DoxyCodeLine{2736 DEFINE\_GUID(DXFILEOBJ\_EffectParamFloats, }
\DoxyCodeLine{2737 0x3014b9a0, 0x62f5, 0x478c, 0x9b, 0x86, 0xe4, 0xac, 0x9f, 0x4e, 0x41, 0x8b);}
\DoxyCodeLine{2738 }
\DoxyCodeLine{2739 \textcolor{comment}{// \{1DBC4C88-\/94C1-\/46ee-\/9076-\/2C28818C9481\}}}
\DoxyCodeLine{2740 DEFINE\_GUID(DXFILEOBJ\_EffectParamString, }
\DoxyCodeLine{2741 0x1dbc4c88, 0x94c1, 0x46ee, 0x90, 0x76, 0x2c, 0x28, 0x81, 0x8c, 0x94, 0x81);}
\DoxyCodeLine{2742 }
\DoxyCodeLine{2743 \textcolor{comment}{// \{E13963BC-\/AE51-\/4c5d-\/B00F-\/CFA3A9D97CE5\}}}
\DoxyCodeLine{2744 DEFINE\_GUID(DXFILEOBJ\_EffectParamDWord,}
\DoxyCodeLine{2745 0xe13963bc, 0xae51, 0x4c5d, 0xb0, 0xf, 0xcf, 0xa3, 0xa9, 0xd9, 0x7c, 0xe5);}
\DoxyCodeLine{2746 }
\DoxyCodeLine{2747 \textcolor{comment}{// \{E331F7E4-\/0559-\/4cc2-\/8E99-\/1CEC1657928F\}}}
\DoxyCodeLine{2748 DEFINE\_GUID(DXFILEOBJ\_EffectInstance, }
\DoxyCodeLine{2749 0xe331f7e4, 0x559, 0x4cc2, 0x8e, 0x99, 0x1c, 0xec, 0x16, 0x57, 0x92, 0x8f);}
\DoxyCodeLine{2750 }
\DoxyCodeLine{2751 \textcolor{comment}{// \{9E415A43-\/7BA6-\/4a73-\/8743-\/B73D47E88476\}}}
\DoxyCodeLine{2752 DEFINE\_GUID(DXFILEOBJ\_AnimTicksPerSecond, }
\DoxyCodeLine{2753 0x9e415a43, 0x7ba6, 0x4a73, 0x87, 0x43, 0xb7, 0x3d, 0x47, 0xe8, 0x84, 0x76);}
\DoxyCodeLine{2754 }
\DoxyCodeLine{2755 \textcolor{comment}{// \{7F9B00B3-\/F125-\/4890-\/876E-\/1CFFBF697C4D\}}}
\DoxyCodeLine{2756 DEFINE\_GUID(DXFILEOBJ\_CompressedAnimationSet, }
\DoxyCodeLine{2757 0x7f9b00b3, 0xf125, 0x4890, 0x87, 0x6e, 0x1c, 0x42, 0xbf, 0x69, 0x7c, 0x4d);}
\DoxyCodeLine{2758 }
\DoxyCodeLine{2759 \textcolor{preprocessor}{\#pragma pack(push, 1)}}
\DoxyCodeLine{2760 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{struct___x_f_i_l_e_c_o_m_p_r_e_s_s_e_d_a_n_i_m_a_t_i_o_n_s_e_t}{\_XFILECOMPRESSEDANIMATIONSET}}}
\DoxyCodeLine{2761 \{}
\DoxyCodeLine{2762     DWORD CompressedBlockSize;}
\DoxyCodeLine{2763     FLOAT TicksPerSec;}
\DoxyCodeLine{2764     DWORD PlaybackType;}
\DoxyCodeLine{2765     DWORD BufferLength;}
\DoxyCodeLine{2766 \} \mbox{\hyperlink{struct___x_f_i_l_e_c_o_m_p_r_e_s_s_e_d_a_n_i_m_a_t_i_o_n_s_e_t}{XFILECOMPRESSEDANIMATIONSET}};}
\DoxyCodeLine{2767 \textcolor{preprocessor}{\#pragma pack(pop)}}
\DoxyCodeLine{2768 }
\DoxyCodeLine{2769 \textcolor{preprocessor}{\#define XSKINEXP\_TEMPLATES \(\backslash\)}}
\DoxyCodeLine{2770 \textcolor{preprocessor}{        "{}xof 0303txt 0032\(\backslash\)}}
\DoxyCodeLine{2771 \textcolor{preprocessor}{        template XSkinMeshHeader \(\backslash\)}}
\DoxyCodeLine{2772 \textcolor{preprocessor}{        \{ \(\backslash\)}}
\DoxyCodeLine{2773 \textcolor{preprocessor}{            <3CF169CE-\/FF7C-\/44ab-\/93C0-\/F78F62D172E2> \(\backslash\)}}
\DoxyCodeLine{2774 \textcolor{preprocessor}{            WORD nMaxSkinWeightsPerVertex; \(\backslash\)}}
\DoxyCodeLine{2775 \textcolor{preprocessor}{            WORD nMaxSkinWeightsPerFace; \(\backslash\)}}
\DoxyCodeLine{2776 \textcolor{preprocessor}{            WORD nBones; \(\backslash\)}}
\DoxyCodeLine{2777 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2778 \textcolor{preprocessor}{        template VertexDuplicationIndices \(\backslash\)}}
\DoxyCodeLine{2779 \textcolor{preprocessor}{        \{ \(\backslash\)}}
\DoxyCodeLine{2780 \textcolor{preprocessor}{            <B8D65549-\/D7C9-\/4995-\/89CF-\/53A9A8B031E3> \(\backslash\)}}
\DoxyCodeLine{2781 \textcolor{preprocessor}{            DWORD nIndices; \(\backslash\)}}
\DoxyCodeLine{2782 \textcolor{preprocessor}{            DWORD nOriginalVertices; \(\backslash\)}}
\DoxyCodeLine{2783 \textcolor{preprocessor}{            array DWORD indices[nIndices]; \(\backslash\)}}
\DoxyCodeLine{2784 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2785 \textcolor{preprocessor}{        template FaceAdjacency \(\backslash\)}}
\DoxyCodeLine{2786 \textcolor{preprocessor}{        \{ \(\backslash\)}}
\DoxyCodeLine{2787 \textcolor{preprocessor}{            <A64C844A-\/E282-\/4756-\/8B80-\/250CDE04398C> \(\backslash\)}}
\DoxyCodeLine{2788 \textcolor{preprocessor}{            DWORD nIndices; \(\backslash\)}}
\DoxyCodeLine{2789 \textcolor{preprocessor}{            array DWORD indices[nIndices]; \(\backslash\)}}
\DoxyCodeLine{2790 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2791 \textcolor{preprocessor}{        template SkinWeights \(\backslash\)}}
\DoxyCodeLine{2792 \textcolor{preprocessor}{        \{ \(\backslash\)}}
\DoxyCodeLine{2793 \textcolor{preprocessor}{            <6F0D123B-\/BAD2-\/4167-\/A0D0-\/80224F25FABB> \(\backslash\)}}
\DoxyCodeLine{2794 \textcolor{preprocessor}{            STRING transformNodeName; \(\backslash\)}}
\DoxyCodeLine{2795 \textcolor{preprocessor}{            DWORD nWeights; \(\backslash\)}}
\DoxyCodeLine{2796 \textcolor{preprocessor}{            array DWORD vertexIndices[nWeights]; \(\backslash\)}}
\DoxyCodeLine{2797 \textcolor{preprocessor}{            array float weights[nWeights]; \(\backslash\)}}
\DoxyCodeLine{2798 \textcolor{preprocessor}{            Matrix4x4 matrixOffset; \(\backslash\)}}
\DoxyCodeLine{2799 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2800 \textcolor{preprocessor}{        template Patch \(\backslash\)}}
\DoxyCodeLine{2801 \textcolor{preprocessor}{        \{ \(\backslash\)}}
\DoxyCodeLine{2802 \textcolor{preprocessor}{            <A3EB5D44-\/FC22-\/429D-\/9AFB-\/3221CB9719A6> \(\backslash\)}}
\DoxyCodeLine{2803 \textcolor{preprocessor}{            DWORD nControlIndices; \(\backslash\)}}
\DoxyCodeLine{2804 \textcolor{preprocessor}{            array DWORD controlIndices[nControlIndices]; \(\backslash\)}}
\DoxyCodeLine{2805 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2806 \textcolor{preprocessor}{        template PatchMesh \(\backslash\)}}
\DoxyCodeLine{2807 \textcolor{preprocessor}{        \{ \(\backslash\)}}
\DoxyCodeLine{2808 \textcolor{preprocessor}{            <D02C95CC-\/EDBA-\/4305-\/9B5D-\/1820D7704BBF> \(\backslash\)}}
\DoxyCodeLine{2809 \textcolor{preprocessor}{            DWORD nVertices; \(\backslash\)}}
\DoxyCodeLine{2810 \textcolor{preprocessor}{            array Vector vertices[nVertices]; \(\backslash\)}}
\DoxyCodeLine{2811 \textcolor{preprocessor}{            DWORD nPatches; \(\backslash\)}}
\DoxyCodeLine{2812 \textcolor{preprocessor}{            array Patch patches[nPatches]; \(\backslash\)}}
\DoxyCodeLine{2813 \textcolor{preprocessor}{            [ ... ] \(\backslash\)}}
\DoxyCodeLine{2814 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2815 \textcolor{preprocessor}{        template PatchMesh9 \(\backslash\)}}
\DoxyCodeLine{2816 \textcolor{preprocessor}{        \{ \(\backslash\)}}
\DoxyCodeLine{2817 \textcolor{preprocessor}{            <B9EC94E1-\/B9A6-\/4251-\/BA18-\/94893F02C0EA> \(\backslash\)}}
\DoxyCodeLine{2818 \textcolor{preprocessor}{            DWORD Type; \(\backslash\)}}
\DoxyCodeLine{2819 \textcolor{preprocessor}{            DWORD Degree; \(\backslash\)}}
\DoxyCodeLine{2820 \textcolor{preprocessor}{            DWORD Basis; \(\backslash\)}}
\DoxyCodeLine{2821 \textcolor{preprocessor}{            DWORD nVertices; \(\backslash\)}}
\DoxyCodeLine{2822 \textcolor{preprocessor}{            array Vector vertices[nVertices]; \(\backslash\)}}
\DoxyCodeLine{2823 \textcolor{preprocessor}{            DWORD nPatches; \(\backslash\)}}
\DoxyCodeLine{2824 \textcolor{preprocessor}{            array Patch patches[nPatches]; \(\backslash\)}}
\DoxyCodeLine{2825 \textcolor{preprocessor}{            [ ... ] \(\backslash\)}}
\DoxyCodeLine{2826 \textcolor{preprocessor}{        \} "{}} \(\backslash\)}
\DoxyCodeLine{2827         "{}template EffectFloats \(\backslash\)}
\DoxyCodeLine{2828         \{ \(\backslash\)}
\DoxyCodeLine{2829             <F1CFE2B3-\/0DE3-\/4e28-\/AFA1-\/155A750A282D> \(\backslash\)}
\DoxyCodeLine{2830             DWORD nFloats; \(\backslash\)}
\DoxyCodeLine{2831             array float Floats[nFloats]; \(\backslash\)}
\DoxyCodeLine{2832         \} \(\backslash\)}
\DoxyCodeLine{2833         template EffectString \(\backslash\)}
\DoxyCodeLine{2834         \{ \(\backslash\)}
\DoxyCodeLine{2835             <D55B097E-\/BDB6-\/4c52-\/B03D-\/6051C89D0E42> \(\backslash\)}
\DoxyCodeLine{2836             STRING Value; \(\backslash\)}
\DoxyCodeLine{2837         \} \(\backslash\)}
\DoxyCodeLine{2838         template EffectDWord \(\backslash\)}
\DoxyCodeLine{2839         \{ \(\backslash\)}
\DoxyCodeLine{2840             <622C0ED0-\/956E-\/4da9-\/908A-\/2AF94F3CE716> \(\backslash\)}
\DoxyCodeLine{2841             DWORD Value; \(\backslash\)}
\DoxyCodeLine{2842         \} "{} \(\backslash\)}
\DoxyCodeLine{2843         "{}template EffectParamFloats \(\backslash\)}
\DoxyCodeLine{2844         \{ \(\backslash\)}
\DoxyCodeLine{2845             <3014B9A0-\/62F5-\/478c-\/9B86-\/E4AC9F4E418B> \(\backslash\)}
\DoxyCodeLine{2846             STRING ParamName; \(\backslash\)}
\DoxyCodeLine{2847             DWORD nFloats; \(\backslash\)}
\DoxyCodeLine{2848             array float Floats[nFloats]; \(\backslash\)}
\DoxyCodeLine{2849         \} "{} \(\backslash\)}
\DoxyCodeLine{2850         "{}template EffectParamString \(\backslash\)}
\DoxyCodeLine{2851         \{ \(\backslash\)}
\DoxyCodeLine{2852             <1DBC4C88-\/94C1-\/46ee-\/9076-\/2C28818C9481> \(\backslash\)}
\DoxyCodeLine{2853             STRING ParamName; \(\backslash\)}
\DoxyCodeLine{2854             STRING Value; \(\backslash\)}
\DoxyCodeLine{2855         \} \(\backslash\)}
\DoxyCodeLine{2856         template EffectParamDWord \(\backslash\)}
\DoxyCodeLine{2857         \{ \(\backslash\)}
\DoxyCodeLine{2858             <E13963BC-\/AE51-\/4c5d-\/B00F-\/CFA3A9D97CE5> \(\backslash\)}
\DoxyCodeLine{2859             STRING ParamName; \(\backslash\)}
\DoxyCodeLine{2860             DWORD Value; \(\backslash\)}
\DoxyCodeLine{2861         \} \(\backslash\)}
\DoxyCodeLine{2862         template EffectInstance \(\backslash\)}
\DoxyCodeLine{2863         \{ \(\backslash\)}
\DoxyCodeLine{2864             <E331F7E4-\/0559-\/4cc2-\/8E99-\/1CEC1657928F> \(\backslash\)}
\DoxyCodeLine{2865             STRING EffectFilename; \(\backslash\)}
\DoxyCodeLine{2866             [ ... ] \(\backslash\)}
\DoxyCodeLine{2867         \} "{} \(\backslash\)}
\DoxyCodeLine{2868         "{}template AnimTicksPerSecond \(\backslash\)}
\DoxyCodeLine{2869         \{ \(\backslash\)}
\DoxyCodeLine{2870             <9E415A43-\/7BA6-\/4a73-\/8743-\/B73D47E88476> \(\backslash\)}
\DoxyCodeLine{2871             DWORD AnimTicksPerSecond; \(\backslash\)}
\DoxyCodeLine{2872         \} \(\backslash\)}
\DoxyCodeLine{2873         template CompressedAnimationSet \(\backslash\)}
\DoxyCodeLine{2874         \{ \(\backslash\)}
\DoxyCodeLine{2875             <7F9B00B3-\/F125-\/4890-\/876E-\/1C42BF697C4D> \(\backslash\)}
\DoxyCodeLine{2876             DWORD CompressedBlockSize; \(\backslash\)}
\DoxyCodeLine{2877             FLOAT TicksPerSec; \(\backslash\)}
\DoxyCodeLine{2878             DWORD PlaybackType; \(\backslash\)}
\DoxyCodeLine{2879             DWORD BufferLength; \(\backslash\)}
\DoxyCodeLine{2880             array DWORD CompressedData[BufferLength]; \(\backslash\)}
\DoxyCodeLine{2881         \} "{}}
\DoxyCodeLine{2882 }
\DoxyCodeLine{2883 \textcolor{preprocessor}{\#define XEXTENSIONS\_TEMPLATES \(\backslash\)}}
\DoxyCodeLine{2884 \textcolor{preprocessor}{        "{}xof 0303txt 0032\(\backslash\)}}
\DoxyCodeLine{2885 \textcolor{preprocessor}{        template FVFData \(\backslash\)}}
\DoxyCodeLine{2886 \textcolor{preprocessor}{        \{ \(\backslash\)}}
\DoxyCodeLine{2887 \textcolor{preprocessor}{            <B6E70A0E-\/8EF9-\/4e83-\/94AD-\/ECC8B0C04897> \(\backslash\)}}
\DoxyCodeLine{2888 \textcolor{preprocessor}{            DWORD dwFVF; \(\backslash\)}}
\DoxyCodeLine{2889 \textcolor{preprocessor}{            DWORD nDWords; \(\backslash\)}}
\DoxyCodeLine{2890 \textcolor{preprocessor}{            array DWORD data[nDWords]; \(\backslash\)}}
\DoxyCodeLine{2891 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2892 \textcolor{preprocessor}{        template VertexElement \(\backslash\)}}
\DoxyCodeLine{2893 \textcolor{preprocessor}{        \{ \(\backslash\)}}
\DoxyCodeLine{2894 \textcolor{preprocessor}{            <F752461C-\/1E23-\/48f6-\/B9F8-\/8350850F336F> \(\backslash\)}}
\DoxyCodeLine{2895 \textcolor{preprocessor}{            DWORD Type; \(\backslash\)}}
\DoxyCodeLine{2896 \textcolor{preprocessor}{            DWORD Method; \(\backslash\)}}
\DoxyCodeLine{2897 \textcolor{preprocessor}{            DWORD Usage; \(\backslash\)}}
\DoxyCodeLine{2898 \textcolor{preprocessor}{            DWORD UsageIndex; \(\backslash\)}}
\DoxyCodeLine{2899 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2900 \textcolor{preprocessor}{        template DeclData \(\backslash\)}}
\DoxyCodeLine{2901 \textcolor{preprocessor}{        \{ \(\backslash\)}}
\DoxyCodeLine{2902 \textcolor{preprocessor}{            <BF22E553-\/292C-\/4781-\/9FEA-\/62BD554BDD93> \(\backslash\)}}
\DoxyCodeLine{2903 \textcolor{preprocessor}{            DWORD nElements; \(\backslash\)}}
\DoxyCodeLine{2904 \textcolor{preprocessor}{            array VertexElement Elements[nElements]; \(\backslash\)}}
\DoxyCodeLine{2905 \textcolor{preprocessor}{            DWORD nDWords; \(\backslash\)}}
\DoxyCodeLine{2906 \textcolor{preprocessor}{            array DWORD data[nDWords]; \(\backslash\)}}
\DoxyCodeLine{2907 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2908 \textcolor{preprocessor}{        template PMAttributeRange \(\backslash\)}}
\DoxyCodeLine{2909 \textcolor{preprocessor}{        \{ \(\backslash\)}}
\DoxyCodeLine{2910 \textcolor{preprocessor}{            <917E0427-\/C61E-\/4a14-\/9C64-\/AFE65F9E9844> \(\backslash\)}}
\DoxyCodeLine{2911 \textcolor{preprocessor}{            DWORD iFaceOffset; \(\backslash\)}}
\DoxyCodeLine{2912 \textcolor{preprocessor}{            DWORD nFacesMin; \(\backslash\)}}
\DoxyCodeLine{2913 \textcolor{preprocessor}{            DWORD nFacesMax; \(\backslash\)}}
\DoxyCodeLine{2914 \textcolor{preprocessor}{            DWORD iVertexOffset; \(\backslash\)}}
\DoxyCodeLine{2915 \textcolor{preprocessor}{            DWORD nVerticesMin; \(\backslash\)}}
\DoxyCodeLine{2916 \textcolor{preprocessor}{            DWORD nVerticesMax; \(\backslash\)}}
\DoxyCodeLine{2917 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2918 \textcolor{preprocessor}{        template PMVSplitRecord \(\backslash\)}}
\DoxyCodeLine{2919 \textcolor{preprocessor}{        \{ \(\backslash\)}}
\DoxyCodeLine{2920 \textcolor{preprocessor}{            <574CCC14-\/F0B3-\/4333-\/822D-\/93E8A8A08E4C> \(\backslash\)}}
\DoxyCodeLine{2921 \textcolor{preprocessor}{            DWORD iFaceCLW; \(\backslash\)}}
\DoxyCodeLine{2922 \textcolor{preprocessor}{            DWORD iVlrOffset; \(\backslash\)}}
\DoxyCodeLine{2923 \textcolor{preprocessor}{            DWORD iCode; \(\backslash\)}}
\DoxyCodeLine{2924 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2925 \textcolor{preprocessor}{        template PMInfo \(\backslash\)}}
\DoxyCodeLine{2926 \textcolor{preprocessor}{        \{ \(\backslash\)}}
\DoxyCodeLine{2927 \textcolor{preprocessor}{            <B6C3E656-\/EC8B-\/4b92-\/9B62-\/681659522947> \(\backslash\)}}
\DoxyCodeLine{2928 \textcolor{preprocessor}{            DWORD nAttributes; \(\backslash\)}}
\DoxyCodeLine{2929 \textcolor{preprocessor}{            array PMAttributeRange attributeRanges[nAttributes]; \(\backslash\)}}
\DoxyCodeLine{2930 \textcolor{preprocessor}{            DWORD nMaxValence; \(\backslash\)}}
\DoxyCodeLine{2931 \textcolor{preprocessor}{            DWORD nMinLogicalVertices; \(\backslash\)}}
\DoxyCodeLine{2932 \textcolor{preprocessor}{            DWORD nMaxLogicalVertices; \(\backslash\)}}
\DoxyCodeLine{2933 \textcolor{preprocessor}{            DWORD nVSplits; \(\backslash\)}}
\DoxyCodeLine{2934 \textcolor{preprocessor}{            array PMVSplitRecord splitRecords[nVSplits]; \(\backslash\)}}
\DoxyCodeLine{2935 \textcolor{preprocessor}{            DWORD nAttributeMispredicts; \(\backslash\)}}
\DoxyCodeLine{2936 \textcolor{preprocessor}{            array DWORD attributeMispredicts[nAttributeMispredicts]; \(\backslash\)}}
\DoxyCodeLine{2937 \textcolor{preprocessor}{        \} "{}}}
\DoxyCodeLine{2938         }
\DoxyCodeLine{2939 \textcolor{preprocessor}{\#endif }\textcolor{comment}{//\_\_D3DX9MESH\_H\_\_}}
\DoxyCodeLine{2940 }
\DoxyCodeLine{2941 }

\end{DoxyCode}
