\hypertarget{strsafe_8h_source}{}\doxysection{strsafe.\+h}
\label{strsafe_8h_source}\index{src/lib/dx/Include/strsafe.h@{src/lib/dx/Include/strsafe.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/******************************************************************}}
\DoxyCodeLine{2 \textcolor{comment}{*                                                                 *}}
\DoxyCodeLine{3 \textcolor{comment}{*  strsafe.h -\/-\/ This module defines safer C library string        *}}
\DoxyCodeLine{4 \textcolor{comment}{*               routine replacements. These are meant to make C   *}}
\DoxyCodeLine{5 \textcolor{comment}{*               a bit more safe in reference to security and      *}}
\DoxyCodeLine{6 \textcolor{comment}{*               robustness                                        *}}
\DoxyCodeLine{7 \textcolor{comment}{*                                                                 *}}
\DoxyCodeLine{8 \textcolor{comment}{*  Copyright (c) Microsoft Corp.  All rights reserved.            *}}
\DoxyCodeLine{9 \textcolor{comment}{*                                                                 *}}
\DoxyCodeLine{10 \textcolor{comment}{******************************************************************/}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#ifndef \_STRSAFE\_H\_INCLUDED\_}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#define \_STRSAFE\_H\_INCLUDED\_}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{14 }
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <stdio.h>}      \textcolor{comment}{// for \_vsnprintf, \_vsnwprintf, getc, getwc}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <string.h>}     \textcolor{comment}{// for memset}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <stdarg.h>}     \textcolor{comment}{// for va\_start, etc.}}
\DoxyCodeLine{18 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 \textcolor{preprocessor}{\#ifndef \_SIZE\_T\_DEFINED}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#ifdef  \_WIN64}}
\DoxyCodeLine{22 \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \_\_int64    size\_t;}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{24 \textcolor{keyword}{typedef} \_\_w64 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}  size\_t;}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !\_WIN64}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#define \_SIZE\_T\_DEFINED}}
\DoxyCodeLine{27 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !\_SIZE\_T\_DEFINED}}
\DoxyCodeLine{28 }
\DoxyCodeLine{29 \textcolor{preprocessor}{\#if !defined(\_WCHAR\_T\_DEFINED) \&\& !defined(\_NATIVE\_WCHAR\_T\_DEFINED)}}
\DoxyCodeLine{30 \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} wchar\_t;}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#define \_WCHAR\_T\_DEFINED}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{33 }
\DoxyCodeLine{34 \textcolor{preprocessor}{\#ifndef \_HRESULT\_DEFINED}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#define \_HRESULT\_DEFINED}}
\DoxyCodeLine{36 \textcolor{keyword}{typedef} \textcolor{keywordtype}{long} HRESULT;}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !\_HRESULT\_DEFINED}}
\DoxyCodeLine{38 }
\DoxyCodeLine{39 \textcolor{preprocessor}{\#ifndef SUCCEEDED}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#define SUCCEEDED(hr)  ((HRESULT)(hr) >= 0)}}
\DoxyCodeLine{41 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{42 }
\DoxyCodeLine{43 \textcolor{preprocessor}{\#ifndef FAILED}}
\DoxyCodeLine{44 \textcolor{preprocessor}{\#define FAILED(hr)  ((HRESULT)(hr) < 0)}}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{46 }
\DoxyCodeLine{47 \textcolor{preprocessor}{\#ifndef S\_OK}}
\DoxyCodeLine{48 \textcolor{preprocessor}{\#define S\_OK  ((HRESULT)0x00000000L)}}
\DoxyCodeLine{49 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{50 }
\DoxyCodeLine{51 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{52 \textcolor{preprocessor}{\#define \_STRSAFE\_EXTERN\_C    extern "{}C"{}}}
\DoxyCodeLine{53 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{54 \textcolor{preprocessor}{\#define \_STRSAFE\_EXTERN\_C    extern}}
\DoxyCodeLine{55 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{56 }
\DoxyCodeLine{57 \textcolor{comment}{// If you do not want to use these functions inline (and instead want to link w/ strsafe.lib), then}}
\DoxyCodeLine{58 \textcolor{comment}{// \#define STRSAFE\_LIB before including this header file.}}
\DoxyCodeLine{59 \textcolor{preprocessor}{\#if defined(STRSAFE\_LIB)}}
\DoxyCodeLine{60 \textcolor{preprocessor}{\#define STRSAFEAPI  \_STRSAFE\_EXTERN\_C HRESULT \_\_stdcall}}
\DoxyCodeLine{61 \textcolor{preprocessor}{\#pragma comment(lib, "{}strsafe.lib"{}})}
\DoxyCodeLine{62 \textcolor{preprocessor}{\#elif defined(STRSAFE\_LIB\_IMPL)}}
\DoxyCodeLine{63 \textcolor{preprocessor}{\#define STRSAFEAPI  \_STRSAFE\_EXTERN\_C HRESULT \_\_stdcall}}
\DoxyCodeLine{64 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{65 \textcolor{preprocessor}{\#define STRSAFEAPI  \_\_inline HRESULT \_\_stdcall}}
\DoxyCodeLine{66 \textcolor{preprocessor}{\#define STRSAFE\_INLINE}}
\DoxyCodeLine{67 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{68 }
\DoxyCodeLine{69 \textcolor{comment}{// Some functions always run inline because they use stdin and we want to avoid building multiple}}
\DoxyCodeLine{70 \textcolor{comment}{// versions of strsafe lib depending on if you use msvcrt, libcmt, etc.}}
\DoxyCodeLine{71 \textcolor{preprocessor}{\#define STRSAFE\_INLINE\_API  \_\_inline HRESULT \_\_stdcall}}
\DoxyCodeLine{72 }
\DoxyCodeLine{73 \textcolor{comment}{// The user can request no "{}Cb"{} or no "{}Cch"{} fuctions, but not both!}}
\DoxyCodeLine{74 \textcolor{preprocessor}{\#if defined(STRSAFE\_NO\_CB\_FUNCTIONS) \&\& defined(STRSAFE\_NO\_CCH\_FUNCTIONS)}}
\DoxyCodeLine{75 \textcolor{preprocessor}{\#error cannot specify both STRSAFE\_NO\_CB\_FUNCTIONS and STRSAFE\_NO\_CCH\_FUNCTIONS !!}}
\DoxyCodeLine{76 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{77 }
\DoxyCodeLine{78 \textcolor{comment}{// This should only be defined when we are building strsafe.lib}}
\DoxyCodeLine{79 \textcolor{preprocessor}{\#ifdef STRSAFE\_LIB\_IMPL}}
\DoxyCodeLine{80 \textcolor{preprocessor}{\#define STRSAFE\_INLINE}}
\DoxyCodeLine{81 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{82 }
\DoxyCodeLine{83 }
\DoxyCodeLine{84 \textcolor{comment}{// If both strsafe.h and ntstrsafe.h are included, only use definitions from one.}}
\DoxyCodeLine{85 \textcolor{preprocessor}{\#ifndef \_NTSTRSAFE\_H\_INCLUDED\_}}
\DoxyCodeLine{86 }
\DoxyCodeLine{87 \textcolor{preprocessor}{\#define STRSAFE\_MAX\_CCH  2147483647 }\textcolor{comment}{// max \# of characters we support (same as INT\_MAX)}}
\DoxyCodeLine{88 }
\DoxyCodeLine{89 \textcolor{comment}{// Flags for controling the Ex functions}}
\DoxyCodeLine{90 \textcolor{comment}{//}}
\DoxyCodeLine{91 \textcolor{comment}{//      STRSAFE\_FILL\_BYTE(0xFF)     0x000000FF  // bottom byte specifies fill pattern}}
\DoxyCodeLine{92 \textcolor{preprocessor}{\#define STRSAFE\_IGNORE\_NULLS        0x00000100  }\textcolor{comment}{// treat null as TEXT("{}"{}) -\/-\/ don't fault on NULL buffers}}
\DoxyCodeLine{93 \textcolor{preprocessor}{\#define STRSAFE\_FILL\_BEHIND\_NULL    0x00000200  }\textcolor{comment}{// fill in extra space behind the null terminator}}
\DoxyCodeLine{94 \textcolor{preprocessor}{\#define STRSAFE\_FILL\_ON\_FAILURE     0x00000400  }\textcolor{comment}{// on failure, overwrite pszDest with fill pattern and null terminate it}}
\DoxyCodeLine{95 \textcolor{preprocessor}{\#define STRSAFE\_NULL\_ON\_FAILURE     0x00000800  }\textcolor{comment}{// on failure, set *pszDest = TEXT('\(\backslash\)0')}}
\DoxyCodeLine{96 \textcolor{preprocessor}{\#define STRSAFE\_NO\_TRUNCATION       0x00001000  }\textcolor{comment}{// instead of returning a truncated result, copy/append nothing to pszDest and null terminate it}}
\DoxyCodeLine{97 }
\DoxyCodeLine{98 \textcolor{preprocessor}{\#define STRSAFE\_VALID\_FLAGS         (0x000000FF | STRSAFE\_IGNORE\_NULLS | STRSAFE\_FILL\_BEHIND\_NULL | STRSAFE\_FILL\_ON\_FAILURE | STRSAFE\_NULL\_ON\_FAILURE | STRSAFE\_NO\_TRUNCATION)}}
\DoxyCodeLine{99 }
\DoxyCodeLine{100 \textcolor{comment}{// helper macro to set the fill character and specify buffer filling}}
\DoxyCodeLine{101 \textcolor{preprocessor}{\#define STRSAFE\_FILL\_BYTE(x)        ((unsigned long)((x \& 0x000000FF) | STRSAFE\_FILL\_BEHIND\_NULL))}}
\DoxyCodeLine{102 \textcolor{preprocessor}{\#define STRSAFE\_FAILURE\_BYTE(x)     ((unsigned long)((x \& 0x000000FF) | STRSAFE\_FILL\_ON\_FAILURE))}}
\DoxyCodeLine{103 }
\DoxyCodeLine{104 \textcolor{preprocessor}{\#define STRSAFE\_GET\_FILL\_PATTERN(dwFlags)  ((int)(dwFlags \& 0x000000FF))}}
\DoxyCodeLine{105 }
\DoxyCodeLine{106 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_NTSTRSAFE\_H\_INCLUDED\_}}
\DoxyCodeLine{107 }
\DoxyCodeLine{108 \textcolor{comment}{// STRSAFE error return codes}}
\DoxyCodeLine{109 \textcolor{comment}{//}}
\DoxyCodeLine{110 \textcolor{preprocessor}{\#define STRSAFE\_E\_INSUFFICIENT\_BUFFER       ((HRESULT)0x8007007AL)  }\textcolor{comment}{// 0x7A = 122L = ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{111 \textcolor{preprocessor}{\#define STRSAFE\_E\_INVALID\_PARAMETER         ((HRESULT)0x80070057L)  }\textcolor{comment}{// 0x57 =  87L = ERROR\_INVALID\_PARAMETER}}
\DoxyCodeLine{112 \textcolor{preprocessor}{\#define STRSAFE\_E\_END\_OF\_FILE               ((HRESULT)0x80070026L)  }\textcolor{comment}{// 0x26 =  38L = ERROR\_HANDLE\_EOF}}
\DoxyCodeLine{113 }
\DoxyCodeLine{114 \textcolor{comment}{// prototypes for the worker functions}}
\DoxyCodeLine{115 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{116 STRSAFEAPI StringCopyWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc);}
\DoxyCodeLine{117 STRSAFEAPI StringCopyWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc);}
\DoxyCodeLine{118 STRSAFEAPI StringCopyExWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{119 STRSAFEAPI StringCopyExWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{120 STRSAFEAPI StringCopyNWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cchSrc);}
\DoxyCodeLine{121 STRSAFEAPI StringCopyNWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cchSrc);}
\DoxyCodeLine{122 STRSAFEAPI StringCopyNExWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cchSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{123 STRSAFEAPI StringCopyNExWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cchSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{124 STRSAFEAPI StringCatWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc);}
\DoxyCodeLine{125 STRSAFEAPI StringCatWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc);}
\DoxyCodeLine{126 STRSAFEAPI StringCatExWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{127 STRSAFEAPI StringCatExWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{128 STRSAFEAPI StringCatNWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cchMaxAppend);}
\DoxyCodeLine{129 STRSAFEAPI StringCatNWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cchMaxAppend);}
\DoxyCodeLine{130 STRSAFEAPI StringCatNExWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cchMaxAppend, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{131 STRSAFEAPI StringCatNExWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cchMaxAppend, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{132 STRSAFEAPI StringVPrintfWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, va\_list argList);}
\DoxyCodeLine{133 STRSAFEAPI StringVPrintfWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, va\_list argList);}
\DoxyCodeLine{134 STRSAFEAPI StringVPrintfExWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, va\_list argList);}
\DoxyCodeLine{135 STRSAFEAPI StringVPrintfExWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, va\_list argList);}
\DoxyCodeLine{136 STRSAFEAPI StringLengthWorkerA(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* psz, \textcolor{keywordtype}{size\_t} cchMax, \textcolor{keywordtype}{size\_t}* pcch);}
\DoxyCodeLine{137 STRSAFEAPI StringLengthWorkerW(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* psz, \textcolor{keywordtype}{size\_t} cchMax, \textcolor{keywordtype}{size\_t}* pcch);}
\DoxyCodeLine{138 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{139 }
\DoxyCodeLine{140 \textcolor{preprocessor}{\#ifndef STRSAFE\_LIB\_IMPL}}
\DoxyCodeLine{141 \textcolor{comment}{// these functions are always inline}}
\DoxyCodeLine{142 STRSAFE\_INLINE\_API StringGetsExWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{143 STRSAFE\_INLINE\_API StringGetsExWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{144 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{145 }
\DoxyCodeLine{146 \textcolor{preprocessor}{\#ifdef \_NTSTRSAFE\_H\_INCLUDED\_}}
\DoxyCodeLine{147 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{148 \textcolor{preprocessor}{\#pragma warning(disable : 4995)}}
\DoxyCodeLine{149 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_NTSTRSAFE\_H\_INCLUDED\_}}
\DoxyCodeLine{150 }
\DoxyCodeLine{151 }
\DoxyCodeLine{152 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{153 \textcolor{comment}{/*++}}
\DoxyCodeLine{154 \textcolor{comment}{}}
\DoxyCodeLine{155 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{156 \textcolor{comment}{StringCchCopy(}}
\DoxyCodeLine{157 \textcolor{comment}{    OUT LPTSTR  pszDest,}}
\DoxyCodeLine{158 \textcolor{comment}{    IN  size\_t  cchDest,}}
\DoxyCodeLine{159 \textcolor{comment}{    IN  LPCTSTR pszSrc}}
\DoxyCodeLine{160 \textcolor{comment}{    );}}
\DoxyCodeLine{161 \textcolor{comment}{}}
\DoxyCodeLine{162 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{163 \textcolor{comment}{}}
\DoxyCodeLine{164 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strcpy'.}}
\DoxyCodeLine{165 \textcolor{comment}{    The size of the destination buffer (in characters) is a parameter and}}
\DoxyCodeLine{166 \textcolor{comment}{    this function will not write past the end of this buffer and it will}}
\DoxyCodeLine{167 \textcolor{comment}{    ALWAYS null terminate the destination buffer (unless it is zero length).}}
\DoxyCodeLine{168 \textcolor{comment}{}}
\DoxyCodeLine{169 \textcolor{comment}{    This routine is not a replacement for strncpy.  That function will pad the}}
\DoxyCodeLine{170 \textcolor{comment}{    destination string with extra null termination characters if the count is}}
\DoxyCodeLine{171 \textcolor{comment}{    greater than the length of the source string, and it will fail to null}}
\DoxyCodeLine{172 \textcolor{comment}{    terminate the destination string if the source string length is greater}}
\DoxyCodeLine{173 \textcolor{comment}{    than or equal to the count. You can not blindly use this instead of strncpy:}}
\DoxyCodeLine{174 \textcolor{comment}{    it is common for code to use it to "{}patch"{} strings and you would introduce}}
\DoxyCodeLine{175 \textcolor{comment}{    errors if the code started null terminating in the middle of the string.}}
\DoxyCodeLine{176 \textcolor{comment}{}}
\DoxyCodeLine{177 \textcolor{comment}{    This function returns a hresult, and not a pointer.  It returns}}
\DoxyCodeLine{178 \textcolor{comment}{    S\_OK if the string was copied without truncation and null terminated,}}
\DoxyCodeLine{179 \textcolor{comment}{    otherwise it will return a failure code. In failure cases as much of}}
\DoxyCodeLine{180 \textcolor{comment}{    pszSrc will be copied to pszDest as possible, and pszDest will be null}}
\DoxyCodeLine{181 \textcolor{comment}{    terminated.}}
\DoxyCodeLine{182 \textcolor{comment}{}}
\DoxyCodeLine{183 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{184 \textcolor{comment}{}}
\DoxyCodeLine{185 \textcolor{comment}{    pszDest        -\/   destination string}}
\DoxyCodeLine{186 \textcolor{comment}{}}
\DoxyCodeLine{187 \textcolor{comment}{    cchDest        -\/   size of destination buffer in characters.}}
\DoxyCodeLine{188 \textcolor{comment}{                       length must be = (\_tcslen(src) + 1) to hold all of the}}
\DoxyCodeLine{189 \textcolor{comment}{                       source including the null terminator}}
\DoxyCodeLine{190 \textcolor{comment}{}}
\DoxyCodeLine{191 \textcolor{comment}{    pszSrc         -\/   source string which must be null terminated}}
\DoxyCodeLine{192 \textcolor{comment}{}}
\DoxyCodeLine{193 \textcolor{comment}{Notes:}}
\DoxyCodeLine{194 \textcolor{comment}{    Behavior is undefined if source and destination strings overlap.}}
\DoxyCodeLine{195 \textcolor{comment}{}}
\DoxyCodeLine{196 \textcolor{comment}{    pszDest and pszSrc should not be NULL. See StringCchCopyEx if you require}}
\DoxyCodeLine{197 \textcolor{comment}{    the handling of NULL values.}}
\DoxyCodeLine{198 \textcolor{comment}{}}
\DoxyCodeLine{199 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{200 \textcolor{comment}{}}
\DoxyCodeLine{201 \textcolor{comment}{    S\_OK           -\/   if there was source data and it was all copied and the}}
\DoxyCodeLine{202 \textcolor{comment}{                       resultant dest string was null terminated}}
\DoxyCodeLine{203 \textcolor{comment}{}}
\DoxyCodeLine{204 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{205 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{206 \textcolor{comment}{}}
\DoxyCodeLine{207 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{208 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{209 \textcolor{comment}{                   -\/   this return value is an indication that the copy}}
\DoxyCodeLine{210 \textcolor{comment}{                       operation failed due to insufficient space. When this}}
\DoxyCodeLine{211 \textcolor{comment}{                       error occurs, the destination buffer is modified to}}
\DoxyCodeLine{212 \textcolor{comment}{                       contain a truncated version of the ideal result and is}}
\DoxyCodeLine{213 \textcolor{comment}{                       null terminated. This is useful for situations where}}
\DoxyCodeLine{214 \textcolor{comment}{                       truncation is ok}}
\DoxyCodeLine{215 \textcolor{comment}{}}
\DoxyCodeLine{216 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{217 \textcolor{comment}{    return value of this function.}}
\DoxyCodeLine{218 \textcolor{comment}{}}
\DoxyCodeLine{219 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{220 }
\DoxyCodeLine{221 STRSAFEAPI StringCchCopyA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc);}
\DoxyCodeLine{222 STRSAFEAPI StringCchCopyW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc);}
\DoxyCodeLine{223 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{224 \textcolor{preprocessor}{\#define StringCchCopy  StringCchCopyW}}
\DoxyCodeLine{225 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{226 \textcolor{preprocessor}{\#define StringCchCopy  StringCchCopyA}}
\DoxyCodeLine{227 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{228 }
\DoxyCodeLine{229 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{230 STRSAFEAPI StringCchCopyA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc)}
\DoxyCodeLine{231 \{}
\DoxyCodeLine{232     HRESULT hr;}
\DoxyCodeLine{233 }
\DoxyCodeLine{234     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{235     \{}
\DoxyCodeLine{236         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{237     \}}
\DoxyCodeLine{238     \textcolor{keywordflow}{else}}
\DoxyCodeLine{239     \{}
\DoxyCodeLine{240         hr = StringCopyWorkerA(pszDest, cchDest, pszSrc);}
\DoxyCodeLine{241     \}}
\DoxyCodeLine{242 }
\DoxyCodeLine{243     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{244 \}}
\DoxyCodeLine{245 }
\DoxyCodeLine{246 STRSAFEAPI StringCchCopyW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc)}
\DoxyCodeLine{247 \{}
\DoxyCodeLine{248     HRESULT hr;}
\DoxyCodeLine{249 }
\DoxyCodeLine{250     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{251     \{}
\DoxyCodeLine{252         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{253     \}}
\DoxyCodeLine{254     \textcolor{keywordflow}{else}}
\DoxyCodeLine{255     \{}
\DoxyCodeLine{256         hr = StringCopyWorkerW(pszDest, cchDest, pszSrc);}
\DoxyCodeLine{257     \}}
\DoxyCodeLine{258 }
\DoxyCodeLine{259     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{260 \}}
\DoxyCodeLine{261 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{262 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{263 }
\DoxyCodeLine{264 }
\DoxyCodeLine{265 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{266 \textcolor{comment}{/*++}}
\DoxyCodeLine{267 \textcolor{comment}{}}
\DoxyCodeLine{268 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{269 \textcolor{comment}{StringCbCopy(}}
\DoxyCodeLine{270 \textcolor{comment}{    OUT LPTSTR pszDest,}}
\DoxyCodeLine{271 \textcolor{comment}{    IN  size\_t cbDest,}}
\DoxyCodeLine{272 \textcolor{comment}{    IN  LPCTSTR pszSrc}}
\DoxyCodeLine{273 \textcolor{comment}{    );}}
\DoxyCodeLine{274 \textcolor{comment}{}}
\DoxyCodeLine{275 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{276 \textcolor{comment}{}}
\DoxyCodeLine{277 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strcpy'.}}
\DoxyCodeLine{278 \textcolor{comment}{    The size of the destination buffer (in bytes) is a parameter and this}}
\DoxyCodeLine{279 \textcolor{comment}{    function will not write past the end of this buffer and it will ALWAYS}}
\DoxyCodeLine{280 \textcolor{comment}{    null terminate the destination buffer (unless it is zero length).}}
\DoxyCodeLine{281 \textcolor{comment}{}}
\DoxyCodeLine{282 \textcolor{comment}{    This routine is not a replacement for strncpy.  That function will pad the}}
\DoxyCodeLine{283 \textcolor{comment}{    destination string with extra null termination characters if the count is}}
\DoxyCodeLine{284 \textcolor{comment}{    greater than the length of the source string, and it will fail to null}}
\DoxyCodeLine{285 \textcolor{comment}{    terminate the destination string if the source string length is greater}}
\DoxyCodeLine{286 \textcolor{comment}{    than or equal to the count. You can not blindly use this instead of strncpy:}}
\DoxyCodeLine{287 \textcolor{comment}{    it is common for code to use it to "{}patch"{} strings and you would introduce}}
\DoxyCodeLine{288 \textcolor{comment}{    errors if the code started null terminating in the middle of the string.}}
\DoxyCodeLine{289 \textcolor{comment}{}}
\DoxyCodeLine{290 \textcolor{comment}{    This function returns a hresult, and not a pointer.  It returns}}
\DoxyCodeLine{291 \textcolor{comment}{    S\_OK if the string was copied without truncation and null terminated,}}
\DoxyCodeLine{292 \textcolor{comment}{    otherwise it will return a failure code. In failure cases as much of pszSrc}}
\DoxyCodeLine{293 \textcolor{comment}{    will be copied to pszDest as possible, and pszDest will be null terminated.}}
\DoxyCodeLine{294 \textcolor{comment}{}}
\DoxyCodeLine{295 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{296 \textcolor{comment}{}}
\DoxyCodeLine{297 \textcolor{comment}{    pszDest        -\/   destination string}}
\DoxyCodeLine{298 \textcolor{comment}{}}
\DoxyCodeLine{299 \textcolor{comment}{    cbDest         -\/   size of destination buffer in bytes.}}
\DoxyCodeLine{300 \textcolor{comment}{                       length must be = ((\_tcslen(src) + 1) * sizeof(TCHAR)) to}}
\DoxyCodeLine{301 \textcolor{comment}{                       hold all of the source including the null terminator}}
\DoxyCodeLine{302 \textcolor{comment}{}}
\DoxyCodeLine{303 \textcolor{comment}{    pszSrc         -\/   source string which must be null terminated}}
\DoxyCodeLine{304 \textcolor{comment}{}}
\DoxyCodeLine{305 \textcolor{comment}{Notes:}}
\DoxyCodeLine{306 \textcolor{comment}{    Behavior is undefined if source and destination strings overlap.}}
\DoxyCodeLine{307 \textcolor{comment}{}}
\DoxyCodeLine{308 \textcolor{comment}{    pszDest and pszSrc should not be NULL.  See StringCbCopyEx if you require}}
\DoxyCodeLine{309 \textcolor{comment}{    the handling of NULL values.}}
\DoxyCodeLine{310 \textcolor{comment}{}}
\DoxyCodeLine{311 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{312 \textcolor{comment}{}}
\DoxyCodeLine{313 \textcolor{comment}{    S\_OK           -\/   if there was source data and it was all copied and the}}
\DoxyCodeLine{314 \textcolor{comment}{                       resultant dest string was null terminated}}
\DoxyCodeLine{315 \textcolor{comment}{}}
\DoxyCodeLine{316 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{317 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{318 \textcolor{comment}{}}
\DoxyCodeLine{319 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{320 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{321 \textcolor{comment}{                   -\/   this return value is an indication that the copy}}
\DoxyCodeLine{322 \textcolor{comment}{                       operation failed due to insufficient space. When this}}
\DoxyCodeLine{323 \textcolor{comment}{                       error occurs, the destination buffer is modified to}}
\DoxyCodeLine{324 \textcolor{comment}{                       contain a truncated version of the ideal result and is}}
\DoxyCodeLine{325 \textcolor{comment}{                       null terminated. This is useful for situations where}}
\DoxyCodeLine{326 \textcolor{comment}{                       truncation is ok}}
\DoxyCodeLine{327 \textcolor{comment}{}}
\DoxyCodeLine{328 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{329 \textcolor{comment}{    return value of this function.}}
\DoxyCodeLine{330 \textcolor{comment}{}}
\DoxyCodeLine{331 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{332 }
\DoxyCodeLine{333 STRSAFEAPI StringCbCopyA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc);}
\DoxyCodeLine{334 STRSAFEAPI StringCbCopyW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc);}
\DoxyCodeLine{335 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{336 \textcolor{preprocessor}{\#define StringCbCopy  StringCbCopyW}}
\DoxyCodeLine{337 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{338 \textcolor{preprocessor}{\#define StringCbCopy  StringCbCopyA}}
\DoxyCodeLine{339 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{340 }
\DoxyCodeLine{341 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{342 STRSAFEAPI StringCbCopyA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc)}
\DoxyCodeLine{343 \{}
\DoxyCodeLine{344     HRESULT hr;}
\DoxyCodeLine{345     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{346 }
\DoxyCodeLine{347     \textcolor{comment}{// convert to count of characters}}
\DoxyCodeLine{348     cchDest = cbDest / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{349 }
\DoxyCodeLine{350     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{351     \{}
\DoxyCodeLine{352         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{353     \}}
\DoxyCodeLine{354     \textcolor{keywordflow}{else}}
\DoxyCodeLine{355     \{}
\DoxyCodeLine{356         hr = StringCopyWorkerA(pszDest, cchDest, pszSrc);}
\DoxyCodeLine{357     \}}
\DoxyCodeLine{358 }
\DoxyCodeLine{359     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{360 \}}
\DoxyCodeLine{361 }
\DoxyCodeLine{362 STRSAFEAPI StringCbCopyW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc)}
\DoxyCodeLine{363 \{}
\DoxyCodeLine{364     HRESULT hr;}
\DoxyCodeLine{365     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{366 }
\DoxyCodeLine{367     \textcolor{comment}{// convert to count of characters}}
\DoxyCodeLine{368     cchDest = cbDest / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{369 }
\DoxyCodeLine{370     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{371     \{}
\DoxyCodeLine{372         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{373     \}}
\DoxyCodeLine{374     \textcolor{keywordflow}{else}}
\DoxyCodeLine{375     \{}
\DoxyCodeLine{376         hr = StringCopyWorkerW(pszDest, cchDest, pszSrc);}
\DoxyCodeLine{377     \}}
\DoxyCodeLine{378 }
\DoxyCodeLine{379     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{380 \}}
\DoxyCodeLine{381 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{382 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{383 }
\DoxyCodeLine{384 }
\DoxyCodeLine{385 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{386 \textcolor{comment}{/*++}}
\DoxyCodeLine{387 \textcolor{comment}{}}
\DoxyCodeLine{388 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{389 \textcolor{comment}{StringCchCopyEx(}}
\DoxyCodeLine{390 \textcolor{comment}{    OUT LPTSTR  pszDest         OPTIONAL,}}
\DoxyCodeLine{391 \textcolor{comment}{    IN  size\_t  cchDest,}}
\DoxyCodeLine{392 \textcolor{comment}{    IN  LPCTSTR pszSrc          OPTIONAL,}}
\DoxyCodeLine{393 \textcolor{comment}{    OUT LPTSTR* ppszDestEnd     OPTIONAL,}}
\DoxyCodeLine{394 \textcolor{comment}{    OUT size\_t* pcchRemaining   OPTIONAL,}}
\DoxyCodeLine{395 \textcolor{comment}{    IN  DWORD   dwFlags}}
\DoxyCodeLine{396 \textcolor{comment}{    );}}
\DoxyCodeLine{397 \textcolor{comment}{}}
\DoxyCodeLine{398 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{399 \textcolor{comment}{}}
\DoxyCodeLine{400 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strcpy' with}}
\DoxyCodeLine{401 \textcolor{comment}{    some additional parameters.  In addition to functionality provided by}}
\DoxyCodeLine{402 \textcolor{comment}{    StringCchCopy, this routine also returns a pointer to the end of the}}
\DoxyCodeLine{403 \textcolor{comment}{    destination string and the number of characters left in the destination string}}
\DoxyCodeLine{404 \textcolor{comment}{    including the null terminator. The flags parameter allows additional controls.}}
\DoxyCodeLine{405 \textcolor{comment}{}}
\DoxyCodeLine{406 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{407 \textcolor{comment}{}}
\DoxyCodeLine{408 \textcolor{comment}{    pszDest         -\/   destination string}}
\DoxyCodeLine{409 \textcolor{comment}{}}
\DoxyCodeLine{410 \textcolor{comment}{    cchDest         -\/   size of destination buffer in characters.}}
\DoxyCodeLine{411 \textcolor{comment}{                        length must be = (\_tcslen(pszSrc) + 1) to hold all of}}
\DoxyCodeLine{412 \textcolor{comment}{                        the source including the null terminator}}
\DoxyCodeLine{413 \textcolor{comment}{}}
\DoxyCodeLine{414 \textcolor{comment}{    pszSrc          -\/   source string which must be null terminated}}
\DoxyCodeLine{415 \textcolor{comment}{}}
\DoxyCodeLine{416 \textcolor{comment}{    ppszDestEnd     -\/   if ppszDestEnd is non-\/null, the function will return a}}
\DoxyCodeLine{417 \textcolor{comment}{                        pointer to the end of the destination string.  If the}}
\DoxyCodeLine{418 \textcolor{comment}{                        function copied any data, the result will point to the}}
\DoxyCodeLine{419 \textcolor{comment}{                        null termination character}}
\DoxyCodeLine{420 \textcolor{comment}{}}
\DoxyCodeLine{421 \textcolor{comment}{    pcchRemaining   -\/   if pcchRemaining is non-\/null, the function will return the}}
\DoxyCodeLine{422 \textcolor{comment}{                        number of characters left in the destination string,}}
\DoxyCodeLine{423 \textcolor{comment}{                        including the null terminator}}
\DoxyCodeLine{424 \textcolor{comment}{}}
\DoxyCodeLine{425 \textcolor{comment}{    dwFlags         -\/   controls some details of the string copy:}}
\DoxyCodeLine{426 \textcolor{comment}{}}
\DoxyCodeLine{427 \textcolor{comment}{        STRSAFE\_FILL\_BEHIND\_NULL}}
\DoxyCodeLine{428 \textcolor{comment}{                    if the function succeeds, the low byte of dwFlags will be}}
\DoxyCodeLine{429 \textcolor{comment}{                    used to fill the uninitialize part of destination buffer}}
\DoxyCodeLine{430 \textcolor{comment}{                    behind the null terminator}}
\DoxyCodeLine{431 \textcolor{comment}{}}
\DoxyCodeLine{432 \textcolor{comment}{        STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{433 \textcolor{comment}{                    treat NULL string pointers like empty strings (TEXT("{}"{})).}}
\DoxyCodeLine{434 \textcolor{comment}{                    this flag is useful for emulating functions like lstrcpy}}
\DoxyCodeLine{435 \textcolor{comment}{}}
\DoxyCodeLine{436 \textcolor{comment}{        STRSAFE\_FILL\_ON\_FAILURE}}
\DoxyCodeLine{437 \textcolor{comment}{                    if the function fails, the low byte of dwFlags will be}}
\DoxyCodeLine{438 \textcolor{comment}{                    used to fill all of the destination buffer, and it will}}
\DoxyCodeLine{439 \textcolor{comment}{                    be null terminated. This will overwrite any truncated}}
\DoxyCodeLine{440 \textcolor{comment}{                    string returned when the failure is}}
\DoxyCodeLine{441 \textcolor{comment}{                    STRSAFE\_E\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{442 \textcolor{comment}{}}
\DoxyCodeLine{443 \textcolor{comment}{        STRSAFE\_NO\_TRUNCATION /}}
\DoxyCodeLine{444 \textcolor{comment}{        STRSAFE\_NULL\_ON\_FAILURE}}
\DoxyCodeLine{445 \textcolor{comment}{                    if the function fails, the destination buffer will be set}}
\DoxyCodeLine{446 \textcolor{comment}{                    to the empty string. This will overwrite any truncated string}}
\DoxyCodeLine{447 \textcolor{comment}{                    returned when the failure is STRSAFE\_E\_INSUFFICIENT\_BUFFER.}}
\DoxyCodeLine{448 \textcolor{comment}{}}
\DoxyCodeLine{449 \textcolor{comment}{Notes:}}
\DoxyCodeLine{450 \textcolor{comment}{    Behavior is undefined if source and destination strings overlap.}}
\DoxyCodeLine{451 \textcolor{comment}{}}
\DoxyCodeLine{452 \textcolor{comment}{    pszDest and pszSrc should not be NULL unless the STRSAFE\_IGNORE\_NULLS flag}}
\DoxyCodeLine{453 \textcolor{comment}{    is specified.  If STRSAFE\_IGNORE\_NULLS is passed, both pszDest and pszSrc}}
\DoxyCodeLine{454 \textcolor{comment}{    may be NULL.  An error may still be returned even though NULLS are ignored}}
\DoxyCodeLine{455 \textcolor{comment}{    due to insufficient space.}}
\DoxyCodeLine{456 \textcolor{comment}{}}
\DoxyCodeLine{457 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{458 \textcolor{comment}{}}
\DoxyCodeLine{459 \textcolor{comment}{    S\_OK           -\/   if there was source data and it was all copied and the}}
\DoxyCodeLine{460 \textcolor{comment}{                       resultant dest string was null terminated}}
\DoxyCodeLine{461 \textcolor{comment}{}}
\DoxyCodeLine{462 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{463 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{464 \textcolor{comment}{}}
\DoxyCodeLine{465 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{466 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{467 \textcolor{comment}{                   -\/   this return value is an indication that the copy}}
\DoxyCodeLine{468 \textcolor{comment}{                       operation failed due to insufficient space. When this}}
\DoxyCodeLine{469 \textcolor{comment}{                       error occurs, the destination buffer is modified to}}
\DoxyCodeLine{470 \textcolor{comment}{                       contain a truncated version of the ideal result and is}}
\DoxyCodeLine{471 \textcolor{comment}{                       null terminated. This is useful for situations where}}
\DoxyCodeLine{472 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{473 \textcolor{comment}{}}
\DoxyCodeLine{474 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{475 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{476 \textcolor{comment}{}}
\DoxyCodeLine{477 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{478 }
\DoxyCodeLine{479 STRSAFEAPI StringCchCopyExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{480 STRSAFEAPI StringCchCopyExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{481 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{482 \textcolor{preprocessor}{\#define StringCchCopyEx  StringCchCopyExW}}
\DoxyCodeLine{483 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{484 \textcolor{preprocessor}{\#define StringCchCopyEx  StringCchCopyExA}}
\DoxyCodeLine{485 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{486 }
\DoxyCodeLine{487 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{488 STRSAFEAPI StringCchCopyExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{489 \{}
\DoxyCodeLine{490     HRESULT hr;}
\DoxyCodeLine{491 }
\DoxyCodeLine{492     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{493     \{}
\DoxyCodeLine{494         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{495     \}}
\DoxyCodeLine{496     \textcolor{keywordflow}{else}}
\DoxyCodeLine{497     \{}
\DoxyCodeLine{498         \textcolor{keywordtype}{size\_t} cbDest;}
\DoxyCodeLine{499 }
\DoxyCodeLine{500         \textcolor{comment}{// safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE\_MAX\_CCH and sizeof(char) is 1}}
\DoxyCodeLine{501         cbDest = cchDest * \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{502 }
\DoxyCodeLine{503         hr = StringCopyExWorkerA(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, pcchRemaining, dwFlags);}
\DoxyCodeLine{504     \}}
\DoxyCodeLine{505 }
\DoxyCodeLine{506     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{507 \}}
\DoxyCodeLine{508 }
\DoxyCodeLine{509 STRSAFEAPI StringCchCopyExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{510 \{}
\DoxyCodeLine{511     HRESULT hr;}
\DoxyCodeLine{512 }
\DoxyCodeLine{513     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{514     \{}
\DoxyCodeLine{515         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{516     \}}
\DoxyCodeLine{517     \textcolor{keywordflow}{else}}
\DoxyCodeLine{518     \{}
\DoxyCodeLine{519         \textcolor{keywordtype}{size\_t} cbDest;}
\DoxyCodeLine{520 }
\DoxyCodeLine{521         \textcolor{comment}{// safe to multiply cchDest * sizeof(wchar\_t) since cchDest < STRSAFE\_MAX\_CCH and sizeof(wchar\_t) is 2}}
\DoxyCodeLine{522         cbDest = cchDest * \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{523 }
\DoxyCodeLine{524         hr = StringCopyExWorkerW(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, pcchRemaining, dwFlags);}
\DoxyCodeLine{525     \}}
\DoxyCodeLine{526 }
\DoxyCodeLine{527     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{528 \}}
\DoxyCodeLine{529 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{530 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{531 }
\DoxyCodeLine{532 }
\DoxyCodeLine{533 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{534 \textcolor{comment}{/*++}}
\DoxyCodeLine{535 \textcolor{comment}{}}
\DoxyCodeLine{536 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{537 \textcolor{comment}{StringCbCopyEx(}}
\DoxyCodeLine{538 \textcolor{comment}{    OUT LPTSTR  pszDest         OPTIONAL,}}
\DoxyCodeLine{539 \textcolor{comment}{    IN  size\_t  cbDest,}}
\DoxyCodeLine{540 \textcolor{comment}{    IN  LPCTSTR pszSrc          OPTIONAL,}}
\DoxyCodeLine{541 \textcolor{comment}{    OUT LPTSTR* ppszDestEnd     OPTIONAL,}}
\DoxyCodeLine{542 \textcolor{comment}{    OUT size\_t* pcbRemaining    OPTIONAL,}}
\DoxyCodeLine{543 \textcolor{comment}{    IN  DWORD   dwFlags}}
\DoxyCodeLine{544 \textcolor{comment}{    );}}
\DoxyCodeLine{545 \textcolor{comment}{}}
\DoxyCodeLine{546 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{547 \textcolor{comment}{}}
\DoxyCodeLine{548 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strcpy' with}}
\DoxyCodeLine{549 \textcolor{comment}{    some additional parameters.  In addition to functionality provided by}}
\DoxyCodeLine{550 \textcolor{comment}{    StringCbCopy, this routine also returns a pointer to the end of the}}
\DoxyCodeLine{551 \textcolor{comment}{    destination string and the number of bytes left in the destination string}}
\DoxyCodeLine{552 \textcolor{comment}{    including the null terminator. The flags parameter allows additional controls.}}
\DoxyCodeLine{553 \textcolor{comment}{}}
\DoxyCodeLine{554 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{555 \textcolor{comment}{}}
\DoxyCodeLine{556 \textcolor{comment}{    pszDest         -\/   destination string}}
\DoxyCodeLine{557 \textcolor{comment}{}}
\DoxyCodeLine{558 \textcolor{comment}{    cbDest          -\/   size of destination buffer in bytes.}}
\DoxyCodeLine{559 \textcolor{comment}{                        length must be ((\_tcslen(pszSrc) + 1) * sizeof(TCHAR)) to}}
\DoxyCodeLine{560 \textcolor{comment}{                        hold all of the source including the null terminator}}
\DoxyCodeLine{561 \textcolor{comment}{}}
\DoxyCodeLine{562 \textcolor{comment}{    pszSrc          -\/   source string which must be null terminated}}
\DoxyCodeLine{563 \textcolor{comment}{}}
\DoxyCodeLine{564 \textcolor{comment}{    ppszDestEnd     -\/   if ppszDestEnd is non-\/null, the function will return a}}
\DoxyCodeLine{565 \textcolor{comment}{                        pointer to the end of the destination string.  If the}}
\DoxyCodeLine{566 \textcolor{comment}{                        function copied any data, the result will point to the}}
\DoxyCodeLine{567 \textcolor{comment}{                        null termination character}}
\DoxyCodeLine{568 \textcolor{comment}{}}
\DoxyCodeLine{569 \textcolor{comment}{    pcbRemaining    -\/   pcbRemaining is non-\/null,the function will return the}}
\DoxyCodeLine{570 \textcolor{comment}{                        number of bytes left in the destination string,}}
\DoxyCodeLine{571 \textcolor{comment}{                        including the null terminator}}
\DoxyCodeLine{572 \textcolor{comment}{}}
\DoxyCodeLine{573 \textcolor{comment}{    dwFlags         -\/   controls some details of the string copy:}}
\DoxyCodeLine{574 \textcolor{comment}{}}
\DoxyCodeLine{575 \textcolor{comment}{        STRSAFE\_FILL\_BEHIND\_NULL}}
\DoxyCodeLine{576 \textcolor{comment}{                    if the function succeeds, the low byte of dwFlags will be}}
\DoxyCodeLine{577 \textcolor{comment}{                    used to fill the uninitialize part of destination buffer}}
\DoxyCodeLine{578 \textcolor{comment}{                    behind the null terminator}}
\DoxyCodeLine{579 \textcolor{comment}{}}
\DoxyCodeLine{580 \textcolor{comment}{        STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{581 \textcolor{comment}{                    treat NULL string pointers like empty strings (TEXT("{}"{})).}}
\DoxyCodeLine{582 \textcolor{comment}{                    this flag is useful for emulating functions like lstrcpy}}
\DoxyCodeLine{583 \textcolor{comment}{}}
\DoxyCodeLine{584 \textcolor{comment}{        STRSAFE\_FILL\_ON\_FAILURE}}
\DoxyCodeLine{585 \textcolor{comment}{                    if the function fails, the low byte of dwFlags will be}}
\DoxyCodeLine{586 \textcolor{comment}{                    used to fill all of the destination buffer, and it will}}
\DoxyCodeLine{587 \textcolor{comment}{                    be null terminated. This will overwrite any truncated}}
\DoxyCodeLine{588 \textcolor{comment}{                    string returned when the failure is}}
\DoxyCodeLine{589 \textcolor{comment}{                    STRSAFE\_E\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{590 \textcolor{comment}{}}
\DoxyCodeLine{591 \textcolor{comment}{        STRSAFE\_NO\_TRUNCATION /}}
\DoxyCodeLine{592 \textcolor{comment}{        STRSAFE\_NULL\_ON\_FAILURE}}
\DoxyCodeLine{593 \textcolor{comment}{                    if the function fails, the destination buffer will be set}}
\DoxyCodeLine{594 \textcolor{comment}{                    to the empty string. This will overwrite any truncated string}}
\DoxyCodeLine{595 \textcolor{comment}{                    returned when the failure is STRSAFE\_E\_INSUFFICIENT\_BUFFER.}}
\DoxyCodeLine{596 \textcolor{comment}{}}
\DoxyCodeLine{597 \textcolor{comment}{Notes:}}
\DoxyCodeLine{598 \textcolor{comment}{    Behavior is undefined if source and destination strings overlap.}}
\DoxyCodeLine{599 \textcolor{comment}{}}
\DoxyCodeLine{600 \textcolor{comment}{    pszDest and pszSrc should not be NULL unless the STRSAFE\_IGNORE\_NULLS flag}}
\DoxyCodeLine{601 \textcolor{comment}{    is specified.  If STRSAFE\_IGNORE\_NULLS is passed, both pszDest and pszSrc}}
\DoxyCodeLine{602 \textcolor{comment}{    may be NULL.  An error may still be returned even though NULLS are ignored}}
\DoxyCodeLine{603 \textcolor{comment}{    due to insufficient space.}}
\DoxyCodeLine{604 \textcolor{comment}{}}
\DoxyCodeLine{605 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{606 \textcolor{comment}{}}
\DoxyCodeLine{607 \textcolor{comment}{    S\_OK           -\/   if there was source data and it was all copied and the}}
\DoxyCodeLine{608 \textcolor{comment}{                       resultant dest string was null terminated}}
\DoxyCodeLine{609 \textcolor{comment}{}}
\DoxyCodeLine{610 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{611 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{612 \textcolor{comment}{}}
\DoxyCodeLine{613 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{614 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{615 \textcolor{comment}{                   -\/   this return value is an indication that the copy}}
\DoxyCodeLine{616 \textcolor{comment}{                       operation failed due to insufficient space. When this}}
\DoxyCodeLine{617 \textcolor{comment}{                       error occurs, the destination buffer is modified to}}
\DoxyCodeLine{618 \textcolor{comment}{                       contain a truncated version of the ideal result and is}}
\DoxyCodeLine{619 \textcolor{comment}{                       null terminated. This is useful for situations where}}
\DoxyCodeLine{620 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{621 \textcolor{comment}{}}
\DoxyCodeLine{622 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{623 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{624 \textcolor{comment}{}}
\DoxyCodeLine{625 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{626 }
\DoxyCodeLine{627 STRSAFEAPI StringCbCopyExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{628 STRSAFEAPI StringCbCopyExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{629 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{630 \textcolor{preprocessor}{\#define StringCbCopyEx  StringCbCopyExW}}
\DoxyCodeLine{631 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{632 \textcolor{preprocessor}{\#define StringCbCopyEx  StringCbCopyExA}}
\DoxyCodeLine{633 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{634 }
\DoxyCodeLine{635 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{636 STRSAFEAPI StringCbCopyExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{637 \{}
\DoxyCodeLine{638     HRESULT hr;}
\DoxyCodeLine{639     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{640     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{641 }
\DoxyCodeLine{642     cchDest = cbDest / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{643 }
\DoxyCodeLine{644     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{645     \{}
\DoxyCodeLine{646         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{647     \}}
\DoxyCodeLine{648     \textcolor{keywordflow}{else}}
\DoxyCodeLine{649     \{}
\DoxyCodeLine{650         hr = StringCopyExWorkerA(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, \&cchRemaining, dwFlags);}
\DoxyCodeLine{651     \}}
\DoxyCodeLine{652 }
\DoxyCodeLine{653     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{654     \{}
\DoxyCodeLine{655         \textcolor{keywordflow}{if} (pcbRemaining)}
\DoxyCodeLine{656         \{}
\DoxyCodeLine{657             \textcolor{comment}{// safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE\_MAX\_CCH and sizeof(char) is 1}}
\DoxyCodeLine{658             *pcbRemaining = (cchRemaining * \textcolor{keyword}{sizeof}(char)) + (cbDest \% \textcolor{keyword}{sizeof}(char));}
\DoxyCodeLine{659         \}}
\DoxyCodeLine{660     \}}
\DoxyCodeLine{661 }
\DoxyCodeLine{662     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{663 \}}
\DoxyCodeLine{664 }
\DoxyCodeLine{665 STRSAFEAPI StringCbCopyExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{666 \{}
\DoxyCodeLine{667     HRESULT hr;}
\DoxyCodeLine{668     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{669     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{670 }
\DoxyCodeLine{671     cchDest = cbDest / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{672 }
\DoxyCodeLine{673     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{674     \{}
\DoxyCodeLine{675         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{676     \}}
\DoxyCodeLine{677     \textcolor{keywordflow}{else}}
\DoxyCodeLine{678     \{}
\DoxyCodeLine{679         hr = StringCopyExWorkerW(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, \&cchRemaining, dwFlags);}
\DoxyCodeLine{680     \}}
\DoxyCodeLine{681 }
\DoxyCodeLine{682     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{683     \{}
\DoxyCodeLine{684         \textcolor{keywordflow}{if} (pcbRemaining)}
\DoxyCodeLine{685         \{}
\DoxyCodeLine{686             \textcolor{comment}{// safe to multiply cchRemaining * sizeof(wchar\_t) since cchRemaining < STRSAFE\_MAX\_CCH and sizeof(wchar\_t) is 2}}
\DoxyCodeLine{687             *pcbRemaining = (cchRemaining * \textcolor{keyword}{sizeof}(wchar\_t)) + (cbDest \% \textcolor{keyword}{sizeof}(wchar\_t));}
\DoxyCodeLine{688         \}}
\DoxyCodeLine{689     \}}
\DoxyCodeLine{690 }
\DoxyCodeLine{691     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{692 \}}
\DoxyCodeLine{693 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{694 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{695 }
\DoxyCodeLine{696 }
\DoxyCodeLine{697 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{698 \textcolor{comment}{/*++}}
\DoxyCodeLine{699 \textcolor{comment}{}}
\DoxyCodeLine{700 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{701 \textcolor{comment}{StringCchCopyN(}}
\DoxyCodeLine{702 \textcolor{comment}{    OUT LPTSTR  pszDest,}}
\DoxyCodeLine{703 \textcolor{comment}{    IN  size\_t  cchDest,}}
\DoxyCodeLine{704 \textcolor{comment}{    IN  LPCTSTR pszSrc,}}
\DoxyCodeLine{705 \textcolor{comment}{    IN  size\_t  cchSrc}}
\DoxyCodeLine{706 \textcolor{comment}{    );}}
\DoxyCodeLine{707 \textcolor{comment}{}}
\DoxyCodeLine{708 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{709 \textcolor{comment}{}}
\DoxyCodeLine{710 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strncpy'.}}
\DoxyCodeLine{711 \textcolor{comment}{    The size of the destination buffer (in characters) is a parameter and}}
\DoxyCodeLine{712 \textcolor{comment}{    this function will not write past the end of this buffer and it will}}
\DoxyCodeLine{713 \textcolor{comment}{    ALWAYS null terminate the destination buffer (unless it is zero length).}}
\DoxyCodeLine{714 \textcolor{comment}{}}
\DoxyCodeLine{715 \textcolor{comment}{    This routine is meant as a replacement for strncpy, but it does behave}}
\DoxyCodeLine{716 \textcolor{comment}{    differently. This function will not pad the destination buffer with extra}}
\DoxyCodeLine{717 \textcolor{comment}{    null termination characters if cchSrc is greater than the length of pszSrc.}}
\DoxyCodeLine{718 \textcolor{comment}{}}
\DoxyCodeLine{719 \textcolor{comment}{    This function returns a hresult, and not a pointer.  It returns}}
\DoxyCodeLine{720 \textcolor{comment}{    S\_OK if the entire string or the first cchSrc characters were copied}}
\DoxyCodeLine{721 \textcolor{comment}{    without truncation and the resultant destination string was null terminated,}}
\DoxyCodeLine{722 \textcolor{comment}{    otherwise it will return a failure code. In failure cases as much of pszSrc}}
\DoxyCodeLine{723 \textcolor{comment}{    will be copied to pszDest as possible, and pszDest will be null terminated.}}
\DoxyCodeLine{724 \textcolor{comment}{}}
\DoxyCodeLine{725 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{726 \textcolor{comment}{}}
\DoxyCodeLine{727 \textcolor{comment}{    pszDest        -\/   destination string}}
\DoxyCodeLine{728 \textcolor{comment}{}}
\DoxyCodeLine{729 \textcolor{comment}{    cchDest        -\/   size of destination buffer in characters.}}
\DoxyCodeLine{730 \textcolor{comment}{                       length must be = (\_tcslen(src) + 1) to hold all of the}}
\DoxyCodeLine{731 \textcolor{comment}{                       source including the null terminator}}
\DoxyCodeLine{732 \textcolor{comment}{}}
\DoxyCodeLine{733 \textcolor{comment}{    pszSrc         -\/   source string}}
\DoxyCodeLine{734 \textcolor{comment}{}}
\DoxyCodeLine{735 \textcolor{comment}{    cchSrc         -\/   maximum number of characters to copy from source string,}}
\DoxyCodeLine{736 \textcolor{comment}{                       not including the null terminator.}}
\DoxyCodeLine{737 \textcolor{comment}{}}
\DoxyCodeLine{738 \textcolor{comment}{Notes:}}
\DoxyCodeLine{739 \textcolor{comment}{    Behavior is undefined if source and destination strings overlap.}}
\DoxyCodeLine{740 \textcolor{comment}{}}
\DoxyCodeLine{741 \textcolor{comment}{    pszDest and pszSrc should not be NULL. See StringCchCopyNEx if you require}}
\DoxyCodeLine{742 \textcolor{comment}{    the handling of NULL values.}}
\DoxyCodeLine{743 \textcolor{comment}{}}
\DoxyCodeLine{744 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{745 \textcolor{comment}{}}
\DoxyCodeLine{746 \textcolor{comment}{    S\_OK           -\/   if there was source data and it was all copied and the}}
\DoxyCodeLine{747 \textcolor{comment}{                       resultant dest string was null terminated}}
\DoxyCodeLine{748 \textcolor{comment}{}}
\DoxyCodeLine{749 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{750 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{751 \textcolor{comment}{}}
\DoxyCodeLine{752 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{753 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{754 \textcolor{comment}{                   -\/   this return value is an indication that the copy}}
\DoxyCodeLine{755 \textcolor{comment}{                       operation failed due to insufficient space. When this}}
\DoxyCodeLine{756 \textcolor{comment}{                       error occurs, the destination buffer is modified to}}
\DoxyCodeLine{757 \textcolor{comment}{                       contain a truncated version of the ideal result and is}}
\DoxyCodeLine{758 \textcolor{comment}{                       null terminated. This is useful for situations where}}
\DoxyCodeLine{759 \textcolor{comment}{                       truncation is ok}}
\DoxyCodeLine{760 \textcolor{comment}{}}
\DoxyCodeLine{761 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{762 \textcolor{comment}{    return value of this function.}}
\DoxyCodeLine{763 \textcolor{comment}{}}
\DoxyCodeLine{764 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{765 }
\DoxyCodeLine{766 STRSAFEAPI StringCchCopyNA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cchSrc);}
\DoxyCodeLine{767 STRSAFEAPI StringCchCopyNW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cchSrc);}
\DoxyCodeLine{768 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{769 \textcolor{preprocessor}{\#define StringCchCopyN  StringCchCopyNW}}
\DoxyCodeLine{770 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{771 \textcolor{preprocessor}{\#define StringCchCopyN  StringCchCopyNA}}
\DoxyCodeLine{772 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{773 }
\DoxyCodeLine{774 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{775 STRSAFEAPI StringCchCopyNA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cchSrc)}
\DoxyCodeLine{776 \{}
\DoxyCodeLine{777     HRESULT hr;}
\DoxyCodeLine{778 }
\DoxyCodeLine{779     \textcolor{keywordflow}{if} ((cchDest > STRSAFE\_MAX\_CCH) ||}
\DoxyCodeLine{780         (cchSrc > STRSAFE\_MAX\_CCH))}
\DoxyCodeLine{781     \{}
\DoxyCodeLine{782         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{783     \}}
\DoxyCodeLine{784     \textcolor{keywordflow}{else}}
\DoxyCodeLine{785     \{}
\DoxyCodeLine{786         hr = StringCopyNWorkerA(pszDest, cchDest, pszSrc, cchSrc);}
\DoxyCodeLine{787     \}}
\DoxyCodeLine{788 }
\DoxyCodeLine{789     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{790 \}}
\DoxyCodeLine{791 }
\DoxyCodeLine{792 STRSAFEAPI StringCchCopyNW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cchSrc)}
\DoxyCodeLine{793 \{}
\DoxyCodeLine{794     HRESULT hr;}
\DoxyCodeLine{795 }
\DoxyCodeLine{796     \textcolor{keywordflow}{if} ((cchDest > STRSAFE\_MAX\_CCH) ||}
\DoxyCodeLine{797         (cchSrc > STRSAFE\_MAX\_CCH))}
\DoxyCodeLine{798     \{}
\DoxyCodeLine{799         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{800     \}}
\DoxyCodeLine{801     \textcolor{keywordflow}{else}}
\DoxyCodeLine{802     \{}
\DoxyCodeLine{803         hr = StringCopyNWorkerW(pszDest, cchDest, pszSrc, cchSrc);}
\DoxyCodeLine{804     \}}
\DoxyCodeLine{805 }
\DoxyCodeLine{806     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{807 \}}
\DoxyCodeLine{808 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{809 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{810 }
\DoxyCodeLine{811 }
\DoxyCodeLine{812 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{813 \textcolor{comment}{/*++}}
\DoxyCodeLine{814 \textcolor{comment}{}}
\DoxyCodeLine{815 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{816 \textcolor{comment}{StringCbCopyN(}}
\DoxyCodeLine{817 \textcolor{comment}{    OUT LPTSTR  pszDest,}}
\DoxyCodeLine{818 \textcolor{comment}{    IN  size\_t  cbDest,}}
\DoxyCodeLine{819 \textcolor{comment}{    IN  LPCTSTR pszSrc,}}
\DoxyCodeLine{820 \textcolor{comment}{    IN  size\_t  cbSrc}}
\DoxyCodeLine{821 \textcolor{comment}{    );}}
\DoxyCodeLine{822 \textcolor{comment}{}}
\DoxyCodeLine{823 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{824 \textcolor{comment}{}}
\DoxyCodeLine{825 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strncpy'.}}
\DoxyCodeLine{826 \textcolor{comment}{    The size of the destination buffer (in bytes) is a parameter and this}}
\DoxyCodeLine{827 \textcolor{comment}{    function will not write past the end of this buffer and it will ALWAYS}}
\DoxyCodeLine{828 \textcolor{comment}{    null terminate the destination buffer (unless it is zero length).}}
\DoxyCodeLine{829 \textcolor{comment}{}}
\DoxyCodeLine{830 \textcolor{comment}{    This routine is meant as a replacement for strncpy, but it does behave}}
\DoxyCodeLine{831 \textcolor{comment}{    differently. This function will not pad the destination buffer with extra}}
\DoxyCodeLine{832 \textcolor{comment}{    null termination characters if cbSrc is greater than the size of pszSrc.}}
\DoxyCodeLine{833 \textcolor{comment}{}}
\DoxyCodeLine{834 \textcolor{comment}{    This function returns a hresult, and not a pointer.  It returns}}
\DoxyCodeLine{835 \textcolor{comment}{    S\_OK if the entire string or the first cbSrc characters were}}
\DoxyCodeLine{836 \textcolor{comment}{    copied without truncation and the resultant destination string was null}}
\DoxyCodeLine{837 \textcolor{comment}{    terminated, otherwise it will return a failure code. In failure cases as}}
\DoxyCodeLine{838 \textcolor{comment}{    much of pszSrc will be copied to pszDest as possible, and pszDest will be}}
\DoxyCodeLine{839 \textcolor{comment}{    null terminated.}}
\DoxyCodeLine{840 \textcolor{comment}{}}
\DoxyCodeLine{841 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{842 \textcolor{comment}{}}
\DoxyCodeLine{843 \textcolor{comment}{    pszDest        -\/   destination string}}
\DoxyCodeLine{844 \textcolor{comment}{}}
\DoxyCodeLine{845 \textcolor{comment}{    cbDest         -\/   size of destination buffer in bytes.}}
\DoxyCodeLine{846 \textcolor{comment}{                       length must be = ((\_tcslen(src) + 1) * sizeof(TCHAR)) to}}
\DoxyCodeLine{847 \textcolor{comment}{                       hold all of the source including the null terminator}}
\DoxyCodeLine{848 \textcolor{comment}{}}
\DoxyCodeLine{849 \textcolor{comment}{    pszSrc         -\/   source string}}
\DoxyCodeLine{850 \textcolor{comment}{}}
\DoxyCodeLine{851 \textcolor{comment}{    cbSrc          -\/   maximum number of bytes to copy from source string,}}
\DoxyCodeLine{852 \textcolor{comment}{                       not including the null terminator.}}
\DoxyCodeLine{853 \textcolor{comment}{}}
\DoxyCodeLine{854 \textcolor{comment}{Notes:}}
\DoxyCodeLine{855 \textcolor{comment}{    Behavior is undefined if source and destination strings overlap.}}
\DoxyCodeLine{856 \textcolor{comment}{}}
\DoxyCodeLine{857 \textcolor{comment}{    pszDest and pszSrc should not be NULL.  See StringCbCopyEx if you require}}
\DoxyCodeLine{858 \textcolor{comment}{    the handling of NULL values.}}
\DoxyCodeLine{859 \textcolor{comment}{}}
\DoxyCodeLine{860 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{861 \textcolor{comment}{}}
\DoxyCodeLine{862 \textcolor{comment}{    S\_OK           -\/   if there was source data and it was all copied and the}}
\DoxyCodeLine{863 \textcolor{comment}{                       resultant dest string was null terminated}}
\DoxyCodeLine{864 \textcolor{comment}{}}
\DoxyCodeLine{865 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{866 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{867 \textcolor{comment}{}}
\DoxyCodeLine{868 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{869 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{870 \textcolor{comment}{                   -\/   this return value is an indication that the copy}}
\DoxyCodeLine{871 \textcolor{comment}{                       operation failed due to insufficient space. When this}}
\DoxyCodeLine{872 \textcolor{comment}{                       error occurs, the destination buffer is modified to}}
\DoxyCodeLine{873 \textcolor{comment}{                       contain a truncated version of the ideal result and is}}
\DoxyCodeLine{874 \textcolor{comment}{                       null terminated. This is useful for situations where}}
\DoxyCodeLine{875 \textcolor{comment}{                       truncation is ok}}
\DoxyCodeLine{876 \textcolor{comment}{}}
\DoxyCodeLine{877 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{878 \textcolor{comment}{    return value of this function.}}
\DoxyCodeLine{879 \textcolor{comment}{}}
\DoxyCodeLine{880 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{881 }
\DoxyCodeLine{882 STRSAFEAPI StringCbCopyNA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cbSrc);}
\DoxyCodeLine{883 STRSAFEAPI StringCbCopyNW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cbSrc);}
\DoxyCodeLine{884 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{885 \textcolor{preprocessor}{\#define StringCbCopyN  StringCbCopyNW}}
\DoxyCodeLine{886 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{887 \textcolor{preprocessor}{\#define StringCbCopyN  StringCbCopyNA}}
\DoxyCodeLine{888 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{889 }
\DoxyCodeLine{890 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{891 STRSAFEAPI StringCbCopyNA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cbSrc)}
\DoxyCodeLine{892 \{}
\DoxyCodeLine{893     HRESULT hr;}
\DoxyCodeLine{894     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{895     \textcolor{keywordtype}{size\_t} cchSrc;}
\DoxyCodeLine{896 }
\DoxyCodeLine{897     \textcolor{comment}{// convert to count of characters}}
\DoxyCodeLine{898     cchDest = cbDest / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{899     cchSrc = cbSrc / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{900 }
\DoxyCodeLine{901     \textcolor{keywordflow}{if} ((cchDest > STRSAFE\_MAX\_CCH) ||}
\DoxyCodeLine{902         (cchSrc > STRSAFE\_MAX\_CCH))}
\DoxyCodeLine{903     \{}
\DoxyCodeLine{904         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{905     \}}
\DoxyCodeLine{906     \textcolor{keywordflow}{else}}
\DoxyCodeLine{907     \{}
\DoxyCodeLine{908         hr = StringCopyNWorkerA(pszDest, cchDest, pszSrc, cchSrc);}
\DoxyCodeLine{909     \}}
\DoxyCodeLine{910 }
\DoxyCodeLine{911     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{912 \}}
\DoxyCodeLine{913 }
\DoxyCodeLine{914 STRSAFEAPI StringCbCopyNW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cbSrc)}
\DoxyCodeLine{915 \{}
\DoxyCodeLine{916     HRESULT hr;}
\DoxyCodeLine{917     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{918     \textcolor{keywordtype}{size\_t} cchSrc;}
\DoxyCodeLine{919 }
\DoxyCodeLine{920     \textcolor{comment}{// convert to count of characters}}
\DoxyCodeLine{921     cchDest = cbDest / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{922     cchSrc = cbSrc / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{923 }
\DoxyCodeLine{924     \textcolor{keywordflow}{if} ((cchDest > STRSAFE\_MAX\_CCH) ||}
\DoxyCodeLine{925         (cchSrc > STRSAFE\_MAX\_CCH))}
\DoxyCodeLine{926     \{}
\DoxyCodeLine{927         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{928     \}}
\DoxyCodeLine{929     \textcolor{keywordflow}{else}}
\DoxyCodeLine{930     \{}
\DoxyCodeLine{931         hr = StringCopyNWorkerW(pszDest, cchDest, pszSrc, cchSrc);}
\DoxyCodeLine{932     \}}
\DoxyCodeLine{933 }
\DoxyCodeLine{934     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{935 \}}
\DoxyCodeLine{936 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{937 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{938 }
\DoxyCodeLine{939 }
\DoxyCodeLine{940 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{941 \textcolor{comment}{/*++}}
\DoxyCodeLine{942 \textcolor{comment}{}}
\DoxyCodeLine{943 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{944 \textcolor{comment}{StringCchCopyNEx(}}
\DoxyCodeLine{945 \textcolor{comment}{    OUT LPTSTR  pszDest         OPTIONAL,}}
\DoxyCodeLine{946 \textcolor{comment}{    IN  size\_t  cchDest,}}
\DoxyCodeLine{947 \textcolor{comment}{    IN  LPCTSTR pszSrc          OPTIONAL,}}
\DoxyCodeLine{948 \textcolor{comment}{    IN  size\_t  cchSrc,}}
\DoxyCodeLine{949 \textcolor{comment}{    OUT LPTSTR* ppszDestEnd     OPTIONAL,}}
\DoxyCodeLine{950 \textcolor{comment}{    OUT size\_t* pcchRemaining   OPTIONAL,}}
\DoxyCodeLine{951 \textcolor{comment}{    IN  DWORD   dwFlags}}
\DoxyCodeLine{952 \textcolor{comment}{    );}}
\DoxyCodeLine{953 \textcolor{comment}{}}
\DoxyCodeLine{954 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{955 \textcolor{comment}{}}
\DoxyCodeLine{956 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strncpy' with}}
\DoxyCodeLine{957 \textcolor{comment}{    some additional parameters.  In addition to functionality provided by}}
\DoxyCodeLine{958 \textcolor{comment}{    StringCchCopyN, this routine also returns a pointer to the end of the}}
\DoxyCodeLine{959 \textcolor{comment}{    destination string and the number of characters left in the destination}}
\DoxyCodeLine{960 \textcolor{comment}{    string including the null terminator. The flags parameter allows}}
\DoxyCodeLine{961 \textcolor{comment}{    additional controls.}}
\DoxyCodeLine{962 \textcolor{comment}{}}
\DoxyCodeLine{963 \textcolor{comment}{    This routine is meant as a replacement for strncpy, but it does behave}}
\DoxyCodeLine{964 \textcolor{comment}{    differently. This function will not pad the destination buffer with extra}}
\DoxyCodeLine{965 \textcolor{comment}{    null termination characters if cchSrc is greater than the length of pszSrc.}}
\DoxyCodeLine{966 \textcolor{comment}{}}
\DoxyCodeLine{967 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{968 \textcolor{comment}{}}
\DoxyCodeLine{969 \textcolor{comment}{    pszDest         -\/   destination string}}
\DoxyCodeLine{970 \textcolor{comment}{}}
\DoxyCodeLine{971 \textcolor{comment}{    cchDest         -\/   size of destination buffer in characters.}}
\DoxyCodeLine{972 \textcolor{comment}{                        length must be = (\_tcslen(pszSrc) + 1) to hold all of}}
\DoxyCodeLine{973 \textcolor{comment}{                        the source including the null terminator}}
\DoxyCodeLine{974 \textcolor{comment}{}}
\DoxyCodeLine{975 \textcolor{comment}{    pszSrc          -\/   source string}}
\DoxyCodeLine{976 \textcolor{comment}{}}
\DoxyCodeLine{977 \textcolor{comment}{    cchSrc          -\/   maximum number of characters to copy from the source}}
\DoxyCodeLine{978 \textcolor{comment}{                        string}}
\DoxyCodeLine{979 \textcolor{comment}{}}
\DoxyCodeLine{980 \textcolor{comment}{    ppszDestEnd     -\/   if ppszDestEnd is non-\/null, the function will return a}}
\DoxyCodeLine{981 \textcolor{comment}{                        pointer to the end of the destination string.  If the}}
\DoxyCodeLine{982 \textcolor{comment}{                        function copied any data, the result will point to the}}
\DoxyCodeLine{983 \textcolor{comment}{                        null termination character}}
\DoxyCodeLine{984 \textcolor{comment}{}}
\DoxyCodeLine{985 \textcolor{comment}{    pcchRemaining   -\/   if pcchRemaining is non-\/null, the function will return the}}
\DoxyCodeLine{986 \textcolor{comment}{                        number of characters left in the destination string,}}
\DoxyCodeLine{987 \textcolor{comment}{                        including the null terminator}}
\DoxyCodeLine{988 \textcolor{comment}{}}
\DoxyCodeLine{989 \textcolor{comment}{    dwFlags         -\/   controls some details of the string copy:}}
\DoxyCodeLine{990 \textcolor{comment}{}}
\DoxyCodeLine{991 \textcolor{comment}{        STRSAFE\_FILL\_BEHIND\_NULL}}
\DoxyCodeLine{992 \textcolor{comment}{                    if the function succeeds, the low byte of dwFlags will be}}
\DoxyCodeLine{993 \textcolor{comment}{                    used to fill the uninitialize part of destination buffer}}
\DoxyCodeLine{994 \textcolor{comment}{                    behind the null terminator}}
\DoxyCodeLine{995 \textcolor{comment}{}}
\DoxyCodeLine{996 \textcolor{comment}{        STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{997 \textcolor{comment}{                    treat NULL string pointers like empty strings (TEXT("{}"{})).}}
\DoxyCodeLine{998 \textcolor{comment}{                    this flag is useful for emulating functions like lstrcpy}}
\DoxyCodeLine{999 \textcolor{comment}{}}
\DoxyCodeLine{1000 \textcolor{comment}{        STRSAFE\_FILL\_ON\_FAILURE}}
\DoxyCodeLine{1001 \textcolor{comment}{                    if the function fails, the low byte of dwFlags will be}}
\DoxyCodeLine{1002 \textcolor{comment}{                    used to fill all of the destination buffer, and it will}}
\DoxyCodeLine{1003 \textcolor{comment}{                    be null terminated. This will overwrite any truncated}}
\DoxyCodeLine{1004 \textcolor{comment}{                    string returned when the failure is}}
\DoxyCodeLine{1005 \textcolor{comment}{                    STRSAFE\_E\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{1006 \textcolor{comment}{}}
\DoxyCodeLine{1007 \textcolor{comment}{        STRSAFE\_NO\_TRUNCATION /}}
\DoxyCodeLine{1008 \textcolor{comment}{        STRSAFE\_NULL\_ON\_FAILURE}}
\DoxyCodeLine{1009 \textcolor{comment}{                    if the function fails, the destination buffer will be set}}
\DoxyCodeLine{1010 \textcolor{comment}{                    to the empty string. This will overwrite any truncated string}}
\DoxyCodeLine{1011 \textcolor{comment}{                    returned when the failure is STRSAFE\_E\_INSUFFICIENT\_BUFFER.}}
\DoxyCodeLine{1012 \textcolor{comment}{}}
\DoxyCodeLine{1013 \textcolor{comment}{Notes:}}
\DoxyCodeLine{1014 \textcolor{comment}{    Behavior is undefined if source and destination strings overlap.}}
\DoxyCodeLine{1015 \textcolor{comment}{}}
\DoxyCodeLine{1016 \textcolor{comment}{    pszDest and pszSrc should not be NULL unless the STRSAFE\_IGNORE\_NULLS flag}}
\DoxyCodeLine{1017 \textcolor{comment}{    is specified. If STRSAFE\_IGNORE\_NULLS is passed, both pszDest and pszSrc}}
\DoxyCodeLine{1018 \textcolor{comment}{    may be NULL. An error may still be returned even though NULLS are ignored}}
\DoxyCodeLine{1019 \textcolor{comment}{    due to insufficient space.}}
\DoxyCodeLine{1020 \textcolor{comment}{}}
\DoxyCodeLine{1021 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{1022 \textcolor{comment}{}}
\DoxyCodeLine{1023 \textcolor{comment}{    S\_OK           -\/   if there was source data and it was all copied and the}}
\DoxyCodeLine{1024 \textcolor{comment}{                       resultant dest string was null terminated}}
\DoxyCodeLine{1025 \textcolor{comment}{}}
\DoxyCodeLine{1026 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{1027 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{1028 \textcolor{comment}{}}
\DoxyCodeLine{1029 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{1030 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{1031 \textcolor{comment}{                   -\/   this return value is an indication that the copy}}
\DoxyCodeLine{1032 \textcolor{comment}{                       operation failed due to insufficient space. When this}}
\DoxyCodeLine{1033 \textcolor{comment}{                       error occurs, the destination buffer is modified to}}
\DoxyCodeLine{1034 \textcolor{comment}{                       contain a truncated version of the ideal result and is}}
\DoxyCodeLine{1035 \textcolor{comment}{                       null terminated. This is useful for situations where}}
\DoxyCodeLine{1036 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{1037 \textcolor{comment}{}}
\DoxyCodeLine{1038 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{1039 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{1040 \textcolor{comment}{}}
\DoxyCodeLine{1041 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{1042 }
\DoxyCodeLine{1043 STRSAFEAPI StringCchCopyNExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cchSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{1044 STRSAFEAPI StringCchCopyNExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cchSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{1045 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{1046 \textcolor{preprocessor}{\#define StringCchCopyNEx  StringCchCopyNExW}}
\DoxyCodeLine{1047 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1048 \textcolor{preprocessor}{\#define StringCchCopyNEx  StringCchCopyNExA}}
\DoxyCodeLine{1049 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{1050 }
\DoxyCodeLine{1051 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{1052 STRSAFEAPI StringCchCopyNExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cchSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{1053 \{}
\DoxyCodeLine{1054     HRESULT hr;}
\DoxyCodeLine{1055 }
\DoxyCodeLine{1056     \textcolor{keywordflow}{if} ((cchDest > STRSAFE\_MAX\_CCH) ||}
\DoxyCodeLine{1057         (cchSrc > STRSAFE\_MAX\_CCH))}
\DoxyCodeLine{1058     \{}
\DoxyCodeLine{1059         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{1060     \}}
\DoxyCodeLine{1061     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1062     \{}
\DoxyCodeLine{1063         \textcolor{keywordtype}{size\_t} cbDest;}
\DoxyCodeLine{1064 }
\DoxyCodeLine{1065         \textcolor{comment}{// safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE\_MAX\_CCH and sizeof(char) is 1}}
\DoxyCodeLine{1066         cbDest = cchDest * \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{1067 }
\DoxyCodeLine{1068         hr = StringCopyNExWorkerA(pszDest, cchDest, cbDest, pszSrc, cchSrc, ppszDestEnd, pcchRemaining, dwFlags);}
\DoxyCodeLine{1069     \}}
\DoxyCodeLine{1070 }
\DoxyCodeLine{1071     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{1072 \}}
\DoxyCodeLine{1073 }
\DoxyCodeLine{1074 STRSAFEAPI StringCchCopyNExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cchSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{1075 \{}
\DoxyCodeLine{1076     HRESULT hr;}
\DoxyCodeLine{1077 }
\DoxyCodeLine{1078     \textcolor{keywordflow}{if} ((cchDest > STRSAFE\_MAX\_CCH) ||}
\DoxyCodeLine{1079         (cchSrc > STRSAFE\_MAX\_CCH))}
\DoxyCodeLine{1080     \{}
\DoxyCodeLine{1081         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{1082     \}}
\DoxyCodeLine{1083     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1084     \{}
\DoxyCodeLine{1085         \textcolor{keywordtype}{size\_t} cbDest;}
\DoxyCodeLine{1086 }
\DoxyCodeLine{1087         \textcolor{comment}{// safe to multiply cchDest * sizeof(wchar\_t) since cchDest < STRSAFE\_MAX\_CCH and sizeof(wchar\_t) is 2}}
\DoxyCodeLine{1088         cbDest = cchDest * \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{1089 }
\DoxyCodeLine{1090         hr = StringCopyNExWorkerW(pszDest, cchDest, cbDest, pszSrc, cchSrc, ppszDestEnd, pcchRemaining, dwFlags);}
\DoxyCodeLine{1091     \}}
\DoxyCodeLine{1092 }
\DoxyCodeLine{1093     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{1094 \}}
\DoxyCodeLine{1095 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{1096 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{1097 }
\DoxyCodeLine{1098 }
\DoxyCodeLine{1099 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{1100 \textcolor{comment}{/*++}}
\DoxyCodeLine{1101 \textcolor{comment}{}}
\DoxyCodeLine{1102 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{1103 \textcolor{comment}{StringCbCopyNEx(}}
\DoxyCodeLine{1104 \textcolor{comment}{    OUT LPTSTR  pszDest         OPTIONAL,}}
\DoxyCodeLine{1105 \textcolor{comment}{    IN  size\_t  cbDest,}}
\DoxyCodeLine{1106 \textcolor{comment}{    IN  LPCTSTR pszSrc          OPTIONAL,}}
\DoxyCodeLine{1107 \textcolor{comment}{    IN  size\_t  cbSrc,}}
\DoxyCodeLine{1108 \textcolor{comment}{    OUT LPTSTR* ppszDestEnd     OPTIONAL,}}
\DoxyCodeLine{1109 \textcolor{comment}{    OUT size\_t* pcbRemaining    OPTIONAL,}}
\DoxyCodeLine{1110 \textcolor{comment}{    IN  DWORD   dwFlags}}
\DoxyCodeLine{1111 \textcolor{comment}{    );}}
\DoxyCodeLine{1112 \textcolor{comment}{}}
\DoxyCodeLine{1113 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{1114 \textcolor{comment}{}}
\DoxyCodeLine{1115 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strncpy' with}}
\DoxyCodeLine{1116 \textcolor{comment}{    some additional parameters.  In addition to functionality provided by}}
\DoxyCodeLine{1117 \textcolor{comment}{    StringCbCopyN, this routine also returns a pointer to the end of the}}
\DoxyCodeLine{1118 \textcolor{comment}{    destination string and the number of bytes left in the destination string}}
\DoxyCodeLine{1119 \textcolor{comment}{    including the null terminator. The flags parameter allows additional controls.}}
\DoxyCodeLine{1120 \textcolor{comment}{}}
\DoxyCodeLine{1121 \textcolor{comment}{    This routine is meant as a replacement for strncpy, but it does behave}}
\DoxyCodeLine{1122 \textcolor{comment}{    differently. This function will not pad the destination buffer with extra}}
\DoxyCodeLine{1123 \textcolor{comment}{    null termination characters if cbSrc is greater than the size of pszSrc.}}
\DoxyCodeLine{1124 \textcolor{comment}{}}
\DoxyCodeLine{1125 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{1126 \textcolor{comment}{}}
\DoxyCodeLine{1127 \textcolor{comment}{    pszDest         -\/   destination string}}
\DoxyCodeLine{1128 \textcolor{comment}{}}
\DoxyCodeLine{1129 \textcolor{comment}{    cbDest          -\/   size of destination buffer in bytes.}}
\DoxyCodeLine{1130 \textcolor{comment}{                        length must be ((\_tcslen(pszSrc) + 1) * sizeof(TCHAR)) to}}
\DoxyCodeLine{1131 \textcolor{comment}{                        hold all of the source including the null terminator}}
\DoxyCodeLine{1132 \textcolor{comment}{}}
\DoxyCodeLine{1133 \textcolor{comment}{    pszSrc          -\/   source string}}
\DoxyCodeLine{1134 \textcolor{comment}{}}
\DoxyCodeLine{1135 \textcolor{comment}{    cbSrc           -\/   maximum number of bytes to copy from source string}}
\DoxyCodeLine{1136 \textcolor{comment}{}}
\DoxyCodeLine{1137 \textcolor{comment}{    ppszDestEnd     -\/   if ppszDestEnd is non-\/null, the function will return a}}
\DoxyCodeLine{1138 \textcolor{comment}{                        pointer to the end of the destination string.  If the}}
\DoxyCodeLine{1139 \textcolor{comment}{                        function copied any data, the result will point to the}}
\DoxyCodeLine{1140 \textcolor{comment}{                        null termination character}}
\DoxyCodeLine{1141 \textcolor{comment}{}}
\DoxyCodeLine{1142 \textcolor{comment}{    pcbRemaining    -\/   pcbRemaining is non-\/null,the function will return the}}
\DoxyCodeLine{1143 \textcolor{comment}{                        number of bytes left in the destination string,}}
\DoxyCodeLine{1144 \textcolor{comment}{                        including the null terminator}}
\DoxyCodeLine{1145 \textcolor{comment}{}}
\DoxyCodeLine{1146 \textcolor{comment}{    dwFlags         -\/   controls some details of the string copy:}}
\DoxyCodeLine{1147 \textcolor{comment}{}}
\DoxyCodeLine{1148 \textcolor{comment}{        STRSAFE\_FILL\_BEHIND\_NULL}}
\DoxyCodeLine{1149 \textcolor{comment}{                    if the function succeeds, the low byte of dwFlags will be}}
\DoxyCodeLine{1150 \textcolor{comment}{                    used to fill the uninitialize part of destination buffer}}
\DoxyCodeLine{1151 \textcolor{comment}{                    behind the null terminator}}
\DoxyCodeLine{1152 \textcolor{comment}{}}
\DoxyCodeLine{1153 \textcolor{comment}{        STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{1154 \textcolor{comment}{                    treat NULL string pointers like empty strings (TEXT("{}"{})).}}
\DoxyCodeLine{1155 \textcolor{comment}{                    this flag is useful for emulating functions like lstrcpy}}
\DoxyCodeLine{1156 \textcolor{comment}{}}
\DoxyCodeLine{1157 \textcolor{comment}{        STRSAFE\_FILL\_ON\_FAILURE}}
\DoxyCodeLine{1158 \textcolor{comment}{                    if the function fails, the low byte of dwFlags will be}}
\DoxyCodeLine{1159 \textcolor{comment}{                    used to fill all of the destination buffer, and it will}}
\DoxyCodeLine{1160 \textcolor{comment}{                    be null terminated. This will overwrite any truncated}}
\DoxyCodeLine{1161 \textcolor{comment}{                    string returned when the failure is}}
\DoxyCodeLine{1162 \textcolor{comment}{                    STRSAFE\_E\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{1163 \textcolor{comment}{}}
\DoxyCodeLine{1164 \textcolor{comment}{        STRSAFE\_NO\_TRUNCATION /}}
\DoxyCodeLine{1165 \textcolor{comment}{        STRSAFE\_NULL\_ON\_FAILURE}}
\DoxyCodeLine{1166 \textcolor{comment}{                    if the function fails, the destination buffer will be set}}
\DoxyCodeLine{1167 \textcolor{comment}{                    to the empty string. This will overwrite any truncated string}}
\DoxyCodeLine{1168 \textcolor{comment}{                    returned when the failure is STRSAFE\_E\_INSUFFICIENT\_BUFFER.}}
\DoxyCodeLine{1169 \textcolor{comment}{}}
\DoxyCodeLine{1170 \textcolor{comment}{Notes:}}
\DoxyCodeLine{1171 \textcolor{comment}{    Behavior is undefined if source and destination strings overlap.}}
\DoxyCodeLine{1172 \textcolor{comment}{}}
\DoxyCodeLine{1173 \textcolor{comment}{    pszDest and pszSrc should not be NULL unless the STRSAFE\_IGNORE\_NULLS flag}}
\DoxyCodeLine{1174 \textcolor{comment}{    is specified.  If STRSAFE\_IGNORE\_NULLS is passed, both pszDest and pszSrc}}
\DoxyCodeLine{1175 \textcolor{comment}{    may be NULL.  An error may still be returned even though NULLS are ignored}}
\DoxyCodeLine{1176 \textcolor{comment}{    due to insufficient space.}}
\DoxyCodeLine{1177 \textcolor{comment}{}}
\DoxyCodeLine{1178 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{1179 \textcolor{comment}{}}
\DoxyCodeLine{1180 \textcolor{comment}{    S\_OK           -\/   if there was source data and it was all copied and the}}
\DoxyCodeLine{1181 \textcolor{comment}{                       resultant dest string was null terminated}}
\DoxyCodeLine{1182 \textcolor{comment}{}}
\DoxyCodeLine{1183 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{1184 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{1185 \textcolor{comment}{}}
\DoxyCodeLine{1186 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{1187 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{1188 \textcolor{comment}{                   -\/   this return value is an indication that the copy}}
\DoxyCodeLine{1189 \textcolor{comment}{                       operation failed due to insufficient space. When this}}
\DoxyCodeLine{1190 \textcolor{comment}{                       error occurs, the destination buffer is modified to}}
\DoxyCodeLine{1191 \textcolor{comment}{                       contain a truncated version of the ideal result and is}}
\DoxyCodeLine{1192 \textcolor{comment}{                       null terminated. This is useful for situations where}}
\DoxyCodeLine{1193 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{1194 \textcolor{comment}{}}
\DoxyCodeLine{1195 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{1196 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{1197 \textcolor{comment}{}}
\DoxyCodeLine{1198 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{1199 }
\DoxyCodeLine{1200 STRSAFEAPI StringCbCopyNExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cbSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{1201 STRSAFEAPI StringCbCopyNExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cbSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{1202 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{1203 \textcolor{preprocessor}{\#define StringCbCopyNEx  StringCbCopyNExW}}
\DoxyCodeLine{1204 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1205 \textcolor{preprocessor}{\#define StringCbCopyNEx  StringCbCopyNExA}}
\DoxyCodeLine{1206 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{1207 }
\DoxyCodeLine{1208 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{1209 STRSAFEAPI StringCbCopyNExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cbSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{1210 \{}
\DoxyCodeLine{1211     HRESULT hr;}
\DoxyCodeLine{1212     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{1213     \textcolor{keywordtype}{size\_t} cchSrc;}
\DoxyCodeLine{1214     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{1215 }
\DoxyCodeLine{1216     cchDest = cbDest / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{1217     cchSrc = cbSrc / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{1218 }
\DoxyCodeLine{1219     \textcolor{keywordflow}{if} ((cchDest > STRSAFE\_MAX\_CCH) ||}
\DoxyCodeLine{1220         (cchSrc > STRSAFE\_MAX\_CCH))}
\DoxyCodeLine{1221     \{}
\DoxyCodeLine{1222         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{1223     \}}
\DoxyCodeLine{1224     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1225     \{}
\DoxyCodeLine{1226         hr = StringCopyNExWorkerA(pszDest, cchDest, cbDest, pszSrc, cchSrc, ppszDestEnd, \&cchRemaining, dwFlags);}
\DoxyCodeLine{1227     \}}
\DoxyCodeLine{1228 }
\DoxyCodeLine{1229     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{1230     \{}
\DoxyCodeLine{1231         \textcolor{keywordflow}{if} (pcbRemaining)}
\DoxyCodeLine{1232         \{}
\DoxyCodeLine{1233             \textcolor{comment}{// safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE\_MAX\_CCH and sizeof(char) is 1}}
\DoxyCodeLine{1234             *pcbRemaining = (cchRemaining * \textcolor{keyword}{sizeof}(char)) + (cbDest \% \textcolor{keyword}{sizeof}(char));}
\DoxyCodeLine{1235         \}}
\DoxyCodeLine{1236     \}}
\DoxyCodeLine{1237 }
\DoxyCodeLine{1238     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{1239 \}}
\DoxyCodeLine{1240 }
\DoxyCodeLine{1241 STRSAFEAPI StringCbCopyNExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cbSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{1242 \{}
\DoxyCodeLine{1243     HRESULT hr;}
\DoxyCodeLine{1244     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{1245     \textcolor{keywordtype}{size\_t} cchSrc;}
\DoxyCodeLine{1246     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{1247 }
\DoxyCodeLine{1248     cchDest = cbDest / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{1249     cchSrc = cbSrc / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{1250 }
\DoxyCodeLine{1251     \textcolor{keywordflow}{if} ((cchDest > STRSAFE\_MAX\_CCH) ||}
\DoxyCodeLine{1252         (cchSrc > STRSAFE\_MAX\_CCH))}
\DoxyCodeLine{1253     \{}
\DoxyCodeLine{1254         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{1255     \}}
\DoxyCodeLine{1256     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1257     \{}
\DoxyCodeLine{1258         hr = StringCopyNExWorkerW(pszDest, cchDest, cbDest, pszSrc, cchSrc, ppszDestEnd, \&cchRemaining, dwFlags);}
\DoxyCodeLine{1259     \}}
\DoxyCodeLine{1260 }
\DoxyCodeLine{1261     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{1262     \{}
\DoxyCodeLine{1263         \textcolor{keywordflow}{if} (pcbRemaining)}
\DoxyCodeLine{1264         \{}
\DoxyCodeLine{1265             \textcolor{comment}{// safe to multiply cchRemaining * sizeof(wchar\_t) since cchRemaining < STRSAFE\_MAX\_CCH and sizeof(wchar\_t) is 2}}
\DoxyCodeLine{1266             *pcbRemaining = (cchRemaining * \textcolor{keyword}{sizeof}(wchar\_t)) + (cbDest \% \textcolor{keyword}{sizeof}(wchar\_t));}
\DoxyCodeLine{1267         \}}
\DoxyCodeLine{1268     \}}
\DoxyCodeLine{1269 }
\DoxyCodeLine{1270     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{1271 \}}
\DoxyCodeLine{1272 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{1273 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{1274 }
\DoxyCodeLine{1275 }
\DoxyCodeLine{1276 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{1277 \textcolor{comment}{/*++}}
\DoxyCodeLine{1278 \textcolor{comment}{}}
\DoxyCodeLine{1279 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{1280 \textcolor{comment}{StringCchCat(}}
\DoxyCodeLine{1281 \textcolor{comment}{    IN OUT LPTSTR  pszDest,}}
\DoxyCodeLine{1282 \textcolor{comment}{    IN     size\_t  cchDest,}}
\DoxyCodeLine{1283 \textcolor{comment}{    IN     LPCTSTR pszSrc}}
\DoxyCodeLine{1284 \textcolor{comment}{    );}}
\DoxyCodeLine{1285 \textcolor{comment}{}}
\DoxyCodeLine{1286 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{1287 \textcolor{comment}{}}
\DoxyCodeLine{1288 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strcat'.}}
\DoxyCodeLine{1289 \textcolor{comment}{    The size of the destination buffer (in characters) is a parameter and this}}
\DoxyCodeLine{1290 \textcolor{comment}{    function will not write past the end of this buffer and it will ALWAYS}}
\DoxyCodeLine{1291 \textcolor{comment}{    null terminate the destination buffer (unless it is zero length).}}
\DoxyCodeLine{1292 \textcolor{comment}{}}
\DoxyCodeLine{1293 \textcolor{comment}{    This function returns a hresult, and not a pointer.  It returns}}
\DoxyCodeLine{1294 \textcolor{comment}{    S\_OK if the string was concatenated without truncation and null terminated,}}
\DoxyCodeLine{1295 \textcolor{comment}{    otherwise it will return a failure code. In failure cases as much of pszSrc}}
\DoxyCodeLine{1296 \textcolor{comment}{    will be appended to pszDest as possible, and pszDest will be null}}
\DoxyCodeLine{1297 \textcolor{comment}{    terminated.}}
\DoxyCodeLine{1298 \textcolor{comment}{}}
\DoxyCodeLine{1299 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{1300 \textcolor{comment}{}}
\DoxyCodeLine{1301 \textcolor{comment}{    pszDest     -\/  destination string which must be null terminated}}
\DoxyCodeLine{1302 \textcolor{comment}{}}
\DoxyCodeLine{1303 \textcolor{comment}{    cchDest     -\/  size of destination buffer in characters.}}
\DoxyCodeLine{1304 \textcolor{comment}{                   length must be = (\_tcslen(pszDest) + \_tcslen(pszSrc) + 1)}}
\DoxyCodeLine{1305 \textcolor{comment}{                   to hold all of the combine string plus the null}}
\DoxyCodeLine{1306 \textcolor{comment}{                   terminator}}
\DoxyCodeLine{1307 \textcolor{comment}{}}
\DoxyCodeLine{1308 \textcolor{comment}{    pszSrc      -\/  source string which must be null terminated}}
\DoxyCodeLine{1309 \textcolor{comment}{}}
\DoxyCodeLine{1310 \textcolor{comment}{Notes:}}
\DoxyCodeLine{1311 \textcolor{comment}{    Behavior is undefined if source and destination strings overlap.}}
\DoxyCodeLine{1312 \textcolor{comment}{}}
\DoxyCodeLine{1313 \textcolor{comment}{    pszDest and pszSrc should not be NULL.  See StringCchCatEx if you require}}
\DoxyCodeLine{1314 \textcolor{comment}{    the handling of NULL values.}}
\DoxyCodeLine{1315 \textcolor{comment}{}}
\DoxyCodeLine{1316 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{1317 \textcolor{comment}{}}
\DoxyCodeLine{1318 \textcolor{comment}{    S\_OK           -\/   if there was source data and it was all concatenated and}}
\DoxyCodeLine{1319 \textcolor{comment}{                       the resultant dest string was null terminated}}
\DoxyCodeLine{1320 \textcolor{comment}{}}
\DoxyCodeLine{1321 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{1322 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{1323 \textcolor{comment}{}}
\DoxyCodeLine{1324 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{1325 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{1326 \textcolor{comment}{                   -\/   this return value is an indication that the operation}}
\DoxyCodeLine{1327 \textcolor{comment}{                       failed due to insufficient space. When this error occurs,}}
\DoxyCodeLine{1328 \textcolor{comment}{                       the destination buffer is modified to contain a truncated}}
\DoxyCodeLine{1329 \textcolor{comment}{                       version of the ideal result and is null terminated. This}}
\DoxyCodeLine{1330 \textcolor{comment}{                       is useful for situations where truncation is ok.}}
\DoxyCodeLine{1331 \textcolor{comment}{}}
\DoxyCodeLine{1332 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{1333 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{1334 \textcolor{comment}{}}
\DoxyCodeLine{1335 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{1336 }
\DoxyCodeLine{1337 STRSAFEAPI StringCchCatA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc);}
\DoxyCodeLine{1338 STRSAFEAPI StringCchCatW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc);}
\DoxyCodeLine{1339 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{1340 \textcolor{preprocessor}{\#define StringCchCat  StringCchCatW}}
\DoxyCodeLine{1341 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1342 \textcolor{preprocessor}{\#define StringCchCat  StringCchCatA}}
\DoxyCodeLine{1343 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{1344 }
\DoxyCodeLine{1345 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{1346 STRSAFEAPI StringCchCatA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc)}
\DoxyCodeLine{1347 \{}
\DoxyCodeLine{1348     HRESULT hr;}
\DoxyCodeLine{1349 }
\DoxyCodeLine{1350     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{1351     \{}
\DoxyCodeLine{1352         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{1353     \}}
\DoxyCodeLine{1354     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1355     \{}
\DoxyCodeLine{1356         hr = StringCatWorkerA(pszDest, cchDest, pszSrc);}
\DoxyCodeLine{1357     \}}
\DoxyCodeLine{1358 }
\DoxyCodeLine{1359     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{1360 \}}
\DoxyCodeLine{1361 }
\DoxyCodeLine{1362 STRSAFEAPI StringCchCatW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc)}
\DoxyCodeLine{1363 \{}
\DoxyCodeLine{1364     HRESULT hr;}
\DoxyCodeLine{1365 }
\DoxyCodeLine{1366     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{1367     \{}
\DoxyCodeLine{1368         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{1369     \}}
\DoxyCodeLine{1370     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1371     \{}
\DoxyCodeLine{1372         hr = StringCatWorkerW(pszDest, cchDest, pszSrc);}
\DoxyCodeLine{1373     \}}
\DoxyCodeLine{1374 }
\DoxyCodeLine{1375     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{1376 \}}
\DoxyCodeLine{1377 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{1378 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{1379 }
\DoxyCodeLine{1380 }
\DoxyCodeLine{1381 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{1382 \textcolor{comment}{/*++}}
\DoxyCodeLine{1383 \textcolor{comment}{}}
\DoxyCodeLine{1384 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{1385 \textcolor{comment}{StringCbCat(}}
\DoxyCodeLine{1386 \textcolor{comment}{    IN OUT LPTSTR  pszDest,}}
\DoxyCodeLine{1387 \textcolor{comment}{    IN     size\_t  cbDest,}}
\DoxyCodeLine{1388 \textcolor{comment}{    IN     LPCTSTR pszSrc}}
\DoxyCodeLine{1389 \textcolor{comment}{    );}}
\DoxyCodeLine{1390 \textcolor{comment}{}}
\DoxyCodeLine{1391 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{1392 \textcolor{comment}{}}
\DoxyCodeLine{1393 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strcat'.}}
\DoxyCodeLine{1394 \textcolor{comment}{    The size of the destination buffer (in bytes) is a parameter and this}}
\DoxyCodeLine{1395 \textcolor{comment}{    function will not write past the end of this buffer and it will ALWAYS}}
\DoxyCodeLine{1396 \textcolor{comment}{    null terminate the destination buffer (unless it is zero length).}}
\DoxyCodeLine{1397 \textcolor{comment}{}}
\DoxyCodeLine{1398 \textcolor{comment}{    This function returns a hresult, and not a pointer.  It returns}}
\DoxyCodeLine{1399 \textcolor{comment}{    S\_OK if the string was concatenated without truncation and null terminated,}}
\DoxyCodeLine{1400 \textcolor{comment}{    otherwise it will return a failure code. In failure cases as much of pszSrc}}
\DoxyCodeLine{1401 \textcolor{comment}{    will be appended to pszDest as possible, and pszDest will be null}}
\DoxyCodeLine{1402 \textcolor{comment}{    terminated.}}
\DoxyCodeLine{1403 \textcolor{comment}{}}
\DoxyCodeLine{1404 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{1405 \textcolor{comment}{}}
\DoxyCodeLine{1406 \textcolor{comment}{    pszDest     -\/  destination string which must be null terminated}}
\DoxyCodeLine{1407 \textcolor{comment}{}}
\DoxyCodeLine{1408 \textcolor{comment}{    cbDest      -\/  size of destination buffer in bytes.}}
\DoxyCodeLine{1409 \textcolor{comment}{                   length must be = ((\_tcslen(pszDest) + \_tcslen(pszSrc) + 1) * sizeof(TCHAR)}}
\DoxyCodeLine{1410 \textcolor{comment}{                   to hold all of the combine string plus the null}}
\DoxyCodeLine{1411 \textcolor{comment}{                   terminator}}
\DoxyCodeLine{1412 \textcolor{comment}{}}
\DoxyCodeLine{1413 \textcolor{comment}{    pszSrc      -\/  source string which must be null terminated}}
\DoxyCodeLine{1414 \textcolor{comment}{}}
\DoxyCodeLine{1415 \textcolor{comment}{Notes:}}
\DoxyCodeLine{1416 \textcolor{comment}{    Behavior is undefined if source and destination strings overlap.}}
\DoxyCodeLine{1417 \textcolor{comment}{}}
\DoxyCodeLine{1418 \textcolor{comment}{    pszDest and pszSrc should not be NULL.  See StringCbCatEx if you require}}
\DoxyCodeLine{1419 \textcolor{comment}{    the handling of NULL values.}}
\DoxyCodeLine{1420 \textcolor{comment}{}}
\DoxyCodeLine{1421 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{1422 \textcolor{comment}{}}
\DoxyCodeLine{1423 \textcolor{comment}{    S\_OK           -\/   if there was source data and it was all concatenated and}}
\DoxyCodeLine{1424 \textcolor{comment}{                       the resultant dest string was null terminated}}
\DoxyCodeLine{1425 \textcolor{comment}{}}
\DoxyCodeLine{1426 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{1427 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{1428 \textcolor{comment}{}}
\DoxyCodeLine{1429 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{1430 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{1431 \textcolor{comment}{                   -\/   this return value is an indication that the operation}}
\DoxyCodeLine{1432 \textcolor{comment}{                       failed due to insufficient space. When this error occurs,}}
\DoxyCodeLine{1433 \textcolor{comment}{                       the destination buffer is modified to contain a truncated}}
\DoxyCodeLine{1434 \textcolor{comment}{                       version of the ideal result and is null terminated. This}}
\DoxyCodeLine{1435 \textcolor{comment}{                       is useful for situations where truncation is ok.}}
\DoxyCodeLine{1436 \textcolor{comment}{}}
\DoxyCodeLine{1437 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{1438 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{1439 \textcolor{comment}{}}
\DoxyCodeLine{1440 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{1441 }
\DoxyCodeLine{1442 STRSAFEAPI StringCbCatA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc);}
\DoxyCodeLine{1443 STRSAFEAPI StringCbCatW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc);}
\DoxyCodeLine{1444 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{1445 \textcolor{preprocessor}{\#define StringCbCat  StringCbCatW}}
\DoxyCodeLine{1446 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1447 \textcolor{preprocessor}{\#define StringCbCat  StringCbCatA}}
\DoxyCodeLine{1448 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{1449 }
\DoxyCodeLine{1450 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{1451 STRSAFEAPI StringCbCatA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc)}
\DoxyCodeLine{1452 \{}
\DoxyCodeLine{1453     HRESULT hr;}
\DoxyCodeLine{1454     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{1455 }
\DoxyCodeLine{1456     cchDest = cbDest / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{1457 }
\DoxyCodeLine{1458     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{1459     \{}
\DoxyCodeLine{1460         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{1461     \}}
\DoxyCodeLine{1462     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1463     \{}
\DoxyCodeLine{1464         hr = StringCatWorkerA(pszDest, cchDest, pszSrc);}
\DoxyCodeLine{1465     \}}
\DoxyCodeLine{1466 }
\DoxyCodeLine{1467     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{1468 \}}
\DoxyCodeLine{1469 }
\DoxyCodeLine{1470 STRSAFEAPI StringCbCatW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc)}
\DoxyCodeLine{1471 \{}
\DoxyCodeLine{1472     HRESULT hr;}
\DoxyCodeLine{1473     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{1474 }
\DoxyCodeLine{1475     cchDest = cbDest / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{1476 }
\DoxyCodeLine{1477     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{1478     \{}
\DoxyCodeLine{1479         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{1480     \}}
\DoxyCodeLine{1481     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1482     \{}
\DoxyCodeLine{1483         hr = StringCatWorkerW(pszDest, cchDest, pszSrc);}
\DoxyCodeLine{1484     \}}
\DoxyCodeLine{1485 }
\DoxyCodeLine{1486     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{1487 \}}
\DoxyCodeLine{1488 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{1489 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{1490 }
\DoxyCodeLine{1491 }
\DoxyCodeLine{1492 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{1493 \textcolor{comment}{/*++}}
\DoxyCodeLine{1494 \textcolor{comment}{}}
\DoxyCodeLine{1495 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{1496 \textcolor{comment}{StringCchCatEx(}}
\DoxyCodeLine{1497 \textcolor{comment}{    IN OUT LPTSTR  pszDest         OPTIONAL,}}
\DoxyCodeLine{1498 \textcolor{comment}{    IN     size\_t  cchDest,}}
\DoxyCodeLine{1499 \textcolor{comment}{    IN     LPCTSTR pszSrc          OPTIONAL,}}
\DoxyCodeLine{1500 \textcolor{comment}{    OUT    LPTSTR* ppszDestEnd     OPTIONAL,}}
\DoxyCodeLine{1501 \textcolor{comment}{    OUT    size\_t* pcchRemaining   OPTIONAL,}}
\DoxyCodeLine{1502 \textcolor{comment}{    IN     DWORD   dwFlags}}
\DoxyCodeLine{1503 \textcolor{comment}{    );}}
\DoxyCodeLine{1504 \textcolor{comment}{}}
\DoxyCodeLine{1505 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{1506 \textcolor{comment}{}}
\DoxyCodeLine{1507 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strcat' with}}
\DoxyCodeLine{1508 \textcolor{comment}{    some additional parameters.  In addition to functionality provided by}}
\DoxyCodeLine{1509 \textcolor{comment}{    StringCchCat, this routine also returns a pointer to the end of the}}
\DoxyCodeLine{1510 \textcolor{comment}{    destination string and the number of characters left in the destination string}}
\DoxyCodeLine{1511 \textcolor{comment}{    including the null terminator. The flags parameter allows additional controls.}}
\DoxyCodeLine{1512 \textcolor{comment}{}}
\DoxyCodeLine{1513 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{1514 \textcolor{comment}{}}
\DoxyCodeLine{1515 \textcolor{comment}{    pszDest         -\/   destination string which must be null terminated}}
\DoxyCodeLine{1516 \textcolor{comment}{}}
\DoxyCodeLine{1517 \textcolor{comment}{    cchDest         -\/   size of destination buffer in characters}}
\DoxyCodeLine{1518 \textcolor{comment}{                        length must be (\_tcslen(pszDest) + \_tcslen(pszSrc) + 1)}}
\DoxyCodeLine{1519 \textcolor{comment}{                        to hold all of the combine string plus the null}}
\DoxyCodeLine{1520 \textcolor{comment}{                        terminator.}}
\DoxyCodeLine{1521 \textcolor{comment}{}}
\DoxyCodeLine{1522 \textcolor{comment}{    pszSrc          -\/   source string which must be null terminated}}
\DoxyCodeLine{1523 \textcolor{comment}{}}
\DoxyCodeLine{1524 \textcolor{comment}{    ppszDestEnd     -\/   if ppszDestEnd is non-\/null, the function will return a}}
\DoxyCodeLine{1525 \textcolor{comment}{                        pointer to the end of the destination string.  If the}}
\DoxyCodeLine{1526 \textcolor{comment}{                        function appended any data, the result will point to the}}
\DoxyCodeLine{1527 \textcolor{comment}{                        null termination character}}
\DoxyCodeLine{1528 \textcolor{comment}{}}
\DoxyCodeLine{1529 \textcolor{comment}{    pcchRemaining   -\/   if pcchRemaining is non-\/null, the function will return the}}
\DoxyCodeLine{1530 \textcolor{comment}{                        number of characters left in the destination string,}}
\DoxyCodeLine{1531 \textcolor{comment}{                        including the null terminator}}
\DoxyCodeLine{1532 \textcolor{comment}{}}
\DoxyCodeLine{1533 \textcolor{comment}{    dwFlags         -\/   controls some details of the string copy:}}
\DoxyCodeLine{1534 \textcolor{comment}{}}
\DoxyCodeLine{1535 \textcolor{comment}{        STRSAFE\_FILL\_BEHIND\_NULL}}
\DoxyCodeLine{1536 \textcolor{comment}{                    if the function succeeds, the low byte of dwFlags will be}}
\DoxyCodeLine{1537 \textcolor{comment}{                    used to fill the uninitialize part of destination buffer}}
\DoxyCodeLine{1538 \textcolor{comment}{                    behind the null terminator}}
\DoxyCodeLine{1539 \textcolor{comment}{}}
\DoxyCodeLine{1540 \textcolor{comment}{        STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{1541 \textcolor{comment}{                    treat NULL string pointers like empty strings (TEXT("{}"{})).}}
\DoxyCodeLine{1542 \textcolor{comment}{                    this flag is useful for emulating functions like lstrcat}}
\DoxyCodeLine{1543 \textcolor{comment}{}}
\DoxyCodeLine{1544 \textcolor{comment}{        STRSAFE\_FILL\_ON\_FAILURE}}
\DoxyCodeLine{1545 \textcolor{comment}{                    if the function fails, the low byte of dwFlags will be}}
\DoxyCodeLine{1546 \textcolor{comment}{                    used to fill all of the destination buffer, and it will}}
\DoxyCodeLine{1547 \textcolor{comment}{                    be null terminated. This will overwrite any pre-\/existing}}
\DoxyCodeLine{1548 \textcolor{comment}{                    or truncated string}}
\DoxyCodeLine{1549 \textcolor{comment}{}}
\DoxyCodeLine{1550 \textcolor{comment}{        STRSAFE\_NULL\_ON\_FAILURE}}
\DoxyCodeLine{1551 \textcolor{comment}{                    if the function fails, the destination buffer will be set}}
\DoxyCodeLine{1552 \textcolor{comment}{                    to the empty string. This will overwrite any pre-\/existing or}}
\DoxyCodeLine{1553 \textcolor{comment}{                    truncated string}}
\DoxyCodeLine{1554 \textcolor{comment}{}}
\DoxyCodeLine{1555 \textcolor{comment}{        STRSAFE\_NO\_TRUNCATION}}
\DoxyCodeLine{1556 \textcolor{comment}{                    if the function returns STRSAFE\_E\_INSUFFICIENT\_BUFFER, pszDest}}
\DoxyCodeLine{1557 \textcolor{comment}{                    will not contain a truncated string, it will remain unchanged.}}
\DoxyCodeLine{1558 \textcolor{comment}{}}
\DoxyCodeLine{1559 \textcolor{comment}{Notes:}}
\DoxyCodeLine{1560 \textcolor{comment}{    Behavior is undefined if source and destination strings overlap.}}
\DoxyCodeLine{1561 \textcolor{comment}{}}
\DoxyCodeLine{1562 \textcolor{comment}{    pszDest and pszSrc should not be NULL unless the STRSAFE\_IGNORE\_NULLS flag}}
\DoxyCodeLine{1563 \textcolor{comment}{    is specified.  If STRSAFE\_IGNORE\_NULLS is passed, both pszDest and pszSrc}}
\DoxyCodeLine{1564 \textcolor{comment}{    may be NULL.  An error may still be returned even though NULLS are ignored}}
\DoxyCodeLine{1565 \textcolor{comment}{    due to insufficient space.}}
\DoxyCodeLine{1566 \textcolor{comment}{}}
\DoxyCodeLine{1567 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{1568 \textcolor{comment}{}}
\DoxyCodeLine{1569 \textcolor{comment}{    S\_OK           -\/   if there was source data and it was all concatenated and}}
\DoxyCodeLine{1570 \textcolor{comment}{                       the resultant dest string was null terminated}}
\DoxyCodeLine{1571 \textcolor{comment}{}}
\DoxyCodeLine{1572 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{1573 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{1574 \textcolor{comment}{}}
\DoxyCodeLine{1575 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{1576 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{1577 \textcolor{comment}{                   -\/   this return value is an indication that the operation}}
\DoxyCodeLine{1578 \textcolor{comment}{                       failed due to insufficient space. When this error}}
\DoxyCodeLine{1579 \textcolor{comment}{                       occurs, the destination buffer is modified to contain}}
\DoxyCodeLine{1580 \textcolor{comment}{                       a truncated version of the ideal result and is null}}
\DoxyCodeLine{1581 \textcolor{comment}{                       terminated. This is useful for situations where}}
\DoxyCodeLine{1582 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{1583 \textcolor{comment}{}}
\DoxyCodeLine{1584 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{1585 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{1586 \textcolor{comment}{}}
\DoxyCodeLine{1587 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{1588 }
\DoxyCodeLine{1589 STRSAFEAPI StringCchCatExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{1590 STRSAFEAPI StringCchCatExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{1591 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{1592 \textcolor{preprocessor}{\#define StringCchCatEx  StringCchCatExW}}
\DoxyCodeLine{1593 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1594 \textcolor{preprocessor}{\#define StringCchCatEx  StringCchCatExA}}
\DoxyCodeLine{1595 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{1596 }
\DoxyCodeLine{1597 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{1598 STRSAFEAPI StringCchCatExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{1599 \{}
\DoxyCodeLine{1600     HRESULT hr;}
\DoxyCodeLine{1601 }
\DoxyCodeLine{1602     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{1603     \{}
\DoxyCodeLine{1604         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{1605     \}}
\DoxyCodeLine{1606     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1607     \{}
\DoxyCodeLine{1608         \textcolor{keywordtype}{size\_t} cbDest;}
\DoxyCodeLine{1609 }
\DoxyCodeLine{1610         \textcolor{comment}{// safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE\_MAX\_CCH and sizeof(char) is 1}}
\DoxyCodeLine{1611         cbDest = cchDest * \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{1612 }
\DoxyCodeLine{1613         hr = StringCatExWorkerA(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, pcchRemaining, dwFlags);}
\DoxyCodeLine{1614     \}}
\DoxyCodeLine{1615 }
\DoxyCodeLine{1616     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{1617 \}}
\DoxyCodeLine{1618 }
\DoxyCodeLine{1619 STRSAFEAPI StringCchCatExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{1620 \{}
\DoxyCodeLine{1621     HRESULT hr;}
\DoxyCodeLine{1622 }
\DoxyCodeLine{1623     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{1624     \{}
\DoxyCodeLine{1625         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{1626     \}}
\DoxyCodeLine{1627     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1628     \{}
\DoxyCodeLine{1629         \textcolor{keywordtype}{size\_t} cbDest;}
\DoxyCodeLine{1630 }
\DoxyCodeLine{1631         \textcolor{comment}{// safe to multiply cchDest * sizeof(wchar\_t) since cchDest < STRSAFE\_MAX\_CCH and sizeof(wchar\_t) is 2}}
\DoxyCodeLine{1632         cbDest = cchDest * \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{1633 }
\DoxyCodeLine{1634         hr = StringCatExWorkerW(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, pcchRemaining, dwFlags);}
\DoxyCodeLine{1635     \}}
\DoxyCodeLine{1636 }
\DoxyCodeLine{1637     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{1638 \}}
\DoxyCodeLine{1639 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{1640 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{1641 }
\DoxyCodeLine{1642 }
\DoxyCodeLine{1643 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{1644 \textcolor{comment}{/*++}}
\DoxyCodeLine{1645 \textcolor{comment}{}}
\DoxyCodeLine{1646 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{1647 \textcolor{comment}{StringCbCatEx(}}
\DoxyCodeLine{1648 \textcolor{comment}{    IN OUT LPTSTR  pszDest         OPTIONAL,}}
\DoxyCodeLine{1649 \textcolor{comment}{    IN     size\_t  cbDest,}}
\DoxyCodeLine{1650 \textcolor{comment}{    IN     LPCTSTR pszSrc          OPTIONAL,}}
\DoxyCodeLine{1651 \textcolor{comment}{    OUT    LPTSTR* ppszDestEnd     OPTIONAL,}}
\DoxyCodeLine{1652 \textcolor{comment}{    OUT    size\_t* pcbRemaining    OPTIONAL,}}
\DoxyCodeLine{1653 \textcolor{comment}{    IN     DWORD   dwFlags}}
\DoxyCodeLine{1654 \textcolor{comment}{    );}}
\DoxyCodeLine{1655 \textcolor{comment}{}}
\DoxyCodeLine{1656 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{1657 \textcolor{comment}{}}
\DoxyCodeLine{1658 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strcat' with}}
\DoxyCodeLine{1659 \textcolor{comment}{    some additional parameters.  In addition to functionality provided by}}
\DoxyCodeLine{1660 \textcolor{comment}{    StringCbCat, this routine also returns a pointer to the end of the}}
\DoxyCodeLine{1661 \textcolor{comment}{    destination string and the number of bytes left in the destination string}}
\DoxyCodeLine{1662 \textcolor{comment}{    including the null terminator. The flags parameter allows additional controls.}}
\DoxyCodeLine{1663 \textcolor{comment}{}}
\DoxyCodeLine{1664 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{1665 \textcolor{comment}{}}
\DoxyCodeLine{1666 \textcolor{comment}{    pszDest         -\/   destination string which must be null terminated}}
\DoxyCodeLine{1667 \textcolor{comment}{}}
\DoxyCodeLine{1668 \textcolor{comment}{    cbDest          -\/   size of destination buffer in bytes.}}
\DoxyCodeLine{1669 \textcolor{comment}{                        length must be ((\_tcslen(pszDest) + \_tcslen(pszSrc) + 1) * sizeof(TCHAR)}}
\DoxyCodeLine{1670 \textcolor{comment}{                        to hold all of the combine string plus the null}}
\DoxyCodeLine{1671 \textcolor{comment}{                        terminator.}}
\DoxyCodeLine{1672 \textcolor{comment}{}}
\DoxyCodeLine{1673 \textcolor{comment}{    pszSrc          -\/   source string which must be null terminated}}
\DoxyCodeLine{1674 \textcolor{comment}{}}
\DoxyCodeLine{1675 \textcolor{comment}{    ppszDestEnd     -\/   if ppszDestEnd is non-\/null, the function will return a}}
\DoxyCodeLine{1676 \textcolor{comment}{                        pointer to the end of the destination string.  If the}}
\DoxyCodeLine{1677 \textcolor{comment}{                        function appended any data, the result will point to the}}
\DoxyCodeLine{1678 \textcolor{comment}{                        null termination character}}
\DoxyCodeLine{1679 \textcolor{comment}{}}
\DoxyCodeLine{1680 \textcolor{comment}{    pcbRemaining    -\/   if pcbRemaining is non-\/null, the function will return}}
\DoxyCodeLine{1681 \textcolor{comment}{                        the number of bytes left in the destination string,}}
\DoxyCodeLine{1682 \textcolor{comment}{                        including the null terminator}}
\DoxyCodeLine{1683 \textcolor{comment}{}}
\DoxyCodeLine{1684 \textcolor{comment}{    dwFlags         -\/   controls some details of the string copy:}}
\DoxyCodeLine{1685 \textcolor{comment}{}}
\DoxyCodeLine{1686 \textcolor{comment}{        STRSAFE\_FILL\_BEHIND\_NULL}}
\DoxyCodeLine{1687 \textcolor{comment}{                    if the function succeeds, the low byte of dwFlags will be}}
\DoxyCodeLine{1688 \textcolor{comment}{                    used to fill the uninitialize part of destination buffer}}
\DoxyCodeLine{1689 \textcolor{comment}{                    behind the null terminator}}
\DoxyCodeLine{1690 \textcolor{comment}{}}
\DoxyCodeLine{1691 \textcolor{comment}{        STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{1692 \textcolor{comment}{                    treat NULL string pointers like empty strings (TEXT("{}"{})).}}
\DoxyCodeLine{1693 \textcolor{comment}{                    this flag is useful for emulating functions like lstrcat}}
\DoxyCodeLine{1694 \textcolor{comment}{}}
\DoxyCodeLine{1695 \textcolor{comment}{        STRSAFE\_FILL\_ON\_FAILURE}}
\DoxyCodeLine{1696 \textcolor{comment}{                    if the function fails, the low byte of dwFlags will be}}
\DoxyCodeLine{1697 \textcolor{comment}{                    used to fill all of the destination buffer, and it will}}
\DoxyCodeLine{1698 \textcolor{comment}{                    be null terminated. This will overwrite any pre-\/existing}}
\DoxyCodeLine{1699 \textcolor{comment}{                    or truncated string}}
\DoxyCodeLine{1700 \textcolor{comment}{}}
\DoxyCodeLine{1701 \textcolor{comment}{        STRSAFE\_NULL\_ON\_FAILURE}}
\DoxyCodeLine{1702 \textcolor{comment}{                    if the function fails, the destination buffer will be set}}
\DoxyCodeLine{1703 \textcolor{comment}{                    to the empty string. This will overwrite any pre-\/existing or}}
\DoxyCodeLine{1704 \textcolor{comment}{                    truncated string}}
\DoxyCodeLine{1705 \textcolor{comment}{}}
\DoxyCodeLine{1706 \textcolor{comment}{        STRSAFE\_NO\_TRUNCATION}}
\DoxyCodeLine{1707 \textcolor{comment}{                    if the function returns STRSAFE\_E\_INSUFFICIENT\_BUFFER, pszDest}}
\DoxyCodeLine{1708 \textcolor{comment}{                    will not contain a truncated string, it will remain unchanged.}}
\DoxyCodeLine{1709 \textcolor{comment}{}}
\DoxyCodeLine{1710 \textcolor{comment}{Notes:}}
\DoxyCodeLine{1711 \textcolor{comment}{    Behavior is undefined if source and destination strings overlap.}}
\DoxyCodeLine{1712 \textcolor{comment}{}}
\DoxyCodeLine{1713 \textcolor{comment}{    pszDest and pszSrc should not be NULL unless the STRSAFE\_IGNORE\_NULLS flag}}
\DoxyCodeLine{1714 \textcolor{comment}{    is specified.  If STRSAFE\_IGNORE\_NULLS is passed, both pszDest and pszSrc}}
\DoxyCodeLine{1715 \textcolor{comment}{    may be NULL.  An error may still be returned even though NULLS are ignored}}
\DoxyCodeLine{1716 \textcolor{comment}{    due to insufficient space.}}
\DoxyCodeLine{1717 \textcolor{comment}{}}
\DoxyCodeLine{1718 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{1719 \textcolor{comment}{}}
\DoxyCodeLine{1720 \textcolor{comment}{    S\_OK           -\/   if there was source data and it was all concatenated}}
\DoxyCodeLine{1721 \textcolor{comment}{                       and the resultant dest string was null terminated}}
\DoxyCodeLine{1722 \textcolor{comment}{}}
\DoxyCodeLine{1723 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{1724 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{1725 \textcolor{comment}{}}
\DoxyCodeLine{1726 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{1727 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{1728 \textcolor{comment}{                   -\/   this return value is an indication that the operation}}
\DoxyCodeLine{1729 \textcolor{comment}{                       failed due to insufficient space. When this error}}
\DoxyCodeLine{1730 \textcolor{comment}{                       occurs, the destination buffer is modified to contain}}
\DoxyCodeLine{1731 \textcolor{comment}{                       a truncated version of the ideal result and is null}}
\DoxyCodeLine{1732 \textcolor{comment}{                       terminated. This is useful for situations where}}
\DoxyCodeLine{1733 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{1734 \textcolor{comment}{}}
\DoxyCodeLine{1735 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{1736 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{1737 \textcolor{comment}{}}
\DoxyCodeLine{1738 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{1739 }
\DoxyCodeLine{1740 STRSAFEAPI StringCbCatExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{1741 STRSAFEAPI StringCbCatExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{1742 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{1743 \textcolor{preprocessor}{\#define StringCbCatEx  StringCbCatExW}}
\DoxyCodeLine{1744 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1745 \textcolor{preprocessor}{\#define StringCbCatEx  StringCbCatExA}}
\DoxyCodeLine{1746 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{1747 }
\DoxyCodeLine{1748 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{1749 STRSAFEAPI StringCbCatExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{1750 \{}
\DoxyCodeLine{1751     HRESULT hr;}
\DoxyCodeLine{1752     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{1753     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{1754 }
\DoxyCodeLine{1755     cchDest = cbDest / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{1756 }
\DoxyCodeLine{1757     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{1758     \{}
\DoxyCodeLine{1759         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{1760     \}}
\DoxyCodeLine{1761     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1762     \{}
\DoxyCodeLine{1763         hr = StringCatExWorkerA(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, \&cchRemaining, dwFlags);}
\DoxyCodeLine{1764     \}}
\DoxyCodeLine{1765 }
\DoxyCodeLine{1766     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{1767     \{}
\DoxyCodeLine{1768         \textcolor{keywordflow}{if} (pcbRemaining)}
\DoxyCodeLine{1769         \{}
\DoxyCodeLine{1770             \textcolor{comment}{// safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE\_MAX\_CCH and sizeof(char) is 1}}
\DoxyCodeLine{1771             *pcbRemaining = (cchRemaining * \textcolor{keyword}{sizeof}(char)) + (cbDest \% \textcolor{keyword}{sizeof}(char));}
\DoxyCodeLine{1772         \}}
\DoxyCodeLine{1773     \}}
\DoxyCodeLine{1774 }
\DoxyCodeLine{1775     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{1776 \}}
\DoxyCodeLine{1777 }
\DoxyCodeLine{1778 STRSAFEAPI StringCbCatExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{1779 \{}
\DoxyCodeLine{1780     HRESULT hr;}
\DoxyCodeLine{1781     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{1782     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{1783 }
\DoxyCodeLine{1784     cchDest = cbDest / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{1785 }
\DoxyCodeLine{1786     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{1787     \{}
\DoxyCodeLine{1788         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{1789     \}}
\DoxyCodeLine{1790     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1791     \{}
\DoxyCodeLine{1792         hr = StringCatExWorkerW(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, \&cchRemaining, dwFlags);}
\DoxyCodeLine{1793     \}}
\DoxyCodeLine{1794 }
\DoxyCodeLine{1795     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{1796     \{}
\DoxyCodeLine{1797         \textcolor{keywordflow}{if} (pcbRemaining)}
\DoxyCodeLine{1798         \{}
\DoxyCodeLine{1799             \textcolor{comment}{// safe to multiply cchRemaining * sizeof(wchar\_t) since cchRemaining < STRSAFE\_MAX\_CCH and sizeof(wchar\_t) is 2}}
\DoxyCodeLine{1800             *pcbRemaining = (cchRemaining * \textcolor{keyword}{sizeof}(wchar\_t)) + (cbDest \% \textcolor{keyword}{sizeof}(wchar\_t));}
\DoxyCodeLine{1801         \}}
\DoxyCodeLine{1802     \}}
\DoxyCodeLine{1803 }
\DoxyCodeLine{1804     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{1805 \}}
\DoxyCodeLine{1806 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{1807 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{1808 }
\DoxyCodeLine{1809 }
\DoxyCodeLine{1810 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{1811 \textcolor{comment}{/*++}}
\DoxyCodeLine{1812 \textcolor{comment}{}}
\DoxyCodeLine{1813 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{1814 \textcolor{comment}{StringCchCatN(}}
\DoxyCodeLine{1815 \textcolor{comment}{    IN OUT LPTSTR  pszDest,}}
\DoxyCodeLine{1816 \textcolor{comment}{    IN     size\_t  cchDest,}}
\DoxyCodeLine{1817 \textcolor{comment}{    IN     LPCTSTR pszSrc,}}
\DoxyCodeLine{1818 \textcolor{comment}{    IN     size\_t  cchMaxAppend}}
\DoxyCodeLine{1819 \textcolor{comment}{    );}}
\DoxyCodeLine{1820 \textcolor{comment}{}}
\DoxyCodeLine{1821 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{1822 \textcolor{comment}{}}
\DoxyCodeLine{1823 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strncat'.}}
\DoxyCodeLine{1824 \textcolor{comment}{    The size of the destination buffer (in characters) is a parameter as well as}}
\DoxyCodeLine{1825 \textcolor{comment}{    the maximum number of characters to append, excluding the null terminator.}}
\DoxyCodeLine{1826 \textcolor{comment}{    This function will not write past the end of the destination buffer and it will}}
\DoxyCodeLine{1827 \textcolor{comment}{    ALWAYS null terminate pszDest (unless it is zero length).}}
\DoxyCodeLine{1828 \textcolor{comment}{}}
\DoxyCodeLine{1829 \textcolor{comment}{    This function returns a hresult, and not a pointer.  It returns}}
\DoxyCodeLine{1830 \textcolor{comment}{    S\_OK if all of pszSrc or the first cchMaxAppend characters were appended}}
\DoxyCodeLine{1831 \textcolor{comment}{    to the destination string and it was null terminated, otherwise it will}}
\DoxyCodeLine{1832 \textcolor{comment}{    return a failure code. In failure cases as much of pszSrc will be appended}}
\DoxyCodeLine{1833 \textcolor{comment}{    to pszDest as possible, and pszDest will be null terminated.}}
\DoxyCodeLine{1834 \textcolor{comment}{}}
\DoxyCodeLine{1835 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{1836 \textcolor{comment}{}}
\DoxyCodeLine{1837 \textcolor{comment}{    pszDest         -\/   destination string which must be null terminated}}
\DoxyCodeLine{1838 \textcolor{comment}{}}
\DoxyCodeLine{1839 \textcolor{comment}{    cchDest         -\/   size of destination buffer in characters.}}
\DoxyCodeLine{1840 \textcolor{comment}{                        length must be (\_tcslen(pszDest) + min(cchMaxAppend, \_tcslen(pszSrc)) + 1)}}
\DoxyCodeLine{1841 \textcolor{comment}{                        to hold all of the combine string plus the null}}
\DoxyCodeLine{1842 \textcolor{comment}{                        terminator.}}
\DoxyCodeLine{1843 \textcolor{comment}{}}
\DoxyCodeLine{1844 \textcolor{comment}{    pszSrc          -\/   source string}}
\DoxyCodeLine{1845 \textcolor{comment}{}}
\DoxyCodeLine{1846 \textcolor{comment}{    cchMaxAppend    -\/   maximum number of characters to append}}
\DoxyCodeLine{1847 \textcolor{comment}{}}
\DoxyCodeLine{1848 \textcolor{comment}{Notes:}}
\DoxyCodeLine{1849 \textcolor{comment}{    Behavior is undefined if source and destination strings overlap.}}
\DoxyCodeLine{1850 \textcolor{comment}{}}
\DoxyCodeLine{1851 \textcolor{comment}{    pszDest and pszSrc should not be NULL. See StringCchCatNEx if you require}}
\DoxyCodeLine{1852 \textcolor{comment}{    the handling of NULL values.}}
\DoxyCodeLine{1853 \textcolor{comment}{}}
\DoxyCodeLine{1854 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{1855 \textcolor{comment}{}}
\DoxyCodeLine{1856 \textcolor{comment}{    S\_OK           -\/   if all of pszSrc or the first cchMaxAppend characters}}
\DoxyCodeLine{1857 \textcolor{comment}{                       were concatenated to pszDest and the resultant dest}}
\DoxyCodeLine{1858 \textcolor{comment}{                       string was null terminated}}
\DoxyCodeLine{1859 \textcolor{comment}{}}
\DoxyCodeLine{1860 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{1861 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{1862 \textcolor{comment}{}}
\DoxyCodeLine{1863 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{1864 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{1865 \textcolor{comment}{                   -\/   this return value is an indication that the operation}}
\DoxyCodeLine{1866 \textcolor{comment}{                       failed due to insufficient space. When this error}}
\DoxyCodeLine{1867 \textcolor{comment}{                       occurs, the destination buffer is modified to contain}}
\DoxyCodeLine{1868 \textcolor{comment}{                       a truncated version of the ideal result and is null}}
\DoxyCodeLine{1869 \textcolor{comment}{                       terminated. This is useful for situations where}}
\DoxyCodeLine{1870 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{1871 \textcolor{comment}{}}
\DoxyCodeLine{1872 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{1873 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{1874 \textcolor{comment}{}}
\DoxyCodeLine{1875 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{1876 }
\DoxyCodeLine{1877 STRSAFEAPI StringCchCatNA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cchMaxAppend);}
\DoxyCodeLine{1878 STRSAFEAPI StringCchCatNW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cchMaxAppend);}
\DoxyCodeLine{1879 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{1880 \textcolor{preprocessor}{\#define StringCchCatN  StringCchCatNW}}
\DoxyCodeLine{1881 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1882 \textcolor{preprocessor}{\#define StringCchCatN  StringCchCatNA}}
\DoxyCodeLine{1883 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{1884 }
\DoxyCodeLine{1885 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{1886 STRSAFEAPI StringCchCatNA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cchMaxAppend)}
\DoxyCodeLine{1887 \{}
\DoxyCodeLine{1888     HRESULT hr;}
\DoxyCodeLine{1889 }
\DoxyCodeLine{1890     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{1891     \{}
\DoxyCodeLine{1892         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{1893     \}}
\DoxyCodeLine{1894     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1895     \{}
\DoxyCodeLine{1896         hr = StringCatNWorkerA(pszDest, cchDest, pszSrc, cchMaxAppend);}
\DoxyCodeLine{1897     \}}
\DoxyCodeLine{1898 }
\DoxyCodeLine{1899     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{1900 \}}
\DoxyCodeLine{1901 }
\DoxyCodeLine{1902 STRSAFEAPI StringCchCatNW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cchMaxAppend)}
\DoxyCodeLine{1903 \{}
\DoxyCodeLine{1904     HRESULT hr;}
\DoxyCodeLine{1905 }
\DoxyCodeLine{1906     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{1907     \{}
\DoxyCodeLine{1908         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{1909     \}}
\DoxyCodeLine{1910     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1911     \{}
\DoxyCodeLine{1912         hr = StringCatNWorkerW(pszDest, cchDest, pszSrc, cchMaxAppend);}
\DoxyCodeLine{1913     \}}
\DoxyCodeLine{1914 }
\DoxyCodeLine{1915     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{1916 \}}
\DoxyCodeLine{1917 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{1918 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{1919 }
\DoxyCodeLine{1920 }
\DoxyCodeLine{1921 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{1922 \textcolor{comment}{/*++}}
\DoxyCodeLine{1923 \textcolor{comment}{}}
\DoxyCodeLine{1924 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{1925 \textcolor{comment}{StringCbCatN(}}
\DoxyCodeLine{1926 \textcolor{comment}{    IN OUT LPTSTR  pszDest,}}
\DoxyCodeLine{1927 \textcolor{comment}{    IN     size\_t  cbDest,}}
\DoxyCodeLine{1928 \textcolor{comment}{    IN     LPCTSTR pszSrc,}}
\DoxyCodeLine{1929 \textcolor{comment}{    IN     size\_t  cbMaxAppend}}
\DoxyCodeLine{1930 \textcolor{comment}{    );}}
\DoxyCodeLine{1931 \textcolor{comment}{}}
\DoxyCodeLine{1932 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{1933 \textcolor{comment}{}}
\DoxyCodeLine{1934 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strncat'.}}
\DoxyCodeLine{1935 \textcolor{comment}{    The size of the destination buffer (in bytes) is a parameter as well as}}
\DoxyCodeLine{1936 \textcolor{comment}{    the maximum number of bytes to append, excluding the null terminator.}}
\DoxyCodeLine{1937 \textcolor{comment}{    This function will not write past the end of the destination buffer and it will}}
\DoxyCodeLine{1938 \textcolor{comment}{    ALWAYS null terminate pszDest (unless it is zero length).}}
\DoxyCodeLine{1939 \textcolor{comment}{}}
\DoxyCodeLine{1940 \textcolor{comment}{    This function returns a hresult, and not a pointer.  It returns}}
\DoxyCodeLine{1941 \textcolor{comment}{    S\_OK if all of pszSrc or the first cbMaxAppend bytes were appended}}
\DoxyCodeLine{1942 \textcolor{comment}{    to the destination string and it was null terminated, otherwise it will}}
\DoxyCodeLine{1943 \textcolor{comment}{    return a failure code. In failure cases as much of pszSrc will be appended}}
\DoxyCodeLine{1944 \textcolor{comment}{    to pszDest as possible, and pszDest will be null terminated.}}
\DoxyCodeLine{1945 \textcolor{comment}{}}
\DoxyCodeLine{1946 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{1947 \textcolor{comment}{}}
\DoxyCodeLine{1948 \textcolor{comment}{    pszDest         -\/   destination string which must be null terminated}}
\DoxyCodeLine{1949 \textcolor{comment}{}}
\DoxyCodeLine{1950 \textcolor{comment}{    cbDest          -\/   size of destination buffer in bytes.}}
\DoxyCodeLine{1951 \textcolor{comment}{                        length must be ((\_tcslen(pszDest) + min(cbMaxAppend / sizeof(TCHAR), \_tcslen(pszSrc)) + 1) * sizeof(TCHAR)}}
\DoxyCodeLine{1952 \textcolor{comment}{                        to hold all of the combine string plus the null}}
\DoxyCodeLine{1953 \textcolor{comment}{                        terminator.}}
\DoxyCodeLine{1954 \textcolor{comment}{}}
\DoxyCodeLine{1955 \textcolor{comment}{    pszSrc          -\/   source string}}
\DoxyCodeLine{1956 \textcolor{comment}{}}
\DoxyCodeLine{1957 \textcolor{comment}{    cbMaxAppend     -\/   maximum number of bytes to append}}
\DoxyCodeLine{1958 \textcolor{comment}{}}
\DoxyCodeLine{1959 \textcolor{comment}{Notes:}}
\DoxyCodeLine{1960 \textcolor{comment}{    Behavior is undefined if source and destination strings overlap.}}
\DoxyCodeLine{1961 \textcolor{comment}{}}
\DoxyCodeLine{1962 \textcolor{comment}{    pszDest and pszSrc should not be NULL. See StringCbCatNEx if you require}}
\DoxyCodeLine{1963 \textcolor{comment}{    the handling of NULL values.}}
\DoxyCodeLine{1964 \textcolor{comment}{}}
\DoxyCodeLine{1965 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{1966 \textcolor{comment}{}}
\DoxyCodeLine{1967 \textcolor{comment}{    S\_OK           -\/   if all of pszSrc or the first cbMaxAppend bytes were}}
\DoxyCodeLine{1968 \textcolor{comment}{                       concatenated to pszDest and the resultant dest string}}
\DoxyCodeLine{1969 \textcolor{comment}{                       was null terminated}}
\DoxyCodeLine{1970 \textcolor{comment}{}}
\DoxyCodeLine{1971 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{1972 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{1973 \textcolor{comment}{}}
\DoxyCodeLine{1974 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{1975 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{1976 \textcolor{comment}{                   -\/   this return value is an indication that the operation}}
\DoxyCodeLine{1977 \textcolor{comment}{                       failed due to insufficient space. When this error}}
\DoxyCodeLine{1978 \textcolor{comment}{                       occurs, the destination buffer is modified to contain}}
\DoxyCodeLine{1979 \textcolor{comment}{                       a truncated version of the ideal result and is null}}
\DoxyCodeLine{1980 \textcolor{comment}{                       terminated. This is useful for situations where}}
\DoxyCodeLine{1981 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{1982 \textcolor{comment}{}}
\DoxyCodeLine{1983 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{1984 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{1985 \textcolor{comment}{}}
\DoxyCodeLine{1986 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{1987 }
\DoxyCodeLine{1988 STRSAFEAPI StringCbCatNA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cbMaxAppend);}
\DoxyCodeLine{1989 STRSAFEAPI StringCbCatNW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cbMaxAppend);}
\DoxyCodeLine{1990 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{1991 \textcolor{preprocessor}{\#define StringCbCatN  StringCbCatNW}}
\DoxyCodeLine{1992 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1993 \textcolor{preprocessor}{\#define StringCbCatN  StringCbCatNA}}
\DoxyCodeLine{1994 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{1995 }
\DoxyCodeLine{1996 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{1997 STRSAFEAPI StringCbCatNA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cbMaxAppend)}
\DoxyCodeLine{1998 \{}
\DoxyCodeLine{1999     HRESULT hr;}
\DoxyCodeLine{2000     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{2001 }
\DoxyCodeLine{2002     cchDest = cbDest / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{2003 }
\DoxyCodeLine{2004     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{2005     \{}
\DoxyCodeLine{2006         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{2007     \}}
\DoxyCodeLine{2008     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2009     \{}
\DoxyCodeLine{2010         \textcolor{keywordtype}{size\_t} cchMaxAppend;}
\DoxyCodeLine{2011 }
\DoxyCodeLine{2012         cchMaxAppend = cbMaxAppend / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{2013 }
\DoxyCodeLine{2014         hr = StringCatNWorkerA(pszDest, cchDest, pszSrc, cchMaxAppend);}
\DoxyCodeLine{2015     \}}
\DoxyCodeLine{2016 }
\DoxyCodeLine{2017     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{2018 \}}
\DoxyCodeLine{2019 }
\DoxyCodeLine{2020 STRSAFEAPI StringCbCatNW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cbMaxAppend)}
\DoxyCodeLine{2021 \{}
\DoxyCodeLine{2022     HRESULT hr;}
\DoxyCodeLine{2023     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{2024 }
\DoxyCodeLine{2025     cchDest = cbDest / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{2026 }
\DoxyCodeLine{2027     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{2028     \{}
\DoxyCodeLine{2029         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{2030     \}}
\DoxyCodeLine{2031     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2032     \{}
\DoxyCodeLine{2033         \textcolor{keywordtype}{size\_t} cchMaxAppend;}
\DoxyCodeLine{2034 }
\DoxyCodeLine{2035         cchMaxAppend = cbMaxAppend / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{2036 }
\DoxyCodeLine{2037         hr = StringCatNWorkerW(pszDest, cchDest, pszSrc, cchMaxAppend);}
\DoxyCodeLine{2038     \}}
\DoxyCodeLine{2039 }
\DoxyCodeLine{2040     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{2041 \}}
\DoxyCodeLine{2042 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{2043 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{2044 }
\DoxyCodeLine{2045 }
\DoxyCodeLine{2046 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{2047 \textcolor{comment}{/*++}}
\DoxyCodeLine{2048 \textcolor{comment}{}}
\DoxyCodeLine{2049 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{2050 \textcolor{comment}{StringCchCatNEx(}}
\DoxyCodeLine{2051 \textcolor{comment}{    IN OUT LPTSTR  pszDest         OPTIONAL,}}
\DoxyCodeLine{2052 \textcolor{comment}{    IN     size\_t  cchDest,}}
\DoxyCodeLine{2053 \textcolor{comment}{    IN     LPCTSTR pszSrc          OPTIONAL,}}
\DoxyCodeLine{2054 \textcolor{comment}{    IN     size\_t  cchMaxAppend,}}
\DoxyCodeLine{2055 \textcolor{comment}{    OUT    LPTSTR* ppszDestEnd     OPTIONAL,}}
\DoxyCodeLine{2056 \textcolor{comment}{    OUT    size\_t* pcchRemaining   OPTIONAL,}}
\DoxyCodeLine{2057 \textcolor{comment}{    IN     DWORD   dwFlags}}
\DoxyCodeLine{2058 \textcolor{comment}{    );}}
\DoxyCodeLine{2059 \textcolor{comment}{}}
\DoxyCodeLine{2060 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{2061 \textcolor{comment}{}}
\DoxyCodeLine{2062 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strncat', with}}
\DoxyCodeLine{2063 \textcolor{comment}{    some additional parameters.  In addition to functionality provided by}}
\DoxyCodeLine{2064 \textcolor{comment}{    StringCchCatN, this routine also returns a pointer to the end of the}}
\DoxyCodeLine{2065 \textcolor{comment}{    destination string and the number of characters left in the destination string}}
\DoxyCodeLine{2066 \textcolor{comment}{    including the null terminator. The flags parameter allows additional controls.}}
\DoxyCodeLine{2067 \textcolor{comment}{}}
\DoxyCodeLine{2068 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{2069 \textcolor{comment}{}}
\DoxyCodeLine{2070 \textcolor{comment}{    pszDest         -\/   destination string which must be null terminated}}
\DoxyCodeLine{2071 \textcolor{comment}{}}
\DoxyCodeLine{2072 \textcolor{comment}{    cchDest         -\/   size of destination buffer in characters.}}
\DoxyCodeLine{2073 \textcolor{comment}{                        length must be (\_tcslen(pszDest) + min(cchMaxAppend, \_tcslen(pszSrc)) + 1)}}
\DoxyCodeLine{2074 \textcolor{comment}{                        to hold all of the combine string plus the null}}
\DoxyCodeLine{2075 \textcolor{comment}{                        terminator.}}
\DoxyCodeLine{2076 \textcolor{comment}{}}
\DoxyCodeLine{2077 \textcolor{comment}{    pszSrc          -\/   source string}}
\DoxyCodeLine{2078 \textcolor{comment}{}}
\DoxyCodeLine{2079 \textcolor{comment}{    cchMaxAppend    -\/   maximum number of characters to append}}
\DoxyCodeLine{2080 \textcolor{comment}{}}
\DoxyCodeLine{2081 \textcolor{comment}{    ppszDestEnd     -\/   if ppszDestEnd is non-\/null, the function will return a}}
\DoxyCodeLine{2082 \textcolor{comment}{                        pointer to the end of the destination string.  If the}}
\DoxyCodeLine{2083 \textcolor{comment}{                        function appended any data, the result will point to the}}
\DoxyCodeLine{2084 \textcolor{comment}{                        null termination character}}
\DoxyCodeLine{2085 \textcolor{comment}{}}
\DoxyCodeLine{2086 \textcolor{comment}{    pcchRemaining   -\/   if pcchRemaining is non-\/null, the function will return the}}
\DoxyCodeLine{2087 \textcolor{comment}{                        number of characters left in the destination string,}}
\DoxyCodeLine{2088 \textcolor{comment}{                        including the null terminator}}
\DoxyCodeLine{2089 \textcolor{comment}{}}
\DoxyCodeLine{2090 \textcolor{comment}{    dwFlags         -\/   controls some details of the string copy:}}
\DoxyCodeLine{2091 \textcolor{comment}{}}
\DoxyCodeLine{2092 \textcolor{comment}{        STRSAFE\_FILL\_BEHIND\_NULL}}
\DoxyCodeLine{2093 \textcolor{comment}{                    if the function succeeds, the low byte of dwFlags will be}}
\DoxyCodeLine{2094 \textcolor{comment}{                    used to fill the uninitialize part of destination buffer}}
\DoxyCodeLine{2095 \textcolor{comment}{                    behind the null terminator}}
\DoxyCodeLine{2096 \textcolor{comment}{}}
\DoxyCodeLine{2097 \textcolor{comment}{        STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{2098 \textcolor{comment}{                    treat NULL string pointers like empty strings (TEXT("{}"{}))}}
\DoxyCodeLine{2099 \textcolor{comment}{}}
\DoxyCodeLine{2100 \textcolor{comment}{        STRSAFE\_FILL\_ON\_FAILURE}}
\DoxyCodeLine{2101 \textcolor{comment}{                    if the function fails, the low byte of dwFlags will be}}
\DoxyCodeLine{2102 \textcolor{comment}{                    used to fill all of the destination buffer, and it will}}
\DoxyCodeLine{2103 \textcolor{comment}{                    be null terminated. This will overwrite any pre-\/existing}}
\DoxyCodeLine{2104 \textcolor{comment}{                    or truncated string}}
\DoxyCodeLine{2105 \textcolor{comment}{}}
\DoxyCodeLine{2106 \textcolor{comment}{        STRSAFE\_NULL\_ON\_FAILURE}}
\DoxyCodeLine{2107 \textcolor{comment}{                    if the function fails, the destination buffer will be set}}
\DoxyCodeLine{2108 \textcolor{comment}{                    to the empty string. This will overwrite any pre-\/existing or}}
\DoxyCodeLine{2109 \textcolor{comment}{                    truncated string}}
\DoxyCodeLine{2110 \textcolor{comment}{}}
\DoxyCodeLine{2111 \textcolor{comment}{        STRSAFE\_NO\_TRUNCATION}}
\DoxyCodeLine{2112 \textcolor{comment}{                    if the function returns STRSAFE\_E\_INSUFFICIENT\_BUFFER, pszDest}}
\DoxyCodeLine{2113 \textcolor{comment}{                    will not contain a truncated string, it will remain unchanged.}}
\DoxyCodeLine{2114 \textcolor{comment}{}}
\DoxyCodeLine{2115 \textcolor{comment}{Notes:}}
\DoxyCodeLine{2116 \textcolor{comment}{    Behavior is undefined if source and destination strings overlap.}}
\DoxyCodeLine{2117 \textcolor{comment}{}}
\DoxyCodeLine{2118 \textcolor{comment}{    pszDest and pszSrc should not be NULL unless the STRSAFE\_IGNORE\_NULLS flag}}
\DoxyCodeLine{2119 \textcolor{comment}{    is specified.  If STRSAFE\_IGNORE\_NULLS is passed, both pszDest and pszSrc}}
\DoxyCodeLine{2120 \textcolor{comment}{    may be NULL.  An error may still be returned even though NULLS are ignored}}
\DoxyCodeLine{2121 \textcolor{comment}{    due to insufficient space.}}
\DoxyCodeLine{2122 \textcolor{comment}{}}
\DoxyCodeLine{2123 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{2124 \textcolor{comment}{}}
\DoxyCodeLine{2125 \textcolor{comment}{    S\_OK           -\/   if all of pszSrc or the first cchMaxAppend characters}}
\DoxyCodeLine{2126 \textcolor{comment}{                       were concatenated to pszDest and the resultant dest}}
\DoxyCodeLine{2127 \textcolor{comment}{                       string was null terminated}}
\DoxyCodeLine{2128 \textcolor{comment}{}}
\DoxyCodeLine{2129 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{2130 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{2131 \textcolor{comment}{}}
\DoxyCodeLine{2132 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{2133 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{2134 \textcolor{comment}{                   -\/   this return value is an indication that the operation}}
\DoxyCodeLine{2135 \textcolor{comment}{                       failed due to insufficient space. When this error}}
\DoxyCodeLine{2136 \textcolor{comment}{                       occurs, the destination buffer is modified to contain}}
\DoxyCodeLine{2137 \textcolor{comment}{                       a truncated version of the ideal result and is null}}
\DoxyCodeLine{2138 \textcolor{comment}{                       terminated. This is useful for situations where}}
\DoxyCodeLine{2139 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{2140 \textcolor{comment}{}}
\DoxyCodeLine{2141 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{2142 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{2143 \textcolor{comment}{}}
\DoxyCodeLine{2144 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{2145 }
\DoxyCodeLine{2146 STRSAFEAPI StringCchCatNExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cchMaxAppend, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{2147 STRSAFEAPI StringCchCatNExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cchMaxAppend, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{2148 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{2149 \textcolor{preprocessor}{\#define StringCchCatNEx  StringCchCatNExW}}
\DoxyCodeLine{2150 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2151 \textcolor{preprocessor}{\#define StringCchCatNEx  StringCchCatNExA}}
\DoxyCodeLine{2152 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{2153 }
\DoxyCodeLine{2154 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{2155 STRSAFEAPI StringCchCatNExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cchMaxAppend, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{2156 \{}
\DoxyCodeLine{2157     HRESULT hr;}
\DoxyCodeLine{2158 }
\DoxyCodeLine{2159     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{2160     \{}
\DoxyCodeLine{2161         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{2162     \}}
\DoxyCodeLine{2163     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2164     \{}
\DoxyCodeLine{2165         \textcolor{keywordtype}{size\_t} cbDest;}
\DoxyCodeLine{2166 }
\DoxyCodeLine{2167         \textcolor{comment}{// safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE\_MAX\_CCH and sizeof(char) is 1}}
\DoxyCodeLine{2168         cbDest = cchDest * \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{2169 }
\DoxyCodeLine{2170         hr = StringCatNExWorkerA(pszDest, cchDest, cbDest, pszSrc, cchMaxAppend, ppszDestEnd, pcchRemaining, dwFlags);}
\DoxyCodeLine{2171     \}}
\DoxyCodeLine{2172 }
\DoxyCodeLine{2173     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{2174 \}}
\DoxyCodeLine{2175 }
\DoxyCodeLine{2176 STRSAFEAPI StringCchCatNExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cchMaxAppend, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{2177 \{}
\DoxyCodeLine{2178     HRESULT hr;}
\DoxyCodeLine{2179 }
\DoxyCodeLine{2180     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{2181     \{}
\DoxyCodeLine{2182         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{2183     \}}
\DoxyCodeLine{2184     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2185     \{}
\DoxyCodeLine{2186         \textcolor{keywordtype}{size\_t} cbDest;}
\DoxyCodeLine{2187 }
\DoxyCodeLine{2188         \textcolor{comment}{// safe to multiply cchDest * sizeof(wchar\_t) since cchDest < STRSAFE\_MAX\_CCH and sizeof(wchar\_t) is 2}}
\DoxyCodeLine{2189         cbDest = cchDest * \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{2190 }
\DoxyCodeLine{2191         hr = StringCatNExWorkerW(pszDest, cchDest, cbDest, pszSrc, cchMaxAppend, ppszDestEnd, pcchRemaining, dwFlags);}
\DoxyCodeLine{2192     \}}
\DoxyCodeLine{2193 }
\DoxyCodeLine{2194     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{2195 \}}
\DoxyCodeLine{2196 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{2197 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{2198 }
\DoxyCodeLine{2199 }
\DoxyCodeLine{2200 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{2201 \textcolor{comment}{/*++}}
\DoxyCodeLine{2202 \textcolor{comment}{}}
\DoxyCodeLine{2203 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{2204 \textcolor{comment}{StringCbCatNEx(}}
\DoxyCodeLine{2205 \textcolor{comment}{    IN OUT LPTSTR  pszDest         OPTIONAL,}}
\DoxyCodeLine{2206 \textcolor{comment}{    IN     size\_t  cbDest,}}
\DoxyCodeLine{2207 \textcolor{comment}{    IN     LPCTSTR pszSrc          OPTIONAL,}}
\DoxyCodeLine{2208 \textcolor{comment}{    IN     size\_t  cbMaxAppend,}}
\DoxyCodeLine{2209 \textcolor{comment}{    OUT    LPTSTR* ppszDestEnd     OPTIONAL,}}
\DoxyCodeLine{2210 \textcolor{comment}{    OUT    size\_t* pcchRemaining   OPTIONAL,}}
\DoxyCodeLine{2211 \textcolor{comment}{    IN     DWORD   dwFlags}}
\DoxyCodeLine{2212 \textcolor{comment}{    );}}
\DoxyCodeLine{2213 \textcolor{comment}{}}
\DoxyCodeLine{2214 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{2215 \textcolor{comment}{}}
\DoxyCodeLine{2216 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strncat', with}}
\DoxyCodeLine{2217 \textcolor{comment}{    some additional parameters.  In addition to functionality provided by}}
\DoxyCodeLine{2218 \textcolor{comment}{    StringCbCatN, this routine also returns a pointer to the end of the}}
\DoxyCodeLine{2219 \textcolor{comment}{    destination string and the number of bytes left in the destination string}}
\DoxyCodeLine{2220 \textcolor{comment}{    including the null terminator. The flags parameter allows additional controls.}}
\DoxyCodeLine{2221 \textcolor{comment}{}}
\DoxyCodeLine{2222 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{2223 \textcolor{comment}{}}
\DoxyCodeLine{2224 \textcolor{comment}{    pszDest         -\/   destination string which must be null terminated}}
\DoxyCodeLine{2225 \textcolor{comment}{}}
\DoxyCodeLine{2226 \textcolor{comment}{    cbDest          -\/   size of destination buffer in bytes.}}
\DoxyCodeLine{2227 \textcolor{comment}{                        length must be ((\_tcslen(pszDest) + min(cbMaxAppend / sizeof(TCHAR), \_tcslen(pszSrc)) + 1) * sizeof(TCHAR)}}
\DoxyCodeLine{2228 \textcolor{comment}{                        to hold all of the combine string plus the null}}
\DoxyCodeLine{2229 \textcolor{comment}{                        terminator.}}
\DoxyCodeLine{2230 \textcolor{comment}{}}
\DoxyCodeLine{2231 \textcolor{comment}{    pszSrc          -\/   source string}}
\DoxyCodeLine{2232 \textcolor{comment}{}}
\DoxyCodeLine{2233 \textcolor{comment}{    cbMaxAppend     -\/   maximum number of bytes to append}}
\DoxyCodeLine{2234 \textcolor{comment}{}}
\DoxyCodeLine{2235 \textcolor{comment}{    ppszDestEnd     -\/   if ppszDestEnd is non-\/null, the function will return a}}
\DoxyCodeLine{2236 \textcolor{comment}{                        pointer to the end of the destination string.  If the}}
\DoxyCodeLine{2237 \textcolor{comment}{                        function appended any data, the result will point to the}}
\DoxyCodeLine{2238 \textcolor{comment}{                        null termination character}}
\DoxyCodeLine{2239 \textcolor{comment}{}}
\DoxyCodeLine{2240 \textcolor{comment}{    pcbRemaining    -\/   if pcbRemaining is non-\/null, the function will return the}}
\DoxyCodeLine{2241 \textcolor{comment}{                        number of bytes left in the destination string,}}
\DoxyCodeLine{2242 \textcolor{comment}{                        including the null terminator}}
\DoxyCodeLine{2243 \textcolor{comment}{}}
\DoxyCodeLine{2244 \textcolor{comment}{    dwFlags         -\/   controls some details of the string copy:}}
\DoxyCodeLine{2245 \textcolor{comment}{}}
\DoxyCodeLine{2246 \textcolor{comment}{        STRSAFE\_FILL\_BEHIND\_NULL}}
\DoxyCodeLine{2247 \textcolor{comment}{                    if the function succeeds, the low byte of dwFlags will be}}
\DoxyCodeLine{2248 \textcolor{comment}{                    used to fill the uninitialize part of destination buffer}}
\DoxyCodeLine{2249 \textcolor{comment}{                    behind the null terminator}}
\DoxyCodeLine{2250 \textcolor{comment}{}}
\DoxyCodeLine{2251 \textcolor{comment}{        STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{2252 \textcolor{comment}{                    treat NULL string pointers like empty strings (TEXT("{}"{}))}}
\DoxyCodeLine{2253 \textcolor{comment}{}}
\DoxyCodeLine{2254 \textcolor{comment}{        STRSAFE\_FILL\_ON\_FAILURE}}
\DoxyCodeLine{2255 \textcolor{comment}{                    if the function fails, the low byte of dwFlags will be}}
\DoxyCodeLine{2256 \textcolor{comment}{                    used to fill all of the destination buffer, and it will}}
\DoxyCodeLine{2257 \textcolor{comment}{                    be null terminated. This will overwrite any pre-\/existing}}
\DoxyCodeLine{2258 \textcolor{comment}{                    or truncated string}}
\DoxyCodeLine{2259 \textcolor{comment}{}}
\DoxyCodeLine{2260 \textcolor{comment}{        STRSAFE\_NULL\_ON\_FAILURE}}
\DoxyCodeLine{2261 \textcolor{comment}{                    if the function fails, the destination buffer will be set}}
\DoxyCodeLine{2262 \textcolor{comment}{                    to the empty string. This will overwrite any pre-\/existing or}}
\DoxyCodeLine{2263 \textcolor{comment}{                    truncated string}}
\DoxyCodeLine{2264 \textcolor{comment}{}}
\DoxyCodeLine{2265 \textcolor{comment}{        STRSAFE\_NO\_TRUNCATION}}
\DoxyCodeLine{2266 \textcolor{comment}{                    if the function returns STRSAFE\_E\_INSUFFICIENT\_BUFFER, pszDest}}
\DoxyCodeLine{2267 \textcolor{comment}{                    will not contain a truncated string, it will remain unchanged.}}
\DoxyCodeLine{2268 \textcolor{comment}{}}
\DoxyCodeLine{2269 \textcolor{comment}{Notes:}}
\DoxyCodeLine{2270 \textcolor{comment}{    Behavior is undefined if source and destination strings overlap.}}
\DoxyCodeLine{2271 \textcolor{comment}{}}
\DoxyCodeLine{2272 \textcolor{comment}{    pszDest and pszSrc should not be NULL unless the STRSAFE\_IGNORE\_NULLS flag}}
\DoxyCodeLine{2273 \textcolor{comment}{    is specified.  If STRSAFE\_IGNORE\_NULLS is passed, both pszDest and pszSrc}}
\DoxyCodeLine{2274 \textcolor{comment}{    may be NULL.  An error may still be returned even though NULLS are ignored}}
\DoxyCodeLine{2275 \textcolor{comment}{    due to insufficient space.}}
\DoxyCodeLine{2276 \textcolor{comment}{}}
\DoxyCodeLine{2277 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{2278 \textcolor{comment}{}}
\DoxyCodeLine{2279 \textcolor{comment}{    S\_OK           -\/   if all of pszSrc or the first cbMaxAppend bytes were}}
\DoxyCodeLine{2280 \textcolor{comment}{                       concatenated to pszDest and the resultant dest string}}
\DoxyCodeLine{2281 \textcolor{comment}{                       was null terminated}}
\DoxyCodeLine{2282 \textcolor{comment}{}}
\DoxyCodeLine{2283 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{2284 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{2285 \textcolor{comment}{}}
\DoxyCodeLine{2286 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{2287 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{2288 \textcolor{comment}{                   -\/   this return value is an indication that the operation}}
\DoxyCodeLine{2289 \textcolor{comment}{                       failed due to insufficient space. When this error}}
\DoxyCodeLine{2290 \textcolor{comment}{                       occurs, the destination buffer is modified to contain}}
\DoxyCodeLine{2291 \textcolor{comment}{                       a truncated version of the ideal result and is null}}
\DoxyCodeLine{2292 \textcolor{comment}{                       terminated. This is useful for situations where}}
\DoxyCodeLine{2293 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{2294 \textcolor{comment}{}}
\DoxyCodeLine{2295 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{2296 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{2297 \textcolor{comment}{}}
\DoxyCodeLine{2298 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{2299 }
\DoxyCodeLine{2300 STRSAFEAPI StringCbCatNExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cbMaxAppend, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{2301 STRSAFEAPI StringCbCatNExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cbMaxAppend, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{2302 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{2303 \textcolor{preprocessor}{\#define StringCbCatNEx  StringCbCatNExW}}
\DoxyCodeLine{2304 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2305 \textcolor{preprocessor}{\#define StringCbCatNEx  StringCbCatNExA}}
\DoxyCodeLine{2306 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{2307 }
\DoxyCodeLine{2308 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{2309 STRSAFEAPI StringCbCatNExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cbMaxAppend, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{2310 \{}
\DoxyCodeLine{2311     HRESULT hr;}
\DoxyCodeLine{2312     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{2313     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{2314 }
\DoxyCodeLine{2315     cchDest = cbDest / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{2316 }
\DoxyCodeLine{2317     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{2318     \{}
\DoxyCodeLine{2319         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{2320     \}}
\DoxyCodeLine{2321     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2322     \{}
\DoxyCodeLine{2323         \textcolor{keywordtype}{size\_t} cchMaxAppend;}
\DoxyCodeLine{2324 }
\DoxyCodeLine{2325         cchMaxAppend = cbMaxAppend / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{2326 }
\DoxyCodeLine{2327         hr = StringCatNExWorkerA(pszDest, cchDest, cbDest, pszSrc, cchMaxAppend, ppszDestEnd, \&cchRemaining, dwFlags);}
\DoxyCodeLine{2328     \}}
\DoxyCodeLine{2329 }
\DoxyCodeLine{2330     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{2331     \{}
\DoxyCodeLine{2332         \textcolor{keywordflow}{if} (pcbRemaining)}
\DoxyCodeLine{2333         \{}
\DoxyCodeLine{2334             \textcolor{comment}{// safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE\_MAX\_CCH and sizeof(char) is 1}}
\DoxyCodeLine{2335             *pcbRemaining = (cchRemaining * \textcolor{keyword}{sizeof}(char)) + (cbDest \% \textcolor{keyword}{sizeof}(char));}
\DoxyCodeLine{2336         \}}
\DoxyCodeLine{2337     \}}
\DoxyCodeLine{2338 }
\DoxyCodeLine{2339     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{2340 \}}
\DoxyCodeLine{2341 }
\DoxyCodeLine{2342 STRSAFEAPI StringCbCatNExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cbMaxAppend, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{2343 \{}
\DoxyCodeLine{2344     HRESULT hr;}
\DoxyCodeLine{2345     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{2346     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{2347 }
\DoxyCodeLine{2348     cchDest = cbDest / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{2349 }
\DoxyCodeLine{2350     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{2351     \{}
\DoxyCodeLine{2352         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{2353     \}}
\DoxyCodeLine{2354     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2355     \{}
\DoxyCodeLine{2356         \textcolor{keywordtype}{size\_t} cchMaxAppend;}
\DoxyCodeLine{2357 }
\DoxyCodeLine{2358         cchMaxAppend = cbMaxAppend / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{2359 }
\DoxyCodeLine{2360         hr = StringCatNExWorkerW(pszDest, cchDest, cbDest, pszSrc, cchMaxAppend, ppszDestEnd, \&cchRemaining, dwFlags);}
\DoxyCodeLine{2361     \}}
\DoxyCodeLine{2362 }
\DoxyCodeLine{2363     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{2364     \{}
\DoxyCodeLine{2365         \textcolor{keywordflow}{if} (pcbRemaining)}
\DoxyCodeLine{2366         \{}
\DoxyCodeLine{2367             \textcolor{comment}{// safe to multiply cchRemaining * sizeof(wchar\_t) since cchRemaining < STRSAFE\_MAX\_CCH and sizeof(wchar\_t) is 2}}
\DoxyCodeLine{2368             *pcbRemaining = (cchRemaining * \textcolor{keyword}{sizeof}(wchar\_t)) + (cbDest \% \textcolor{keyword}{sizeof}(wchar\_t));}
\DoxyCodeLine{2369         \}}
\DoxyCodeLine{2370     \}}
\DoxyCodeLine{2371 }
\DoxyCodeLine{2372     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{2373 \}}
\DoxyCodeLine{2374 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{2375 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{2376 }
\DoxyCodeLine{2377 }
\DoxyCodeLine{2378 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{2379 \textcolor{comment}{/*++}}
\DoxyCodeLine{2380 \textcolor{comment}{}}
\DoxyCodeLine{2381 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{2382 \textcolor{comment}{StringCchVPrintf(}}
\DoxyCodeLine{2383 \textcolor{comment}{    OUT LPTSTR  pszDest,}}
\DoxyCodeLine{2384 \textcolor{comment}{    IN  size\_t  cchDest,}}
\DoxyCodeLine{2385 \textcolor{comment}{    IN  LPCTSTR pszFormat,}}
\DoxyCodeLine{2386 \textcolor{comment}{    IN  va\_list argList}}
\DoxyCodeLine{2387 \textcolor{comment}{    );}}
\DoxyCodeLine{2388 \textcolor{comment}{}}
\DoxyCodeLine{2389 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{2390 \textcolor{comment}{}}
\DoxyCodeLine{2391 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'vsprintf'.}}
\DoxyCodeLine{2392 \textcolor{comment}{    The size of the destination buffer (in characters) is a parameter and}}
\DoxyCodeLine{2393 \textcolor{comment}{    this function will not write past the end of this buffer and it will}}
\DoxyCodeLine{2394 \textcolor{comment}{    ALWAYS null terminate the destination buffer (unless it is zero length).}}
\DoxyCodeLine{2395 \textcolor{comment}{}}
\DoxyCodeLine{2396 \textcolor{comment}{    This function returns a hresult, and not a pointer.  It returns}}
\DoxyCodeLine{2397 \textcolor{comment}{    S\_OK if the string was printed without truncation and null terminated,}}
\DoxyCodeLine{2398 \textcolor{comment}{    otherwise it will return a failure code. In failure cases it will return}}
\DoxyCodeLine{2399 \textcolor{comment}{    a truncated version of the ideal result.}}
\DoxyCodeLine{2400 \textcolor{comment}{}}
\DoxyCodeLine{2401 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{2402 \textcolor{comment}{}}
\DoxyCodeLine{2403 \textcolor{comment}{    pszDest     -\/  destination string}}
\DoxyCodeLine{2404 \textcolor{comment}{}}
\DoxyCodeLine{2405 \textcolor{comment}{    cchDest     -\/  size of destination buffer in characters}}
\DoxyCodeLine{2406 \textcolor{comment}{                   length must be sufficient to hold the resulting formatted}}
\DoxyCodeLine{2407 \textcolor{comment}{                   string, including the null terminator.}}
\DoxyCodeLine{2408 \textcolor{comment}{}}
\DoxyCodeLine{2409 \textcolor{comment}{    pszFormat   -\/  format string which must be null terminated}}
\DoxyCodeLine{2410 \textcolor{comment}{}}
\DoxyCodeLine{2411 \textcolor{comment}{    argList     -\/  va\_list from the variable arguments according to the}}
\DoxyCodeLine{2412 \textcolor{comment}{                   stdarg.h convention}}
\DoxyCodeLine{2413 \textcolor{comment}{}}
\DoxyCodeLine{2414 \textcolor{comment}{Notes:}}
\DoxyCodeLine{2415 \textcolor{comment}{    Behavior is undefined if destination, format strings or any arguments}}
\DoxyCodeLine{2416 \textcolor{comment}{    strings overlap.}}
\DoxyCodeLine{2417 \textcolor{comment}{}}
\DoxyCodeLine{2418 \textcolor{comment}{    pszDest and pszFormat should not be NULL.  See StringCchVPrintfEx if you}}
\DoxyCodeLine{2419 \textcolor{comment}{    require the handling of NULL values.}}
\DoxyCodeLine{2420 \textcolor{comment}{}}
\DoxyCodeLine{2421 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{2422 \textcolor{comment}{}}
\DoxyCodeLine{2423 \textcolor{comment}{    S\_OK           -\/   if there was sufficient space in the dest buffer for}}
\DoxyCodeLine{2424 \textcolor{comment}{                       the resultant string and it was null terminated.}}
\DoxyCodeLine{2425 \textcolor{comment}{}}
\DoxyCodeLine{2426 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{2427 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{2428 \textcolor{comment}{}}
\DoxyCodeLine{2429 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{2430 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{2431 \textcolor{comment}{                   -\/   this return value is an indication that the print}}
\DoxyCodeLine{2432 \textcolor{comment}{                       operation failed due to insufficient space. When this}}
\DoxyCodeLine{2433 \textcolor{comment}{                       error occurs, the destination buffer is modified to}}
\DoxyCodeLine{2434 \textcolor{comment}{                       contain a truncated version of the ideal result and is}}
\DoxyCodeLine{2435 \textcolor{comment}{                       null terminated. This is useful for situations where}}
\DoxyCodeLine{2436 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{2437 \textcolor{comment}{}}
\DoxyCodeLine{2438 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{2439 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{2440 \textcolor{comment}{}}
\DoxyCodeLine{2441 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{2442 }
\DoxyCodeLine{2443 STRSAFEAPI StringCchVPrintfA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, va\_list argList);}
\DoxyCodeLine{2444 STRSAFEAPI StringCchVPrintfW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, va\_list argList);}
\DoxyCodeLine{2445 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{2446 \textcolor{preprocessor}{\#define StringCchVPrintf  StringCchVPrintfW}}
\DoxyCodeLine{2447 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2448 \textcolor{preprocessor}{\#define StringCchVPrintf  StringCchVPrintfA}}
\DoxyCodeLine{2449 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{2450 }
\DoxyCodeLine{2451 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{2452 STRSAFEAPI StringCchVPrintfA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, va\_list argList)}
\DoxyCodeLine{2453 \{}
\DoxyCodeLine{2454     HRESULT hr;}
\DoxyCodeLine{2455 }
\DoxyCodeLine{2456     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{2457     \{}
\DoxyCodeLine{2458         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{2459     \}}
\DoxyCodeLine{2460     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2461     \{}
\DoxyCodeLine{2462         hr = StringVPrintfWorkerA(pszDest, cchDest, pszFormat, argList);}
\DoxyCodeLine{2463     \}}
\DoxyCodeLine{2464 }
\DoxyCodeLine{2465     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{2466 \}}
\DoxyCodeLine{2467 }
\DoxyCodeLine{2468 STRSAFEAPI StringCchVPrintfW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, va\_list argList)}
\DoxyCodeLine{2469 \{}
\DoxyCodeLine{2470     HRESULT hr;}
\DoxyCodeLine{2471 }
\DoxyCodeLine{2472     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{2473     \{}
\DoxyCodeLine{2474         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{2475     \}}
\DoxyCodeLine{2476     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2477     \{}
\DoxyCodeLine{2478         hr = StringVPrintfWorkerW(pszDest, cchDest, pszFormat, argList);}
\DoxyCodeLine{2479     \}}
\DoxyCodeLine{2480 }
\DoxyCodeLine{2481     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{2482 \}}
\DoxyCodeLine{2483 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{2484 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{2485 }
\DoxyCodeLine{2486 }
\DoxyCodeLine{2487 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{2488 \textcolor{comment}{/*++}}
\DoxyCodeLine{2489 \textcolor{comment}{}}
\DoxyCodeLine{2490 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{2491 \textcolor{comment}{StringCbVPrintf(}}
\DoxyCodeLine{2492 \textcolor{comment}{    OUT LPTSTR  pszDest,}}
\DoxyCodeLine{2493 \textcolor{comment}{    IN  size\_t  cbDest,}}
\DoxyCodeLine{2494 \textcolor{comment}{    IN  LPCTSTR pszFormat,}}
\DoxyCodeLine{2495 \textcolor{comment}{    IN  va\_list argList}}
\DoxyCodeLine{2496 \textcolor{comment}{    );}}
\DoxyCodeLine{2497 \textcolor{comment}{}}
\DoxyCodeLine{2498 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{2499 \textcolor{comment}{}}
\DoxyCodeLine{2500 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'vsprintf'.}}
\DoxyCodeLine{2501 \textcolor{comment}{    The size of the destination buffer (in bytes) is a parameter and}}
\DoxyCodeLine{2502 \textcolor{comment}{    this function will not write past the end of this buffer and it will}}
\DoxyCodeLine{2503 \textcolor{comment}{    ALWAYS null terminate the destination buffer (unless it is zero length).}}
\DoxyCodeLine{2504 \textcolor{comment}{}}
\DoxyCodeLine{2505 \textcolor{comment}{    This function returns a hresult, and not a pointer.  It returns}}
\DoxyCodeLine{2506 \textcolor{comment}{    S\_OK if the string was printed without truncation and null terminated,}}
\DoxyCodeLine{2507 \textcolor{comment}{    otherwise it will return a failure code. In failure cases it will return}}
\DoxyCodeLine{2508 \textcolor{comment}{    a truncated version of the ideal result.}}
\DoxyCodeLine{2509 \textcolor{comment}{}}
\DoxyCodeLine{2510 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{2511 \textcolor{comment}{}}
\DoxyCodeLine{2512 \textcolor{comment}{    pszDest     -\/  destination string}}
\DoxyCodeLine{2513 \textcolor{comment}{}}
\DoxyCodeLine{2514 \textcolor{comment}{    cbDest      -\/  size of destination buffer in bytes}}
\DoxyCodeLine{2515 \textcolor{comment}{                   length must be sufficient to hold the resulting formatted}}
\DoxyCodeLine{2516 \textcolor{comment}{                   string, including the null terminator.}}
\DoxyCodeLine{2517 \textcolor{comment}{}}
\DoxyCodeLine{2518 \textcolor{comment}{    pszFormat   -\/  format string which must be null terminated}}
\DoxyCodeLine{2519 \textcolor{comment}{}}
\DoxyCodeLine{2520 \textcolor{comment}{    argList     -\/  va\_list from the variable arguments according to the}}
\DoxyCodeLine{2521 \textcolor{comment}{                   stdarg.h convention}}
\DoxyCodeLine{2522 \textcolor{comment}{}}
\DoxyCodeLine{2523 \textcolor{comment}{Notes:}}
\DoxyCodeLine{2524 \textcolor{comment}{    Behavior is undefined if destination, format strings or any arguments}}
\DoxyCodeLine{2525 \textcolor{comment}{    strings overlap.}}
\DoxyCodeLine{2526 \textcolor{comment}{}}
\DoxyCodeLine{2527 \textcolor{comment}{    pszDest and pszFormat should not be NULL.  See StringCbVPrintfEx if you}}
\DoxyCodeLine{2528 \textcolor{comment}{    require the handling of NULL values.}}
\DoxyCodeLine{2529 \textcolor{comment}{}}
\DoxyCodeLine{2530 \textcolor{comment}{}}
\DoxyCodeLine{2531 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{2532 \textcolor{comment}{}}
\DoxyCodeLine{2533 \textcolor{comment}{    S\_OK           -\/   if there was sufficient space in the dest buffer for}}
\DoxyCodeLine{2534 \textcolor{comment}{                       the resultant string and it was null terminated.}}
\DoxyCodeLine{2535 \textcolor{comment}{}}
\DoxyCodeLine{2536 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{2537 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{2538 \textcolor{comment}{}}
\DoxyCodeLine{2539 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{2540 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{2541 \textcolor{comment}{                   -\/   this return value is an indication that the print}}
\DoxyCodeLine{2542 \textcolor{comment}{                       operation failed due to insufficient space. When this}}
\DoxyCodeLine{2543 \textcolor{comment}{                       error occurs, the destination buffer is modified to}}
\DoxyCodeLine{2544 \textcolor{comment}{                       contain a truncated version of the ideal result and is}}
\DoxyCodeLine{2545 \textcolor{comment}{                       null terminated. This is useful for situations where}}
\DoxyCodeLine{2546 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{2547 \textcolor{comment}{}}
\DoxyCodeLine{2548 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{2549 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{2550 \textcolor{comment}{}}
\DoxyCodeLine{2551 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{2552 }
\DoxyCodeLine{2553 STRSAFEAPI StringCbVPrintfA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, va\_list argList);}
\DoxyCodeLine{2554 STRSAFEAPI StringCbVPrintfW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, va\_list argList);}
\DoxyCodeLine{2555 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{2556 \textcolor{preprocessor}{\#define StringCbVPrintf  StringCbVPrintfW}}
\DoxyCodeLine{2557 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2558 \textcolor{preprocessor}{\#define StringCbVPrintf  StringCbVPrintfA}}
\DoxyCodeLine{2559 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{2560 }
\DoxyCodeLine{2561 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{2562 STRSAFEAPI StringCbVPrintfA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, va\_list argList)}
\DoxyCodeLine{2563 \{}
\DoxyCodeLine{2564     HRESULT hr;}
\DoxyCodeLine{2565     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{2566 }
\DoxyCodeLine{2567     cchDest = cbDest / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{2568 }
\DoxyCodeLine{2569     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{2570     \{}
\DoxyCodeLine{2571         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{2572     \}}
\DoxyCodeLine{2573     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2574     \{}
\DoxyCodeLine{2575         hr = StringVPrintfWorkerA(pszDest, cchDest, pszFormat, argList);}
\DoxyCodeLine{2576     \}}
\DoxyCodeLine{2577 }
\DoxyCodeLine{2578     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{2579 \}}
\DoxyCodeLine{2580 }
\DoxyCodeLine{2581 STRSAFEAPI StringCbVPrintfW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, va\_list argList)}
\DoxyCodeLine{2582 \{}
\DoxyCodeLine{2583     HRESULT hr;}
\DoxyCodeLine{2584     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{2585 }
\DoxyCodeLine{2586     cchDest = cbDest / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{2587 }
\DoxyCodeLine{2588     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{2589     \{}
\DoxyCodeLine{2590         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{2591     \}}
\DoxyCodeLine{2592     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2593     \{}
\DoxyCodeLine{2594         hr = StringVPrintfWorkerW(pszDest, cchDest, pszFormat, argList);}
\DoxyCodeLine{2595     \}}
\DoxyCodeLine{2596 }
\DoxyCodeLine{2597     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{2598 \}}
\DoxyCodeLine{2599 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{2600 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{2601 }
\DoxyCodeLine{2602 }
\DoxyCodeLine{2603 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{2604 \textcolor{comment}{/*++}}
\DoxyCodeLine{2605 \textcolor{comment}{}}
\DoxyCodeLine{2606 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{2607 \textcolor{comment}{StringCchPrintf(}}
\DoxyCodeLine{2608 \textcolor{comment}{    OUT LPTSTR  pszDest,}}
\DoxyCodeLine{2609 \textcolor{comment}{    IN  size\_t  cchDest,}}
\DoxyCodeLine{2610 \textcolor{comment}{    IN  LPCTSTR pszFormat,}}
\DoxyCodeLine{2611 \textcolor{comment}{    ...}}
\DoxyCodeLine{2612 \textcolor{comment}{    );}}
\DoxyCodeLine{2613 \textcolor{comment}{}}
\DoxyCodeLine{2614 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{2615 \textcolor{comment}{}}
\DoxyCodeLine{2616 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'sprintf'.}}
\DoxyCodeLine{2617 \textcolor{comment}{    The size of the destination buffer (in characters) is a parameter and}}
\DoxyCodeLine{2618 \textcolor{comment}{    this function will not write past the end of this buffer and it will}}
\DoxyCodeLine{2619 \textcolor{comment}{    ALWAYS null terminate the destination buffer (unless it is zero length).}}
\DoxyCodeLine{2620 \textcolor{comment}{}}
\DoxyCodeLine{2621 \textcolor{comment}{    This function returns a hresult, and not a pointer.  It returns}}
\DoxyCodeLine{2622 \textcolor{comment}{    S\_OK if the string was printed without truncation and null terminated,}}
\DoxyCodeLine{2623 \textcolor{comment}{    otherwise it will return a failure code. In failure cases it will return}}
\DoxyCodeLine{2624 \textcolor{comment}{    a truncated version of the ideal result.}}
\DoxyCodeLine{2625 \textcolor{comment}{}}
\DoxyCodeLine{2626 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{2627 \textcolor{comment}{}}
\DoxyCodeLine{2628 \textcolor{comment}{    pszDest     -\/  destination string}}
\DoxyCodeLine{2629 \textcolor{comment}{}}
\DoxyCodeLine{2630 \textcolor{comment}{    cchDest     -\/  size of destination buffer in characters}}
\DoxyCodeLine{2631 \textcolor{comment}{                   length must be sufficient to hold the resulting formatted}}
\DoxyCodeLine{2632 \textcolor{comment}{                   string, including the null terminator.}}
\DoxyCodeLine{2633 \textcolor{comment}{}}
\DoxyCodeLine{2634 \textcolor{comment}{    pszFormat   -\/  format string which must be null terminated}}
\DoxyCodeLine{2635 \textcolor{comment}{}}
\DoxyCodeLine{2636 \textcolor{comment}{    ...         -\/  additional parameters to be formatted according to}}
\DoxyCodeLine{2637 \textcolor{comment}{                   the format string}}
\DoxyCodeLine{2638 \textcolor{comment}{}}
\DoxyCodeLine{2639 \textcolor{comment}{Notes:}}
\DoxyCodeLine{2640 \textcolor{comment}{    Behavior is undefined if destination, format strings or any arguments}}
\DoxyCodeLine{2641 \textcolor{comment}{    strings overlap.}}
\DoxyCodeLine{2642 \textcolor{comment}{}}
\DoxyCodeLine{2643 \textcolor{comment}{    pszDest and pszFormat should not be NULL.  See StringCchPrintfEx if you}}
\DoxyCodeLine{2644 \textcolor{comment}{    require the handling of NULL values.}}
\DoxyCodeLine{2645 \textcolor{comment}{}}
\DoxyCodeLine{2646 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{2647 \textcolor{comment}{}}
\DoxyCodeLine{2648 \textcolor{comment}{    S\_OK           -\/   if there was sufficient space in the dest buffer for}}
\DoxyCodeLine{2649 \textcolor{comment}{                       the resultant string and it was null terminated.}}
\DoxyCodeLine{2650 \textcolor{comment}{}}
\DoxyCodeLine{2651 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{2652 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{2653 \textcolor{comment}{}}
\DoxyCodeLine{2654 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{2655 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{2656 \textcolor{comment}{                   -\/   this return value is an indication that the print}}
\DoxyCodeLine{2657 \textcolor{comment}{                       operation failed due to insufficient space. When this}}
\DoxyCodeLine{2658 \textcolor{comment}{                       error occurs, the destination buffer is modified to}}
\DoxyCodeLine{2659 \textcolor{comment}{                       contain a truncated version of the ideal result and is}}
\DoxyCodeLine{2660 \textcolor{comment}{                       null terminated. This is useful for situations where}}
\DoxyCodeLine{2661 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{2662 \textcolor{comment}{}}
\DoxyCodeLine{2663 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{2664 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{2665 \textcolor{comment}{}}
\DoxyCodeLine{2666 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{2667 }
\DoxyCodeLine{2668 STRSAFEAPI StringCchPrintfA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, ...);}
\DoxyCodeLine{2669 STRSAFEAPI StringCchPrintfW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, ...);}
\DoxyCodeLine{2670 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{2671 \textcolor{preprocessor}{\#define StringCchPrintf  StringCchPrintfW}}
\DoxyCodeLine{2672 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2673 \textcolor{preprocessor}{\#define StringCchPrintf  StringCchPrintfA}}
\DoxyCodeLine{2674 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{2675 }
\DoxyCodeLine{2676 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{2677 STRSAFEAPI StringCchPrintfA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, ...)}
\DoxyCodeLine{2678 \{}
\DoxyCodeLine{2679     HRESULT hr;}
\DoxyCodeLine{2680 }
\DoxyCodeLine{2681     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{2682     \{}
\DoxyCodeLine{2683         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{2684     \}}
\DoxyCodeLine{2685     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2686     \{}
\DoxyCodeLine{2687         va\_list argList;}
\DoxyCodeLine{2688 }
\DoxyCodeLine{2689         va\_start(argList, pszFormat);}
\DoxyCodeLine{2690 }
\DoxyCodeLine{2691         hr = StringVPrintfWorkerA(pszDest, cchDest, pszFormat, argList);}
\DoxyCodeLine{2692 }
\DoxyCodeLine{2693         va\_end(argList);}
\DoxyCodeLine{2694     \}}
\DoxyCodeLine{2695 }
\DoxyCodeLine{2696     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{2697 \}}
\DoxyCodeLine{2698 }
\DoxyCodeLine{2699 STRSAFEAPI StringCchPrintfW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, ...)}
\DoxyCodeLine{2700 \{}
\DoxyCodeLine{2701     HRESULT hr;}
\DoxyCodeLine{2702 }
\DoxyCodeLine{2703     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{2704     \{}
\DoxyCodeLine{2705         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{2706     \}}
\DoxyCodeLine{2707     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2708     \{}
\DoxyCodeLine{2709         va\_list argList;}
\DoxyCodeLine{2710 }
\DoxyCodeLine{2711         va\_start(argList, pszFormat);}
\DoxyCodeLine{2712 }
\DoxyCodeLine{2713         hr = StringVPrintfWorkerW(pszDest, cchDest, pszFormat, argList);}
\DoxyCodeLine{2714 }
\DoxyCodeLine{2715         va\_end(argList);}
\DoxyCodeLine{2716     \}}
\DoxyCodeLine{2717 }
\DoxyCodeLine{2718     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{2719 \}}
\DoxyCodeLine{2720 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{2721 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{2722 }
\DoxyCodeLine{2723 }
\DoxyCodeLine{2724 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{2725 \textcolor{comment}{/*++}}
\DoxyCodeLine{2726 \textcolor{comment}{}}
\DoxyCodeLine{2727 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{2728 \textcolor{comment}{StringCbPrintf(}}
\DoxyCodeLine{2729 \textcolor{comment}{    OUT LPTSTR  pszDest,}}
\DoxyCodeLine{2730 \textcolor{comment}{    IN  size\_t  cbDest,}}
\DoxyCodeLine{2731 \textcolor{comment}{    IN  LPCTSTR pszFormat,}}
\DoxyCodeLine{2732 \textcolor{comment}{    ...}}
\DoxyCodeLine{2733 \textcolor{comment}{    );}}
\DoxyCodeLine{2734 \textcolor{comment}{}}
\DoxyCodeLine{2735 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{2736 \textcolor{comment}{}}
\DoxyCodeLine{2737 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'sprintf'.}}
\DoxyCodeLine{2738 \textcolor{comment}{    The size of the destination buffer (in bytes) is a parameter and}}
\DoxyCodeLine{2739 \textcolor{comment}{    this function will not write past the end of this buffer and it will}}
\DoxyCodeLine{2740 \textcolor{comment}{    ALWAYS null terminate the destination buffer (unless it is zero length).}}
\DoxyCodeLine{2741 \textcolor{comment}{}}
\DoxyCodeLine{2742 \textcolor{comment}{    This function returns a hresult, and not a pointer.  It returns}}
\DoxyCodeLine{2743 \textcolor{comment}{    S\_OK if the string was printed without truncation and null terminated,}}
\DoxyCodeLine{2744 \textcolor{comment}{    otherwise it will return a failure code. In failure cases it will return}}
\DoxyCodeLine{2745 \textcolor{comment}{    a truncated version of the ideal result.}}
\DoxyCodeLine{2746 \textcolor{comment}{}}
\DoxyCodeLine{2747 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{2748 \textcolor{comment}{}}
\DoxyCodeLine{2749 \textcolor{comment}{    pszDest     -\/  destination string}}
\DoxyCodeLine{2750 \textcolor{comment}{}}
\DoxyCodeLine{2751 \textcolor{comment}{    cbDest      -\/  size of destination buffer in bytes}}
\DoxyCodeLine{2752 \textcolor{comment}{                   length must be sufficient to hold the resulting formatted}}
\DoxyCodeLine{2753 \textcolor{comment}{                   string, including the null terminator.}}
\DoxyCodeLine{2754 \textcolor{comment}{}}
\DoxyCodeLine{2755 \textcolor{comment}{    pszFormat   -\/  format string which must be null terminated}}
\DoxyCodeLine{2756 \textcolor{comment}{}}
\DoxyCodeLine{2757 \textcolor{comment}{    ...         -\/  additional parameters to be formatted according to}}
\DoxyCodeLine{2758 \textcolor{comment}{                   the format string}}
\DoxyCodeLine{2759 \textcolor{comment}{}}
\DoxyCodeLine{2760 \textcolor{comment}{Notes:}}
\DoxyCodeLine{2761 \textcolor{comment}{    Behavior is undefined if destination, format strings or any arguments}}
\DoxyCodeLine{2762 \textcolor{comment}{    strings overlap.}}
\DoxyCodeLine{2763 \textcolor{comment}{}}
\DoxyCodeLine{2764 \textcolor{comment}{    pszDest and pszFormat should not be NULL.  See StringCbPrintfEx if you}}
\DoxyCodeLine{2765 \textcolor{comment}{    require the handling of NULL values.}}
\DoxyCodeLine{2766 \textcolor{comment}{}}
\DoxyCodeLine{2767 \textcolor{comment}{}}
\DoxyCodeLine{2768 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{2769 \textcolor{comment}{}}
\DoxyCodeLine{2770 \textcolor{comment}{    S\_OK           -\/   if there was sufficient space in the dest buffer for}}
\DoxyCodeLine{2771 \textcolor{comment}{                       the resultant string and it was null terminated.}}
\DoxyCodeLine{2772 \textcolor{comment}{}}
\DoxyCodeLine{2773 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{2774 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{2775 \textcolor{comment}{}}
\DoxyCodeLine{2776 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{2777 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{2778 \textcolor{comment}{                   -\/   this return value is an indication that the print}}
\DoxyCodeLine{2779 \textcolor{comment}{                       operation failed due to insufficient space. When this}}
\DoxyCodeLine{2780 \textcolor{comment}{                       error occurs, the destination buffer is modified to}}
\DoxyCodeLine{2781 \textcolor{comment}{                       contain a truncated version of the ideal result and is}}
\DoxyCodeLine{2782 \textcolor{comment}{                       null terminated. This is useful for situations where}}
\DoxyCodeLine{2783 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{2784 \textcolor{comment}{}}
\DoxyCodeLine{2785 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{2786 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{2787 \textcolor{comment}{}}
\DoxyCodeLine{2788 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{2789 }
\DoxyCodeLine{2790 STRSAFEAPI StringCbPrintfA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, ...);}
\DoxyCodeLine{2791 STRSAFEAPI StringCbPrintfW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, ...);}
\DoxyCodeLine{2792 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{2793 \textcolor{preprocessor}{\#define StringCbPrintf  StringCbPrintfW}}
\DoxyCodeLine{2794 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2795 \textcolor{preprocessor}{\#define StringCbPrintf  StringCbPrintfA}}
\DoxyCodeLine{2796 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{2797 }
\DoxyCodeLine{2798 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{2799 STRSAFEAPI StringCbPrintfA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, ...)}
\DoxyCodeLine{2800 \{}
\DoxyCodeLine{2801     HRESULT hr;}
\DoxyCodeLine{2802     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{2803 }
\DoxyCodeLine{2804     cchDest = cbDest / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{2805 }
\DoxyCodeLine{2806     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{2807     \{}
\DoxyCodeLine{2808         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{2809     \}}
\DoxyCodeLine{2810     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2811     \{}
\DoxyCodeLine{2812         va\_list argList;}
\DoxyCodeLine{2813 }
\DoxyCodeLine{2814         va\_start(argList, pszFormat);}
\DoxyCodeLine{2815 }
\DoxyCodeLine{2816         hr = StringVPrintfWorkerA(pszDest, cchDest, pszFormat, argList);}
\DoxyCodeLine{2817 }
\DoxyCodeLine{2818         va\_end(argList);}
\DoxyCodeLine{2819     \}}
\DoxyCodeLine{2820 }
\DoxyCodeLine{2821     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{2822 \}}
\DoxyCodeLine{2823 }
\DoxyCodeLine{2824 STRSAFEAPI StringCbPrintfW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, ...)}
\DoxyCodeLine{2825 \{}
\DoxyCodeLine{2826     HRESULT hr;}
\DoxyCodeLine{2827     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{2828 }
\DoxyCodeLine{2829     cchDest = cbDest / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{2830 }
\DoxyCodeLine{2831     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{2832     \{}
\DoxyCodeLine{2833         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{2834     \}}
\DoxyCodeLine{2835     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2836     \{}
\DoxyCodeLine{2837         va\_list argList;}
\DoxyCodeLine{2838 }
\DoxyCodeLine{2839         va\_start(argList, pszFormat);}
\DoxyCodeLine{2840 }
\DoxyCodeLine{2841         hr = StringVPrintfWorkerW(pszDest, cchDest, pszFormat, argList);}
\DoxyCodeLine{2842 }
\DoxyCodeLine{2843         va\_end(argList);}
\DoxyCodeLine{2844     \}}
\DoxyCodeLine{2845 }
\DoxyCodeLine{2846     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{2847 \}}
\DoxyCodeLine{2848 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{2849 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{2850 }
\DoxyCodeLine{2851 }
\DoxyCodeLine{2852 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{2853 \textcolor{comment}{/*++}}
\DoxyCodeLine{2854 \textcolor{comment}{}}
\DoxyCodeLine{2855 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{2856 \textcolor{comment}{StringCchPrintfEx(}}
\DoxyCodeLine{2857 \textcolor{comment}{    OUT LPTSTR  pszDest         OPTIONAL,}}
\DoxyCodeLine{2858 \textcolor{comment}{    IN  size\_t  cchDest,}}
\DoxyCodeLine{2859 \textcolor{comment}{    OUT LPTSTR* ppszDestEnd     OPTIONAL,}}
\DoxyCodeLine{2860 \textcolor{comment}{    OUT size\_t* pcchRemaining   OPTIONAL,}}
\DoxyCodeLine{2861 \textcolor{comment}{    IN  DWORD   dwFlags,}}
\DoxyCodeLine{2862 \textcolor{comment}{    IN  LPCTSTR pszFormat       OPTIONAL,}}
\DoxyCodeLine{2863 \textcolor{comment}{    ...}}
\DoxyCodeLine{2864 \textcolor{comment}{    );}}
\DoxyCodeLine{2865 \textcolor{comment}{}}
\DoxyCodeLine{2866 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{2867 \textcolor{comment}{}}
\DoxyCodeLine{2868 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'sprintf' with}}
\DoxyCodeLine{2869 \textcolor{comment}{    some additional parameters.  In addition to functionality provided by}}
\DoxyCodeLine{2870 \textcolor{comment}{    StringCchPrintf, this routine also returns a pointer to the end of the}}
\DoxyCodeLine{2871 \textcolor{comment}{    destination string and the number of characters left in the destination string}}
\DoxyCodeLine{2872 \textcolor{comment}{    including the null terminator. The flags parameter allows additional controls.}}
\DoxyCodeLine{2873 \textcolor{comment}{}}
\DoxyCodeLine{2874 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{2875 \textcolor{comment}{}}
\DoxyCodeLine{2876 \textcolor{comment}{    pszDest         -\/   destination string}}
\DoxyCodeLine{2877 \textcolor{comment}{}}
\DoxyCodeLine{2878 \textcolor{comment}{    cchDest         -\/   size of destination buffer in characters.}}
\DoxyCodeLine{2879 \textcolor{comment}{                        length must be sufficient to contain the resulting}}
\DoxyCodeLine{2880 \textcolor{comment}{                        formatted string plus the null terminator.}}
\DoxyCodeLine{2881 \textcolor{comment}{}}
\DoxyCodeLine{2882 \textcolor{comment}{    ppszDestEnd     -\/   if ppszDestEnd is non-\/null, the function will return a}}
\DoxyCodeLine{2883 \textcolor{comment}{                        pointer to the end of the destination string.  If the}}
\DoxyCodeLine{2884 \textcolor{comment}{                        function printed any data, the result will point to the}}
\DoxyCodeLine{2885 \textcolor{comment}{                        null termination character}}
\DoxyCodeLine{2886 \textcolor{comment}{}}
\DoxyCodeLine{2887 \textcolor{comment}{    pcchRemaining   -\/   if pcchRemaining is non-\/null, the function will return}}
\DoxyCodeLine{2888 \textcolor{comment}{                        the number of characters left in the destination string,}}
\DoxyCodeLine{2889 \textcolor{comment}{                        including the null terminator}}
\DoxyCodeLine{2890 \textcolor{comment}{}}
\DoxyCodeLine{2891 \textcolor{comment}{    dwFlags         -\/   controls some details of the string copy:}}
\DoxyCodeLine{2892 \textcolor{comment}{}}
\DoxyCodeLine{2893 \textcolor{comment}{        STRSAFE\_FILL\_BEHIND\_NULL}}
\DoxyCodeLine{2894 \textcolor{comment}{                    if the function succeeds, the low byte of dwFlags will be}}
\DoxyCodeLine{2895 \textcolor{comment}{                    used to fill the uninitialize part of destination buffer}}
\DoxyCodeLine{2896 \textcolor{comment}{                    behind the null terminator}}
\DoxyCodeLine{2897 \textcolor{comment}{}}
\DoxyCodeLine{2898 \textcolor{comment}{        STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{2899 \textcolor{comment}{                    treat NULL string pointers like empty strings (TEXT("{}"{}))}}
\DoxyCodeLine{2900 \textcolor{comment}{}}
\DoxyCodeLine{2901 \textcolor{comment}{        STRSAFE\_FILL\_ON\_FAILURE}}
\DoxyCodeLine{2902 \textcolor{comment}{                    if the function fails, the low byte of dwFlags will be}}
\DoxyCodeLine{2903 \textcolor{comment}{                    used to fill all of the destination buffer, and it will}}
\DoxyCodeLine{2904 \textcolor{comment}{                    be null terminated. This will overwrite any truncated}}
\DoxyCodeLine{2905 \textcolor{comment}{                    string returned when the failure is}}
\DoxyCodeLine{2906 \textcolor{comment}{                    STRSAFE\_E\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{2907 \textcolor{comment}{}}
\DoxyCodeLine{2908 \textcolor{comment}{        STRSAFE\_NO\_TRUNCATION /}}
\DoxyCodeLine{2909 \textcolor{comment}{        STRSAFE\_NULL\_ON\_FAILURE}}
\DoxyCodeLine{2910 \textcolor{comment}{                    if the function fails, the destination buffer will be set}}
\DoxyCodeLine{2911 \textcolor{comment}{                    to the empty string. This will overwrite any truncated string}}
\DoxyCodeLine{2912 \textcolor{comment}{                    returned when the failure is STRSAFE\_E\_INSUFFICIENT\_BUFFER.}}
\DoxyCodeLine{2913 \textcolor{comment}{}}
\DoxyCodeLine{2914 \textcolor{comment}{    pszFormat       -\/   format string which must be null terminated}}
\DoxyCodeLine{2915 \textcolor{comment}{}}
\DoxyCodeLine{2916 \textcolor{comment}{    ...             -\/   additional parameters to be formatted according to}}
\DoxyCodeLine{2917 \textcolor{comment}{                        the format string}}
\DoxyCodeLine{2918 \textcolor{comment}{}}
\DoxyCodeLine{2919 \textcolor{comment}{Notes:}}
\DoxyCodeLine{2920 \textcolor{comment}{    Behavior is undefined if destination, format strings or any arguments}}
\DoxyCodeLine{2921 \textcolor{comment}{    strings overlap.}}
\DoxyCodeLine{2922 \textcolor{comment}{}}
\DoxyCodeLine{2923 \textcolor{comment}{    pszDest and pszFormat should not be NULL unless the STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{2924 \textcolor{comment}{    flag is specified.  If STRSAFE\_IGNORE\_NULLS is passed, both pszDest and}}
\DoxyCodeLine{2925 \textcolor{comment}{    pszFormat may be NULL.  An error may still be returned even though NULLS}}
\DoxyCodeLine{2926 \textcolor{comment}{    are ignored due to insufficient space.}}
\DoxyCodeLine{2927 \textcolor{comment}{}}
\DoxyCodeLine{2928 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{2929 \textcolor{comment}{}}
\DoxyCodeLine{2930 \textcolor{comment}{    S\_OK           -\/   if there was source data and it was all concatenated and}}
\DoxyCodeLine{2931 \textcolor{comment}{                       the resultant dest string was null terminated}}
\DoxyCodeLine{2932 \textcolor{comment}{}}
\DoxyCodeLine{2933 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{2934 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{2935 \textcolor{comment}{}}
\DoxyCodeLine{2936 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{2937 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{2938 \textcolor{comment}{                   -\/   this return value is an indication that the print}}
\DoxyCodeLine{2939 \textcolor{comment}{                       operation failed due to insufficient space. When this}}
\DoxyCodeLine{2940 \textcolor{comment}{                       error occurs, the destination buffer is modified to}}
\DoxyCodeLine{2941 \textcolor{comment}{                       contain a truncated version of the ideal result and is}}
\DoxyCodeLine{2942 \textcolor{comment}{                       null terminated. This is useful for situations where}}
\DoxyCodeLine{2943 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{2944 \textcolor{comment}{}}
\DoxyCodeLine{2945 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{2946 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{2947 \textcolor{comment}{}}
\DoxyCodeLine{2948 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{2949 }
\DoxyCodeLine{2950 STRSAFEAPI StringCchPrintfExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, ...);}
\DoxyCodeLine{2951 STRSAFEAPI StringCchPrintfExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, ...);}
\DoxyCodeLine{2952 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{2953 \textcolor{preprocessor}{\#define StringCchPrintfEx  StringCchPrintfExW}}
\DoxyCodeLine{2954 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2955 \textcolor{preprocessor}{\#define StringCchPrintfEx  StringCchPrintfExA}}
\DoxyCodeLine{2956 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{2957 }
\DoxyCodeLine{2958 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{2959 STRSAFEAPI StringCchPrintfExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, ...)}
\DoxyCodeLine{2960 \{}
\DoxyCodeLine{2961     HRESULT hr;}
\DoxyCodeLine{2962 }
\DoxyCodeLine{2963     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{2964     \{}
\DoxyCodeLine{2965         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{2966     \}}
\DoxyCodeLine{2967     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2968     \{}
\DoxyCodeLine{2969         \textcolor{keywordtype}{size\_t} cbDest;}
\DoxyCodeLine{2970         va\_list argList;}
\DoxyCodeLine{2971 }
\DoxyCodeLine{2972         \textcolor{comment}{// safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE\_MAX\_CCH and sizeof(char) is 1}}
\DoxyCodeLine{2973         cbDest = cchDest * \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{2974         va\_start(argList, pszFormat);}
\DoxyCodeLine{2975 }
\DoxyCodeLine{2976         hr = StringVPrintfExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags, pszFormat, argList);}
\DoxyCodeLine{2977 }
\DoxyCodeLine{2978         va\_end(argList);}
\DoxyCodeLine{2979     \}}
\DoxyCodeLine{2980 }
\DoxyCodeLine{2981     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{2982 \}}
\DoxyCodeLine{2983 }
\DoxyCodeLine{2984 STRSAFEAPI StringCchPrintfExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, ...)}
\DoxyCodeLine{2985 \{}
\DoxyCodeLine{2986     HRESULT hr;}
\DoxyCodeLine{2987 }
\DoxyCodeLine{2988     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{2989     \{}
\DoxyCodeLine{2990         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{2991     \}}
\DoxyCodeLine{2992     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2993     \{}
\DoxyCodeLine{2994         \textcolor{keywordtype}{size\_t} cbDest;}
\DoxyCodeLine{2995         va\_list argList;}
\DoxyCodeLine{2996 }
\DoxyCodeLine{2997         \textcolor{comment}{// safe to multiply cchDest * sizeof(wchar\_t) since cchDest < STRSAFE\_MAX\_CCH and sizeof(wchar\_t) is 2}}
\DoxyCodeLine{2998         cbDest = cchDest * \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{2999         va\_start(argList, pszFormat);}
\DoxyCodeLine{3000 }
\DoxyCodeLine{3001         hr = StringVPrintfExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags, pszFormat, argList);}
\DoxyCodeLine{3002 }
\DoxyCodeLine{3003         va\_end(argList);}
\DoxyCodeLine{3004     \}}
\DoxyCodeLine{3005 }
\DoxyCodeLine{3006     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{3007 \}}
\DoxyCodeLine{3008 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{3009 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{3010 }
\DoxyCodeLine{3011 }
\DoxyCodeLine{3012 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{3013 \textcolor{comment}{/*++}}
\DoxyCodeLine{3014 \textcolor{comment}{}}
\DoxyCodeLine{3015 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{3016 \textcolor{comment}{StringCbPrintfEx(}}
\DoxyCodeLine{3017 \textcolor{comment}{    OUT LPTSTR  pszDest         OPTIONAL,}}
\DoxyCodeLine{3018 \textcolor{comment}{    IN  size\_t  cbDest,}}
\DoxyCodeLine{3019 \textcolor{comment}{    OUT LPTSTR* ppszDestEnd     OPTIONAL,}}
\DoxyCodeLine{3020 \textcolor{comment}{    OUT size\_t* pcbRemaining    OPTIONAL,}}
\DoxyCodeLine{3021 \textcolor{comment}{    IN  DWORD   dwFlags,}}
\DoxyCodeLine{3022 \textcolor{comment}{    IN  LPCTSTR pszFormat       OPTIONAL,}}
\DoxyCodeLine{3023 \textcolor{comment}{    ...}}
\DoxyCodeLine{3024 \textcolor{comment}{    );}}
\DoxyCodeLine{3025 \textcolor{comment}{}}
\DoxyCodeLine{3026 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{3027 \textcolor{comment}{}}
\DoxyCodeLine{3028 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'sprintf' with}}
\DoxyCodeLine{3029 \textcolor{comment}{    some additional parameters.  In addition to functionality provided by}}
\DoxyCodeLine{3030 \textcolor{comment}{    StringCbPrintf, this routine also returns a pointer to the end of the}}
\DoxyCodeLine{3031 \textcolor{comment}{    destination string and the number of bytes left in the destination string}}
\DoxyCodeLine{3032 \textcolor{comment}{    including the null terminator. The flags parameter allows additional controls.}}
\DoxyCodeLine{3033 \textcolor{comment}{}}
\DoxyCodeLine{3034 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{3035 \textcolor{comment}{}}
\DoxyCodeLine{3036 \textcolor{comment}{    pszDest         -\/   destination string}}
\DoxyCodeLine{3037 \textcolor{comment}{}}
\DoxyCodeLine{3038 \textcolor{comment}{    cbDest          -\/   size of destination buffer in bytes.}}
\DoxyCodeLine{3039 \textcolor{comment}{                        length must be sufficient to contain the resulting}}
\DoxyCodeLine{3040 \textcolor{comment}{                        formatted string plus the null terminator.}}
\DoxyCodeLine{3041 \textcolor{comment}{}}
\DoxyCodeLine{3042 \textcolor{comment}{    ppszDestEnd     -\/   if ppszDestEnd is non-\/null, the function will return a}}
\DoxyCodeLine{3043 \textcolor{comment}{                        pointer to the end of the destination string.  If the}}
\DoxyCodeLine{3044 \textcolor{comment}{                        function printed any data, the result will point to the}}
\DoxyCodeLine{3045 \textcolor{comment}{                        null termination character}}
\DoxyCodeLine{3046 \textcolor{comment}{}}
\DoxyCodeLine{3047 \textcolor{comment}{    pcbRemaining    -\/   if pcbRemaining is non-\/null, the function will return}}
\DoxyCodeLine{3048 \textcolor{comment}{                        the number of bytes left in the destination string,}}
\DoxyCodeLine{3049 \textcolor{comment}{                        including the null terminator}}
\DoxyCodeLine{3050 \textcolor{comment}{}}
\DoxyCodeLine{3051 \textcolor{comment}{    dwFlags         -\/   controls some details of the string copy:}}
\DoxyCodeLine{3052 \textcolor{comment}{}}
\DoxyCodeLine{3053 \textcolor{comment}{        STRSAFE\_FILL\_BEHIND\_NULL}}
\DoxyCodeLine{3054 \textcolor{comment}{                    if the function succeeds, the low byte of dwFlags will be}}
\DoxyCodeLine{3055 \textcolor{comment}{                    used to fill the uninitialize part of destination buffer}}
\DoxyCodeLine{3056 \textcolor{comment}{                    behind the null terminator}}
\DoxyCodeLine{3057 \textcolor{comment}{}}
\DoxyCodeLine{3058 \textcolor{comment}{        STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{3059 \textcolor{comment}{                    treat NULL string pointers like empty strings (TEXT("{}"{}))}}
\DoxyCodeLine{3060 \textcolor{comment}{}}
\DoxyCodeLine{3061 \textcolor{comment}{        STRSAFE\_FILL\_ON\_FAILURE}}
\DoxyCodeLine{3062 \textcolor{comment}{                    if the function fails, the low byte of dwFlags will be}}
\DoxyCodeLine{3063 \textcolor{comment}{                    used to fill all of the destination buffer, and it will}}
\DoxyCodeLine{3064 \textcolor{comment}{                    be null terminated. This will overwrite any truncated}}
\DoxyCodeLine{3065 \textcolor{comment}{                    string returned when the failure is}}
\DoxyCodeLine{3066 \textcolor{comment}{                    STRSAFE\_E\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{3067 \textcolor{comment}{}}
\DoxyCodeLine{3068 \textcolor{comment}{        STRSAFE\_NO\_TRUNCATION /}}
\DoxyCodeLine{3069 \textcolor{comment}{        STRSAFE\_NULL\_ON\_FAILURE}}
\DoxyCodeLine{3070 \textcolor{comment}{                    if the function fails, the destination buffer will be set}}
\DoxyCodeLine{3071 \textcolor{comment}{                    to the empty string. This will overwrite any truncated string}}
\DoxyCodeLine{3072 \textcolor{comment}{                    returned when the failure is STRSAFE\_E\_INSUFFICIENT\_BUFFER.}}
\DoxyCodeLine{3073 \textcolor{comment}{}}
\DoxyCodeLine{3074 \textcolor{comment}{    pszFormat       -\/   format string which must be null terminated}}
\DoxyCodeLine{3075 \textcolor{comment}{}}
\DoxyCodeLine{3076 \textcolor{comment}{    ...             -\/   additional parameters to be formatted according to}}
\DoxyCodeLine{3077 \textcolor{comment}{                        the format string}}
\DoxyCodeLine{3078 \textcolor{comment}{}}
\DoxyCodeLine{3079 \textcolor{comment}{Notes:}}
\DoxyCodeLine{3080 \textcolor{comment}{    Behavior is undefined if destination, format strings or any arguments}}
\DoxyCodeLine{3081 \textcolor{comment}{    strings overlap.}}
\DoxyCodeLine{3082 \textcolor{comment}{}}
\DoxyCodeLine{3083 \textcolor{comment}{    pszDest and pszFormat should not be NULL unless the STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{3084 \textcolor{comment}{    flag is specified.  If STRSAFE\_IGNORE\_NULLS is passed, both pszDest and}}
\DoxyCodeLine{3085 \textcolor{comment}{    pszFormat may be NULL.  An error may still be returned even though NULLS}}
\DoxyCodeLine{3086 \textcolor{comment}{    are ignored due to insufficient space.}}
\DoxyCodeLine{3087 \textcolor{comment}{}}
\DoxyCodeLine{3088 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{3089 \textcolor{comment}{}}
\DoxyCodeLine{3090 \textcolor{comment}{    S\_OK           -\/   if there was source data and it was all concatenated and}}
\DoxyCodeLine{3091 \textcolor{comment}{                       the resultant dest string was null terminated}}
\DoxyCodeLine{3092 \textcolor{comment}{}}
\DoxyCodeLine{3093 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{3094 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{3095 \textcolor{comment}{}}
\DoxyCodeLine{3096 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{3097 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{3098 \textcolor{comment}{                   -\/   this return value is an indication that the print}}
\DoxyCodeLine{3099 \textcolor{comment}{                       operation failed due to insufficient space. When this}}
\DoxyCodeLine{3100 \textcolor{comment}{                       error occurs, the destination buffer is modified to}}
\DoxyCodeLine{3101 \textcolor{comment}{                       contain a truncated version of the ideal result and is}}
\DoxyCodeLine{3102 \textcolor{comment}{                       null terminated. This is useful for situations where}}
\DoxyCodeLine{3103 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{3104 \textcolor{comment}{}}
\DoxyCodeLine{3105 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{3106 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{3107 \textcolor{comment}{}}
\DoxyCodeLine{3108 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{3109 }
\DoxyCodeLine{3110 STRSAFEAPI StringCbPrintfExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, ...);}
\DoxyCodeLine{3111 STRSAFEAPI StringCbPrintfExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, ...);}
\DoxyCodeLine{3112 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{3113 \textcolor{preprocessor}{\#define StringCbPrintfEx  StringCbPrintfExW}}
\DoxyCodeLine{3114 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3115 \textcolor{preprocessor}{\#define StringCbPrintfEx  StringCbPrintfExA}}
\DoxyCodeLine{3116 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{3117 }
\DoxyCodeLine{3118 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{3119 STRSAFEAPI StringCbPrintfExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, ...)}
\DoxyCodeLine{3120 \{}
\DoxyCodeLine{3121     HRESULT hr;}
\DoxyCodeLine{3122     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{3123     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{3124 }
\DoxyCodeLine{3125     cchDest = cbDest / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{3126 }
\DoxyCodeLine{3127     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{3128     \{}
\DoxyCodeLine{3129         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{3130     \}}
\DoxyCodeLine{3131     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3132     \{}
\DoxyCodeLine{3133         va\_list argList;}
\DoxyCodeLine{3134 }
\DoxyCodeLine{3135         va\_start(argList, pszFormat);}
\DoxyCodeLine{3136 }
\DoxyCodeLine{3137         hr = StringVPrintfExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, \&cchRemaining, dwFlags, pszFormat, argList);}
\DoxyCodeLine{3138 }
\DoxyCodeLine{3139         va\_end(argList);}
\DoxyCodeLine{3140     \}}
\DoxyCodeLine{3141 }
\DoxyCodeLine{3142     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{3143     \{}
\DoxyCodeLine{3144         \textcolor{keywordflow}{if} (pcbRemaining)}
\DoxyCodeLine{3145         \{}
\DoxyCodeLine{3146             \textcolor{comment}{// safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE\_MAX\_CCH and sizeof(char) is 1}}
\DoxyCodeLine{3147             *pcbRemaining = (cchRemaining * \textcolor{keyword}{sizeof}(char)) + (cbDest \% \textcolor{keyword}{sizeof}(char));}
\DoxyCodeLine{3148         \}}
\DoxyCodeLine{3149     \}}
\DoxyCodeLine{3150 }
\DoxyCodeLine{3151     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{3152 \}}
\DoxyCodeLine{3153 }
\DoxyCodeLine{3154 STRSAFEAPI StringCbPrintfExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, ...)}
\DoxyCodeLine{3155 \{}
\DoxyCodeLine{3156     HRESULT hr;}
\DoxyCodeLine{3157     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{3158     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{3159 }
\DoxyCodeLine{3160     cchDest = cbDest / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{3161 }
\DoxyCodeLine{3162     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{3163     \{}
\DoxyCodeLine{3164         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{3165     \}}
\DoxyCodeLine{3166     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3167     \{}
\DoxyCodeLine{3168         va\_list argList;}
\DoxyCodeLine{3169 }
\DoxyCodeLine{3170         va\_start(argList, pszFormat);}
\DoxyCodeLine{3171 }
\DoxyCodeLine{3172         hr = StringVPrintfExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, \&cchRemaining, dwFlags, pszFormat, argList);}
\DoxyCodeLine{3173 }
\DoxyCodeLine{3174         va\_end(argList);}
\DoxyCodeLine{3175     \}}
\DoxyCodeLine{3176 }
\DoxyCodeLine{3177     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{3178     \{}
\DoxyCodeLine{3179         \textcolor{keywordflow}{if} (pcbRemaining)}
\DoxyCodeLine{3180         \{}
\DoxyCodeLine{3181             \textcolor{comment}{// safe to multiply cchRemaining * sizeof(wchar\_t) since cchRemaining < STRSAFE\_MAX\_CCH and sizeof(wchar\_t) is 2}}
\DoxyCodeLine{3182             *pcbRemaining = (cchRemaining * \textcolor{keyword}{sizeof}(wchar\_t)) + (cbDest \% \textcolor{keyword}{sizeof}(wchar\_t));}
\DoxyCodeLine{3183         \}}
\DoxyCodeLine{3184     \}}
\DoxyCodeLine{3185 }
\DoxyCodeLine{3186     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{3187 \}}
\DoxyCodeLine{3188 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{3189 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{3190 }
\DoxyCodeLine{3191 }
\DoxyCodeLine{3192 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{3193 \textcolor{comment}{/*++}}
\DoxyCodeLine{3194 \textcolor{comment}{}}
\DoxyCodeLine{3195 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{3196 \textcolor{comment}{StringCchVPrintfEx(}}
\DoxyCodeLine{3197 \textcolor{comment}{    OUT LPTSTR  pszDest         OPTIONAL,}}
\DoxyCodeLine{3198 \textcolor{comment}{    IN  size\_t  cchDest,}}
\DoxyCodeLine{3199 \textcolor{comment}{    OUT LPTSTR* ppszDestEnd     OPTIONAL,}}
\DoxyCodeLine{3200 \textcolor{comment}{    OUT size\_t* pcchRemaining   OPTIONAL,}}
\DoxyCodeLine{3201 \textcolor{comment}{    IN  DWORD   dwFlags,}}
\DoxyCodeLine{3202 \textcolor{comment}{    IN  LPCTSTR pszFormat       OPTIONAL,}}
\DoxyCodeLine{3203 \textcolor{comment}{    IN  va\_list argList}}
\DoxyCodeLine{3204 \textcolor{comment}{    );}}
\DoxyCodeLine{3205 \textcolor{comment}{}}
\DoxyCodeLine{3206 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{3207 \textcolor{comment}{}}
\DoxyCodeLine{3208 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'vsprintf' with}}
\DoxyCodeLine{3209 \textcolor{comment}{    some additional parameters.  In addition to functionality provided by}}
\DoxyCodeLine{3210 \textcolor{comment}{    StringCchVPrintf, this routine also returns a pointer to the end of the}}
\DoxyCodeLine{3211 \textcolor{comment}{    destination string and the number of characters left in the destination string}}
\DoxyCodeLine{3212 \textcolor{comment}{    including the null terminator. The flags parameter allows additional controls.}}
\DoxyCodeLine{3213 \textcolor{comment}{}}
\DoxyCodeLine{3214 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{3215 \textcolor{comment}{}}
\DoxyCodeLine{3216 \textcolor{comment}{    pszDest         -\/   destination string}}
\DoxyCodeLine{3217 \textcolor{comment}{}}
\DoxyCodeLine{3218 \textcolor{comment}{    cchDest         -\/   size of destination buffer in characters.}}
\DoxyCodeLine{3219 \textcolor{comment}{                        length must be sufficient to contain the resulting}}
\DoxyCodeLine{3220 \textcolor{comment}{                        formatted string plus the null terminator.}}
\DoxyCodeLine{3221 \textcolor{comment}{}}
\DoxyCodeLine{3222 \textcolor{comment}{    ppszDestEnd     -\/   if ppszDestEnd is non-\/null, the function will return a}}
\DoxyCodeLine{3223 \textcolor{comment}{                        pointer to the end of the destination string.  If the}}
\DoxyCodeLine{3224 \textcolor{comment}{                        function printed any data, the result will point to the}}
\DoxyCodeLine{3225 \textcolor{comment}{                        null termination character}}
\DoxyCodeLine{3226 \textcolor{comment}{}}
\DoxyCodeLine{3227 \textcolor{comment}{    pcchRemaining   -\/   if pcchRemaining is non-\/null, the function will return}}
\DoxyCodeLine{3228 \textcolor{comment}{                        the number of characters left in the destination string,}}
\DoxyCodeLine{3229 \textcolor{comment}{                        including the null terminator}}
\DoxyCodeLine{3230 \textcolor{comment}{}}
\DoxyCodeLine{3231 \textcolor{comment}{    dwFlags         -\/   controls some details of the string copy:}}
\DoxyCodeLine{3232 \textcolor{comment}{}}
\DoxyCodeLine{3233 \textcolor{comment}{        STRSAFE\_FILL\_BEHIND\_NULL}}
\DoxyCodeLine{3234 \textcolor{comment}{                    if the function succeeds, the low byte of dwFlags will be}}
\DoxyCodeLine{3235 \textcolor{comment}{                    used to fill the uninitialize part of destination buffer}}
\DoxyCodeLine{3236 \textcolor{comment}{                    behind the null terminator}}
\DoxyCodeLine{3237 \textcolor{comment}{}}
\DoxyCodeLine{3238 \textcolor{comment}{        STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{3239 \textcolor{comment}{                    treat NULL string pointers like empty strings (TEXT("{}"{}))}}
\DoxyCodeLine{3240 \textcolor{comment}{}}
\DoxyCodeLine{3241 \textcolor{comment}{        STRSAFE\_FILL\_ON\_FAILURE}}
\DoxyCodeLine{3242 \textcolor{comment}{                    if the function fails, the low byte of dwFlags will be}}
\DoxyCodeLine{3243 \textcolor{comment}{                    used to fill all of the destination buffer, and it will}}
\DoxyCodeLine{3244 \textcolor{comment}{                    be null terminated. This will overwrite any truncated}}
\DoxyCodeLine{3245 \textcolor{comment}{                    string returned when the failure is}}
\DoxyCodeLine{3246 \textcolor{comment}{                    STRSAFE\_E\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{3247 \textcolor{comment}{}}
\DoxyCodeLine{3248 \textcolor{comment}{        STRSAFE\_NO\_TRUNCATION /}}
\DoxyCodeLine{3249 \textcolor{comment}{        STRSAFE\_NULL\_ON\_FAILURE}}
\DoxyCodeLine{3250 \textcolor{comment}{                    if the function fails, the destination buffer will be set}}
\DoxyCodeLine{3251 \textcolor{comment}{                    to the empty string. This will overwrite any truncated string}}
\DoxyCodeLine{3252 \textcolor{comment}{                    returned when the failure is STRSAFE\_E\_INSUFFICIENT\_BUFFER.}}
\DoxyCodeLine{3253 \textcolor{comment}{}}
\DoxyCodeLine{3254 \textcolor{comment}{    pszFormat       -\/   format string which must be null terminated}}
\DoxyCodeLine{3255 \textcolor{comment}{}}
\DoxyCodeLine{3256 \textcolor{comment}{    argList         -\/   va\_list from the variable arguments according to the}}
\DoxyCodeLine{3257 \textcolor{comment}{                        stdarg.h convention}}
\DoxyCodeLine{3258 \textcolor{comment}{}}
\DoxyCodeLine{3259 \textcolor{comment}{Notes:}}
\DoxyCodeLine{3260 \textcolor{comment}{    Behavior is undefined if destination, format strings or any arguments}}
\DoxyCodeLine{3261 \textcolor{comment}{    strings overlap.}}
\DoxyCodeLine{3262 \textcolor{comment}{}}
\DoxyCodeLine{3263 \textcolor{comment}{    pszDest and pszFormat should not be NULL unless the STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{3264 \textcolor{comment}{    flag is specified.  If STRSAFE\_IGNORE\_NULLS is passed, both pszDest and}}
\DoxyCodeLine{3265 \textcolor{comment}{    pszFormat may be NULL.  An error may still be returned even though NULLS}}
\DoxyCodeLine{3266 \textcolor{comment}{    are ignored due to insufficient space.}}
\DoxyCodeLine{3267 \textcolor{comment}{}}
\DoxyCodeLine{3268 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{3269 \textcolor{comment}{}}
\DoxyCodeLine{3270 \textcolor{comment}{    S\_OK           -\/   if there was source data and it was all concatenated and}}
\DoxyCodeLine{3271 \textcolor{comment}{                       the resultant dest string was null terminated}}
\DoxyCodeLine{3272 \textcolor{comment}{}}
\DoxyCodeLine{3273 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{3274 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{3275 \textcolor{comment}{}}
\DoxyCodeLine{3276 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{3277 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{3278 \textcolor{comment}{                   -\/   this return value is an indication that the print}}
\DoxyCodeLine{3279 \textcolor{comment}{                       operation failed due to insufficient space. When this}}
\DoxyCodeLine{3280 \textcolor{comment}{                       error occurs, the destination buffer is modified to}}
\DoxyCodeLine{3281 \textcolor{comment}{                       contain a truncated version of the ideal result and is}}
\DoxyCodeLine{3282 \textcolor{comment}{                       null terminated. This is useful for situations where}}
\DoxyCodeLine{3283 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{3284 \textcolor{comment}{}}
\DoxyCodeLine{3285 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{3286 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{3287 \textcolor{comment}{}}
\DoxyCodeLine{3288 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{3289 }
\DoxyCodeLine{3290 STRSAFEAPI StringCchVPrintfExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, va\_list argList);}
\DoxyCodeLine{3291 STRSAFEAPI StringCchVPrintfExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, va\_list argList);}
\DoxyCodeLine{3292 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{3293 \textcolor{preprocessor}{\#define StringCchVPrintfEx  StringCchVPrintfExW}}
\DoxyCodeLine{3294 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3295 \textcolor{preprocessor}{\#define StringCchVPrintfEx  StringCchVPrintfExA}}
\DoxyCodeLine{3296 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{3297 }
\DoxyCodeLine{3298 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{3299 STRSAFEAPI StringCchVPrintfExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, va\_list argList)}
\DoxyCodeLine{3300 \{}
\DoxyCodeLine{3301     HRESULT hr;}
\DoxyCodeLine{3302 }
\DoxyCodeLine{3303     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{3304     \{}
\DoxyCodeLine{3305         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{3306     \}}
\DoxyCodeLine{3307     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3308     \{}
\DoxyCodeLine{3309         \textcolor{keywordtype}{size\_t} cbDest;}
\DoxyCodeLine{3310 }
\DoxyCodeLine{3311         \textcolor{comment}{// safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE\_MAX\_CCH and sizeof(char) is 1}}
\DoxyCodeLine{3312         cbDest = cchDest * \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{3313 }
\DoxyCodeLine{3314         hr = StringVPrintfExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags, pszFormat, argList);}
\DoxyCodeLine{3315     \}}
\DoxyCodeLine{3316 }
\DoxyCodeLine{3317     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{3318 \}}
\DoxyCodeLine{3319 }
\DoxyCodeLine{3320 STRSAFEAPI StringCchVPrintfExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, va\_list argList)}
\DoxyCodeLine{3321 \{}
\DoxyCodeLine{3322     HRESULT hr;}
\DoxyCodeLine{3323 }
\DoxyCodeLine{3324     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{3325     \{}
\DoxyCodeLine{3326         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{3327     \}}
\DoxyCodeLine{3328     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3329     \{}
\DoxyCodeLine{3330         \textcolor{keywordtype}{size\_t} cbDest;}
\DoxyCodeLine{3331 }
\DoxyCodeLine{3332         \textcolor{comment}{// safe to multiply cchDest * sizeof(wchar\_t) since cchDest < STRSAFE\_MAX\_CCH and sizeof(wchar\_t) is 2}}
\DoxyCodeLine{3333         cbDest = cchDest * \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{3334 }
\DoxyCodeLine{3335         hr = StringVPrintfExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags, pszFormat, argList);}
\DoxyCodeLine{3336     \}}
\DoxyCodeLine{3337 }
\DoxyCodeLine{3338     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{3339 \}}
\DoxyCodeLine{3340 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{3341 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{3342 }
\DoxyCodeLine{3343 }
\DoxyCodeLine{3344 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{3345 \textcolor{comment}{/*++}}
\DoxyCodeLine{3346 \textcolor{comment}{}}
\DoxyCodeLine{3347 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{3348 \textcolor{comment}{StringCbVPrintfEx(}}
\DoxyCodeLine{3349 \textcolor{comment}{    OUT LPTSTR  pszDest         OPTIONAL,}}
\DoxyCodeLine{3350 \textcolor{comment}{    IN  size\_t  cbDest,}}
\DoxyCodeLine{3351 \textcolor{comment}{    OUT LPTSTR* ppszDestEnd     OPTIONAL,}}
\DoxyCodeLine{3352 \textcolor{comment}{    OUT size\_t* pcbRemaining    OPTIONAL,}}
\DoxyCodeLine{3353 \textcolor{comment}{    IN  DWORD   dwFlags,}}
\DoxyCodeLine{3354 \textcolor{comment}{    IN  LPCTSTR pszFormat       OPTIONAL,}}
\DoxyCodeLine{3355 \textcolor{comment}{    IN  va\_list argList}}
\DoxyCodeLine{3356 \textcolor{comment}{    );}}
\DoxyCodeLine{3357 \textcolor{comment}{}}
\DoxyCodeLine{3358 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{3359 \textcolor{comment}{}}
\DoxyCodeLine{3360 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'vsprintf' with}}
\DoxyCodeLine{3361 \textcolor{comment}{    some additional parameters.  In addition to functionality provided by}}
\DoxyCodeLine{3362 \textcolor{comment}{    StringCbVPrintf, this routine also returns a pointer to the end of the}}
\DoxyCodeLine{3363 \textcolor{comment}{    destination string and the number of characters left in the destination string}}
\DoxyCodeLine{3364 \textcolor{comment}{    including the null terminator. The flags parameter allows additional controls.}}
\DoxyCodeLine{3365 \textcolor{comment}{}}
\DoxyCodeLine{3366 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{3367 \textcolor{comment}{}}
\DoxyCodeLine{3368 \textcolor{comment}{    pszDest         -\/   destination string}}
\DoxyCodeLine{3369 \textcolor{comment}{}}
\DoxyCodeLine{3370 \textcolor{comment}{    cbDest          -\/   size of destination buffer in bytes.}}
\DoxyCodeLine{3371 \textcolor{comment}{                        length must be sufficient to contain the resulting}}
\DoxyCodeLine{3372 \textcolor{comment}{                        formatted string plus the null terminator.}}
\DoxyCodeLine{3373 \textcolor{comment}{}}
\DoxyCodeLine{3374 \textcolor{comment}{    ppszDestEnd     -\/   if ppszDestEnd is non-\/null, the function will return}}
\DoxyCodeLine{3375 \textcolor{comment}{                        a pointer to the end of the destination string.  If the}}
\DoxyCodeLine{3376 \textcolor{comment}{                        function printed any data, the result will point to the}}
\DoxyCodeLine{3377 \textcolor{comment}{                        null termination character}}
\DoxyCodeLine{3378 \textcolor{comment}{}}
\DoxyCodeLine{3379 \textcolor{comment}{    pcbRemaining    -\/   if pcbRemaining is non-\/null, the function will return}}
\DoxyCodeLine{3380 \textcolor{comment}{                        the number of bytes left in the destination string,}}
\DoxyCodeLine{3381 \textcolor{comment}{                        including the null terminator}}
\DoxyCodeLine{3382 \textcolor{comment}{}}
\DoxyCodeLine{3383 \textcolor{comment}{    dwFlags         -\/   controls some details of the string copy:}}
\DoxyCodeLine{3384 \textcolor{comment}{}}
\DoxyCodeLine{3385 \textcolor{comment}{        STRSAFE\_FILL\_BEHIND\_NULL}}
\DoxyCodeLine{3386 \textcolor{comment}{                    if the function succeeds, the low byte of dwFlags will be}}
\DoxyCodeLine{3387 \textcolor{comment}{                    used to fill the uninitialize part of destination buffer}}
\DoxyCodeLine{3388 \textcolor{comment}{                    behind the null terminator}}
\DoxyCodeLine{3389 \textcolor{comment}{}}
\DoxyCodeLine{3390 \textcolor{comment}{        STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{3391 \textcolor{comment}{                    treat NULL string pointers like empty strings (TEXT("{}"{}))}}
\DoxyCodeLine{3392 \textcolor{comment}{}}
\DoxyCodeLine{3393 \textcolor{comment}{        STRSAFE\_FILL\_ON\_FAILURE}}
\DoxyCodeLine{3394 \textcolor{comment}{                    if the function fails, the low byte of dwFlags will be}}
\DoxyCodeLine{3395 \textcolor{comment}{                    used to fill all of the destination buffer, and it will}}
\DoxyCodeLine{3396 \textcolor{comment}{                    be null terminated. This will overwrite any truncated}}
\DoxyCodeLine{3397 \textcolor{comment}{                    string returned when the failure is}}
\DoxyCodeLine{3398 \textcolor{comment}{                    STRSAFE\_E\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{3399 \textcolor{comment}{}}
\DoxyCodeLine{3400 \textcolor{comment}{        STRSAFE\_NO\_TRUNCATION /}}
\DoxyCodeLine{3401 \textcolor{comment}{        STRSAFE\_NULL\_ON\_FAILURE}}
\DoxyCodeLine{3402 \textcolor{comment}{                    if the function fails, the destination buffer will be set}}
\DoxyCodeLine{3403 \textcolor{comment}{                    to the empty string. This will overwrite any truncated string}}
\DoxyCodeLine{3404 \textcolor{comment}{                    returned when the failure is STRSAFE\_E\_INSUFFICIENT\_BUFFER.}}
\DoxyCodeLine{3405 \textcolor{comment}{}}
\DoxyCodeLine{3406 \textcolor{comment}{    pszFormat       -\/   format string which must be null terminated}}
\DoxyCodeLine{3407 \textcolor{comment}{}}
\DoxyCodeLine{3408 \textcolor{comment}{    argList         -\/   va\_list from the variable arguments according to the}}
\DoxyCodeLine{3409 \textcolor{comment}{                        stdarg.h convention}}
\DoxyCodeLine{3410 \textcolor{comment}{}}
\DoxyCodeLine{3411 \textcolor{comment}{Notes:}}
\DoxyCodeLine{3412 \textcolor{comment}{    Behavior is undefined if destination, format strings or any arguments}}
\DoxyCodeLine{3413 \textcolor{comment}{    strings overlap.}}
\DoxyCodeLine{3414 \textcolor{comment}{}}
\DoxyCodeLine{3415 \textcolor{comment}{    pszDest and pszFormat should not be NULL unless the STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{3416 \textcolor{comment}{    flag is specified.  If STRSAFE\_IGNORE\_NULLS is passed, both pszDest and}}
\DoxyCodeLine{3417 \textcolor{comment}{    pszFormat may be NULL.  An error may still be returned even though NULLS}}
\DoxyCodeLine{3418 \textcolor{comment}{    are ignored due to insufficient space.}}
\DoxyCodeLine{3419 \textcolor{comment}{}}
\DoxyCodeLine{3420 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{3421 \textcolor{comment}{}}
\DoxyCodeLine{3422 \textcolor{comment}{    S\_OK           -\/   if there was source data and it was all concatenated and}}
\DoxyCodeLine{3423 \textcolor{comment}{                       the resultant dest string was null terminated}}
\DoxyCodeLine{3424 \textcolor{comment}{}}
\DoxyCodeLine{3425 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{3426 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{3427 \textcolor{comment}{}}
\DoxyCodeLine{3428 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{3429 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{3430 \textcolor{comment}{                   -\/   this return value is an indication that the print}}
\DoxyCodeLine{3431 \textcolor{comment}{                       operation failed due to insufficient space. When this}}
\DoxyCodeLine{3432 \textcolor{comment}{                       error occurs, the destination buffer is modified to}}
\DoxyCodeLine{3433 \textcolor{comment}{                       contain a truncated version of the ideal result and is}}
\DoxyCodeLine{3434 \textcolor{comment}{                       null terminated. This is useful for situations where}}
\DoxyCodeLine{3435 \textcolor{comment}{                       truncation is ok.}}
\DoxyCodeLine{3436 \textcolor{comment}{}}
\DoxyCodeLine{3437 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{3438 \textcolor{comment}{    return value of this function}}
\DoxyCodeLine{3439 \textcolor{comment}{}}
\DoxyCodeLine{3440 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{3441 }
\DoxyCodeLine{3442 STRSAFEAPI StringCbVPrintfExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, va\_list argList);}
\DoxyCodeLine{3443 STRSAFEAPI StringCbVPrintfExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, va\_list argList);}
\DoxyCodeLine{3444 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{3445 \textcolor{preprocessor}{\#define StringCbVPrintfEx  StringCbVPrintfExW}}
\DoxyCodeLine{3446 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3447 \textcolor{preprocessor}{\#define StringCbVPrintfEx  StringCbVPrintfExA}}
\DoxyCodeLine{3448 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{3449 }
\DoxyCodeLine{3450 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{3451 STRSAFEAPI StringCbVPrintfExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, va\_list argList)}
\DoxyCodeLine{3452 \{}
\DoxyCodeLine{3453     HRESULT hr;}
\DoxyCodeLine{3454     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{3455     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{3456 }
\DoxyCodeLine{3457     cchDest = cbDest / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{3458 }
\DoxyCodeLine{3459     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{3460     \{}
\DoxyCodeLine{3461         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{3462     \}}
\DoxyCodeLine{3463     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3464     \{}
\DoxyCodeLine{3465         hr = StringVPrintfExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, \&cchRemaining, dwFlags, pszFormat, argList);}
\DoxyCodeLine{3466     \}}
\DoxyCodeLine{3467 }
\DoxyCodeLine{3468     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{3469     \{}
\DoxyCodeLine{3470         \textcolor{keywordflow}{if} (pcbRemaining)}
\DoxyCodeLine{3471         \{}
\DoxyCodeLine{3472             \textcolor{comment}{// safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE\_MAX\_CCH and sizeof(char) is 1}}
\DoxyCodeLine{3473             *pcbRemaining = (cchRemaining * \textcolor{keyword}{sizeof}(char)) + (cbDest \% \textcolor{keyword}{sizeof}(char));}
\DoxyCodeLine{3474         \}}
\DoxyCodeLine{3475     \}}
\DoxyCodeLine{3476 }
\DoxyCodeLine{3477     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{3478 \}}
\DoxyCodeLine{3479 }
\DoxyCodeLine{3480 STRSAFEAPI StringCbVPrintfExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, va\_list argList)}
\DoxyCodeLine{3481 \{}
\DoxyCodeLine{3482     HRESULT hr;}
\DoxyCodeLine{3483     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{3484     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{3485 }
\DoxyCodeLine{3486     cchDest = cbDest / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{3487 }
\DoxyCodeLine{3488     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{3489     \{}
\DoxyCodeLine{3490         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{3491     \}}
\DoxyCodeLine{3492     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3493     \{}
\DoxyCodeLine{3494         hr = StringVPrintfExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, \&cchRemaining, dwFlags, pszFormat, argList);}
\DoxyCodeLine{3495     \}}
\DoxyCodeLine{3496 }
\DoxyCodeLine{3497     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{3498     \{}
\DoxyCodeLine{3499         \textcolor{keywordflow}{if} (pcbRemaining)}
\DoxyCodeLine{3500         \{}
\DoxyCodeLine{3501             \textcolor{comment}{// safe to multiply cchRemaining * sizeof(wchar\_t) since cchRemaining < STRSAFE\_MAX\_CCH and sizeof(wchar\_t) is 2}}
\DoxyCodeLine{3502             *pcbRemaining = (cchRemaining * \textcolor{keyword}{sizeof}(wchar\_t)) + (cbDest \% \textcolor{keyword}{sizeof}(wchar\_t));}
\DoxyCodeLine{3503         \}}
\DoxyCodeLine{3504     \}}
\DoxyCodeLine{3505 }
\DoxyCodeLine{3506     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{3507 \}}
\DoxyCodeLine{3508 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{3509 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{3510 }
\DoxyCodeLine{3511 }
\DoxyCodeLine{3512 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{3513 \textcolor{comment}{/*++}}
\DoxyCodeLine{3514 \textcolor{comment}{}}
\DoxyCodeLine{3515 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{3516 \textcolor{comment}{StringCchGets(}}
\DoxyCodeLine{3517 \textcolor{comment}{    OUT LPTSTR  pszDest,}}
\DoxyCodeLine{3518 \textcolor{comment}{    IN  size\_t  cchDest}}
\DoxyCodeLine{3519 \textcolor{comment}{    );}}
\DoxyCodeLine{3520 \textcolor{comment}{}}
\DoxyCodeLine{3521 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{3522 \textcolor{comment}{}}
\DoxyCodeLine{3523 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'gets'.}}
\DoxyCodeLine{3524 \textcolor{comment}{    The size of the destination buffer (in characters) is a parameter and}}
\DoxyCodeLine{3525 \textcolor{comment}{    this function will not write past the end of this buffer and it will}}
\DoxyCodeLine{3526 \textcolor{comment}{    ALWAYS null terminate the destination buffer (unless it is zero length).}}
\DoxyCodeLine{3527 \textcolor{comment}{}}
\DoxyCodeLine{3528 \textcolor{comment}{    This routine is not a replacement for fgets.  That function does not replace}}
\DoxyCodeLine{3529 \textcolor{comment}{    newline characters with a null terminator.}}
\DoxyCodeLine{3530 \textcolor{comment}{}}
\DoxyCodeLine{3531 \textcolor{comment}{    This function returns a hresult, and not a pointer.  It returns}}
\DoxyCodeLine{3532 \textcolor{comment}{    S\_OK if any characters were read from stdin and copied to pszDest and}}
\DoxyCodeLine{3533 \textcolor{comment}{    pszDest was null terminated, otherwise it will return a failure code.}}
\DoxyCodeLine{3534 \textcolor{comment}{}}
\DoxyCodeLine{3535 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{3536 \textcolor{comment}{}}
\DoxyCodeLine{3537 \textcolor{comment}{    pszDest     -\/   destination string}}
\DoxyCodeLine{3538 \textcolor{comment}{}}
\DoxyCodeLine{3539 \textcolor{comment}{    cchDest     -\/   size of destination buffer in characters.}}
\DoxyCodeLine{3540 \textcolor{comment}{}}
\DoxyCodeLine{3541 \textcolor{comment}{Notes:}}
\DoxyCodeLine{3542 \textcolor{comment}{    pszDest should not be NULL. See StringCchGetsEx if you require the handling}}
\DoxyCodeLine{3543 \textcolor{comment}{    of NULL values.}}
\DoxyCodeLine{3544 \textcolor{comment}{}}
\DoxyCodeLine{3545 \textcolor{comment}{    cchDest must be > 1 for this function to succeed.}}
\DoxyCodeLine{3546 \textcolor{comment}{}}
\DoxyCodeLine{3547 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{3548 \textcolor{comment}{}}
\DoxyCodeLine{3549 \textcolor{comment}{    S\_OK           -\/   data was read from stdin and copied, and the resultant}}
\DoxyCodeLine{3550 \textcolor{comment}{                       dest string was null terminated}}
\DoxyCodeLine{3551 \textcolor{comment}{}}
\DoxyCodeLine{3552 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{3553 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{3554 \textcolor{comment}{}}
\DoxyCodeLine{3555 \textcolor{comment}{      STRSAFE\_E\_END\_OF\_FILE /}}
\DoxyCodeLine{3556 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_HANDLE\_EOF}}
\DoxyCodeLine{3557 \textcolor{comment}{                   -\/   this return value indicates an error or end-\/of-\/file}}
\DoxyCodeLine{3558 \textcolor{comment}{                       condition, use feof or ferror to determine which one has}}
\DoxyCodeLine{3559 \textcolor{comment}{                       occured.}}
\DoxyCodeLine{3560 \textcolor{comment}{}}
\DoxyCodeLine{3561 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{3562 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{3563 \textcolor{comment}{                   -\/   this return value is an indication that there was}}
\DoxyCodeLine{3564 \textcolor{comment}{                       insufficient space in the destination buffer to copy any}}
\DoxyCodeLine{3565 \textcolor{comment}{                       data}}
\DoxyCodeLine{3566 \textcolor{comment}{}}
\DoxyCodeLine{3567 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{3568 \textcolor{comment}{    return value of this function.}}
\DoxyCodeLine{3569 \textcolor{comment}{}}
\DoxyCodeLine{3570 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{3571 }
\DoxyCodeLine{3572 \textcolor{preprocessor}{\#ifndef STRSAFE\_LIB\_IMPL}}
\DoxyCodeLine{3573 STRSAFE\_INLINE\_API StringCchGetsA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest);}
\DoxyCodeLine{3574 STRSAFE\_INLINE\_API StringCchGetsW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest);}
\DoxyCodeLine{3575 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{3576 \textcolor{preprocessor}{\#define StringCchGets  StringCchGetsW}}
\DoxyCodeLine{3577 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3578 \textcolor{preprocessor}{\#define StringCchGets  StringCchGetsA}}
\DoxyCodeLine{3579 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{3580 }
\DoxyCodeLine{3581 STRSAFE\_INLINE\_API StringCchGetsA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest)}
\DoxyCodeLine{3582 \{}
\DoxyCodeLine{3583     HRESULT hr;}
\DoxyCodeLine{3584 }
\DoxyCodeLine{3585     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{3586     \{}
\DoxyCodeLine{3587         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{3588     \}}
\DoxyCodeLine{3589     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3590     \{}
\DoxyCodeLine{3591         \textcolor{keywordtype}{size\_t} cbDest;}
\DoxyCodeLine{3592 }
\DoxyCodeLine{3593         \textcolor{comment}{// safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE\_MAX\_CCH and sizeof(char) is 1}}
\DoxyCodeLine{3594         cbDest = cchDest * \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{3595 }
\DoxyCodeLine{3596         hr = StringGetsExWorkerA(pszDest, cchDest, cbDest, NULL, NULL, 0);}
\DoxyCodeLine{3597     \}}
\DoxyCodeLine{3598 }
\DoxyCodeLine{3599     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{3600 \}}
\DoxyCodeLine{3601 }
\DoxyCodeLine{3602 STRSAFE\_INLINE\_API StringCchGetsW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest)}
\DoxyCodeLine{3603 \{}
\DoxyCodeLine{3604     HRESULT hr;}
\DoxyCodeLine{3605 }
\DoxyCodeLine{3606     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{3607     \{}
\DoxyCodeLine{3608         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{3609     \}}
\DoxyCodeLine{3610     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3611     \{}
\DoxyCodeLine{3612         \textcolor{keywordtype}{size\_t} cbDest;}
\DoxyCodeLine{3613 }
\DoxyCodeLine{3614         \textcolor{comment}{// safe to multiply cchDest * sizeof(wchar\_t) since cchDest < STRSAFE\_MAX\_CCH and sizeof(wchar\_t) is 2}}
\DoxyCodeLine{3615         cbDest = cchDest * \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{3616 }
\DoxyCodeLine{3617         hr = StringGetsExWorkerW(pszDest, cchDest, cbDest, NULL, NULL, 0);}
\DoxyCodeLine{3618     \}}
\DoxyCodeLine{3619 }
\DoxyCodeLine{3620     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{3621 \}}
\DoxyCodeLine{3622 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{3623 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_LIB\_IMPL}}
\DoxyCodeLine{3624 }
\DoxyCodeLine{3625 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{3626 \textcolor{comment}{/*++}}
\DoxyCodeLine{3627 \textcolor{comment}{}}
\DoxyCodeLine{3628 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{3629 \textcolor{comment}{StringCbGets(}}
\DoxyCodeLine{3630 \textcolor{comment}{    OUT LPTSTR  pszDest,}}
\DoxyCodeLine{3631 \textcolor{comment}{    IN  size\_t  cbDest}}
\DoxyCodeLine{3632 \textcolor{comment}{    );}}
\DoxyCodeLine{3633 \textcolor{comment}{}}
\DoxyCodeLine{3634 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{3635 \textcolor{comment}{}}
\DoxyCodeLine{3636 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'gets'.}}
\DoxyCodeLine{3637 \textcolor{comment}{    The size of the destination buffer (in bytes) is a parameter and}}
\DoxyCodeLine{3638 \textcolor{comment}{    this function will not write past the end of this buffer and it will}}
\DoxyCodeLine{3639 \textcolor{comment}{    ALWAYS null terminate the destination buffer (unless it is zero length).}}
\DoxyCodeLine{3640 \textcolor{comment}{}}
\DoxyCodeLine{3641 \textcolor{comment}{    This routine is not a replacement for fgets.  That function does not replace}}
\DoxyCodeLine{3642 \textcolor{comment}{    newline characters with a null terminator.}}
\DoxyCodeLine{3643 \textcolor{comment}{}}
\DoxyCodeLine{3644 \textcolor{comment}{    This function returns a hresult, and not a pointer.  It returns}}
\DoxyCodeLine{3645 \textcolor{comment}{    S\_OK if any characters were read from stdin and copied to pszDest}}
\DoxyCodeLine{3646 \textcolor{comment}{    and pszDest was null terminated, otherwise it will return a failure code.}}
\DoxyCodeLine{3647 \textcolor{comment}{}}
\DoxyCodeLine{3648 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{3649 \textcolor{comment}{}}
\DoxyCodeLine{3650 \textcolor{comment}{    pszDest     -\/   destination string}}
\DoxyCodeLine{3651 \textcolor{comment}{}}
\DoxyCodeLine{3652 \textcolor{comment}{    cbDest      -\/   size of destination buffer in bytes.}}
\DoxyCodeLine{3653 \textcolor{comment}{}}
\DoxyCodeLine{3654 \textcolor{comment}{Notes:}}
\DoxyCodeLine{3655 \textcolor{comment}{    pszDest should not be NULL. See StringCbGetsEx if you require the handling}}
\DoxyCodeLine{3656 \textcolor{comment}{    of NULL values.}}
\DoxyCodeLine{3657 \textcolor{comment}{}}
\DoxyCodeLine{3658 \textcolor{comment}{    cbDest must be > sizeof(TCHAR) for this function to succeed.}}
\DoxyCodeLine{3659 \textcolor{comment}{}}
\DoxyCodeLine{3660 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{3661 \textcolor{comment}{}}
\DoxyCodeLine{3662 \textcolor{comment}{    S\_OK           -\/   data was read from stdin and copied, and the resultant}}
\DoxyCodeLine{3663 \textcolor{comment}{                       dest string was null terminated}}
\DoxyCodeLine{3664 \textcolor{comment}{}}
\DoxyCodeLine{3665 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{3666 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{3667 \textcolor{comment}{}}
\DoxyCodeLine{3668 \textcolor{comment}{      STRSAFE\_E\_END\_OF\_FILE /}}
\DoxyCodeLine{3669 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_HANDLE\_EOF}}
\DoxyCodeLine{3670 \textcolor{comment}{                   -\/   this return value indicates an error or end-\/of-\/file}}
\DoxyCodeLine{3671 \textcolor{comment}{                       condition, use feof or ferror to determine which one has}}
\DoxyCodeLine{3672 \textcolor{comment}{                       occured.}}
\DoxyCodeLine{3673 \textcolor{comment}{}}
\DoxyCodeLine{3674 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{3675 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{3676 \textcolor{comment}{                   -\/   this return value is an indication that there was}}
\DoxyCodeLine{3677 \textcolor{comment}{                       insufficient space in the destination buffer to copy any}}
\DoxyCodeLine{3678 \textcolor{comment}{                       data}}
\DoxyCodeLine{3679 \textcolor{comment}{}}
\DoxyCodeLine{3680 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{3681 \textcolor{comment}{    return value of this function.}}
\DoxyCodeLine{3682 \textcolor{comment}{}}
\DoxyCodeLine{3683 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{3684 }
\DoxyCodeLine{3685 \textcolor{preprocessor}{\#ifndef STRSAFE\_LIB\_IMPL}}
\DoxyCodeLine{3686 STRSAFE\_INLINE\_API StringCbGetsA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest);}
\DoxyCodeLine{3687 STRSAFE\_INLINE\_API StringCbGetsW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest);}
\DoxyCodeLine{3688 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{3689 \textcolor{preprocessor}{\#define StringCbGets  StringCbGetsW}}
\DoxyCodeLine{3690 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3691 \textcolor{preprocessor}{\#define StringCbGets  StringCbGetsA}}
\DoxyCodeLine{3692 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{3693 }
\DoxyCodeLine{3694 STRSAFE\_INLINE\_API StringCbGetsA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest)}
\DoxyCodeLine{3695 \{}
\DoxyCodeLine{3696     HRESULT hr;}
\DoxyCodeLine{3697     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{3698 }
\DoxyCodeLine{3699     \textcolor{comment}{// convert to count of characters}}
\DoxyCodeLine{3700     cchDest = cbDest / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{3701 }
\DoxyCodeLine{3702     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{3703     \{}
\DoxyCodeLine{3704         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{3705     \}}
\DoxyCodeLine{3706     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3707     \{}
\DoxyCodeLine{3708         hr = StringGetsExWorkerA(pszDest, cchDest, cbDest, NULL, NULL, 0);}
\DoxyCodeLine{3709     \}}
\DoxyCodeLine{3710 }
\DoxyCodeLine{3711     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{3712 \}}
\DoxyCodeLine{3713 }
\DoxyCodeLine{3714 STRSAFE\_INLINE\_API StringCbGetsW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest)}
\DoxyCodeLine{3715 \{}
\DoxyCodeLine{3716     HRESULT hr;}
\DoxyCodeLine{3717     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{3718 }
\DoxyCodeLine{3719     \textcolor{comment}{// convert to count of characters}}
\DoxyCodeLine{3720     cchDest = cbDest / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{3721 }
\DoxyCodeLine{3722     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{3723     \{}
\DoxyCodeLine{3724         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{3725     \}}
\DoxyCodeLine{3726     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3727     \{}
\DoxyCodeLine{3728         hr = StringGetsExWorkerW(pszDest, cchDest, cbDest, NULL, NULL, 0);}
\DoxyCodeLine{3729     \}}
\DoxyCodeLine{3730 }
\DoxyCodeLine{3731     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{3732 \}}
\DoxyCodeLine{3733 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{3734 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_LIB\_IMPL}}
\DoxyCodeLine{3735 }
\DoxyCodeLine{3736 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{3737 \textcolor{comment}{/*++}}
\DoxyCodeLine{3738 \textcolor{comment}{}}
\DoxyCodeLine{3739 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{3740 \textcolor{comment}{StringCchGetsEx(}}
\DoxyCodeLine{3741 \textcolor{comment}{    OUT LPTSTR  pszDest         OPTIONAL,}}
\DoxyCodeLine{3742 \textcolor{comment}{    IN  size\_t  cchDest,}}
\DoxyCodeLine{3743 \textcolor{comment}{    OUT LPTSTR* ppszDestEnd     OPTIONAL,}}
\DoxyCodeLine{3744 \textcolor{comment}{    OUT size\_t* pcchRemaining   OPTIONAL,}}
\DoxyCodeLine{3745 \textcolor{comment}{    IN  DWORD   dwFlags}}
\DoxyCodeLine{3746 \textcolor{comment}{    );}}
\DoxyCodeLine{3747 \textcolor{comment}{}}
\DoxyCodeLine{3748 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{3749 \textcolor{comment}{}}
\DoxyCodeLine{3750 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'gets' with}}
\DoxyCodeLine{3751 \textcolor{comment}{    some additional parameters. In addition to functionality provided by}}
\DoxyCodeLine{3752 \textcolor{comment}{    StringCchGets, this routine also returns a pointer to the end of the}}
\DoxyCodeLine{3753 \textcolor{comment}{    destination string and the number of characters left in the destination string}}
\DoxyCodeLine{3754 \textcolor{comment}{    including the null terminator. The flags parameter allows additional controls.}}
\DoxyCodeLine{3755 \textcolor{comment}{}}
\DoxyCodeLine{3756 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{3757 \textcolor{comment}{}}
\DoxyCodeLine{3758 \textcolor{comment}{    pszDest         -\/   destination string}}
\DoxyCodeLine{3759 \textcolor{comment}{}}
\DoxyCodeLine{3760 \textcolor{comment}{    cchDest         -\/   size of destination buffer in characters.}}
\DoxyCodeLine{3761 \textcolor{comment}{}}
\DoxyCodeLine{3762 \textcolor{comment}{    ppszDestEnd     -\/   if ppszDestEnd is non-\/null, the function will return a}}
\DoxyCodeLine{3763 \textcolor{comment}{                        pointer to the end of the destination string.  If the}}
\DoxyCodeLine{3764 \textcolor{comment}{                        function copied any data, the result will point to the}}
\DoxyCodeLine{3765 \textcolor{comment}{                        null termination character}}
\DoxyCodeLine{3766 \textcolor{comment}{}}
\DoxyCodeLine{3767 \textcolor{comment}{    pcchRemaining   -\/   if pcchRemaining is non-\/null, the function will return the}}
\DoxyCodeLine{3768 \textcolor{comment}{                        number of characters left in the destination string,}}
\DoxyCodeLine{3769 \textcolor{comment}{                        including the null terminator}}
\DoxyCodeLine{3770 \textcolor{comment}{}}
\DoxyCodeLine{3771 \textcolor{comment}{    dwFlags         -\/   controls some details of the string copy:}}
\DoxyCodeLine{3772 \textcolor{comment}{}}
\DoxyCodeLine{3773 \textcolor{comment}{        STRSAFE\_FILL\_BEHIND\_NULL}}
\DoxyCodeLine{3774 \textcolor{comment}{                    if the function succeeds, the low byte of dwFlags will be}}
\DoxyCodeLine{3775 \textcolor{comment}{                    used to fill the uninitialize part of destination buffer}}
\DoxyCodeLine{3776 \textcolor{comment}{                    behind the null terminator}}
\DoxyCodeLine{3777 \textcolor{comment}{}}
\DoxyCodeLine{3778 \textcolor{comment}{        STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{3779 \textcolor{comment}{                    treat NULL string pointers like empty strings (TEXT("{}"{})).}}
\DoxyCodeLine{3780 \textcolor{comment}{}}
\DoxyCodeLine{3781 \textcolor{comment}{        STRSAFE\_FILL\_ON\_FAILURE}}
\DoxyCodeLine{3782 \textcolor{comment}{                    if the function fails, the low byte of dwFlags will be}}
\DoxyCodeLine{3783 \textcolor{comment}{                    used to fill all of the destination buffer, and it will}}
\DoxyCodeLine{3784 \textcolor{comment}{                    be null terminated.}}
\DoxyCodeLine{3785 \textcolor{comment}{}}
\DoxyCodeLine{3786 \textcolor{comment}{        STRSAFE\_NO\_TRUNCATION /}}
\DoxyCodeLine{3787 \textcolor{comment}{        STRSAFE\_NULL\_ON\_FAILURE}}
\DoxyCodeLine{3788 \textcolor{comment}{                    if the function fails, the destination buffer will be set}}
\DoxyCodeLine{3789 \textcolor{comment}{                    to the empty string.}}
\DoxyCodeLine{3790 \textcolor{comment}{}}
\DoxyCodeLine{3791 \textcolor{comment}{Notes:}}
\DoxyCodeLine{3792 \textcolor{comment}{    pszDest should not be NULL unless the STRSAFE\_IGNORE\_NULLS flag is specified.}}
\DoxyCodeLine{3793 \textcolor{comment}{    If STRSAFE\_IGNORE\_NULLS is passed and pszDest is NULL, an error may still be}}
\DoxyCodeLine{3794 \textcolor{comment}{    returned even though NULLS are ignored}}
\DoxyCodeLine{3795 \textcolor{comment}{}}
\DoxyCodeLine{3796 \textcolor{comment}{    cchDest must be > 1 for this function to succeed.}}
\DoxyCodeLine{3797 \textcolor{comment}{}}
\DoxyCodeLine{3798 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{3799 \textcolor{comment}{}}
\DoxyCodeLine{3800 \textcolor{comment}{    S\_OK           -\/   data was read from stdin and copied, and the resultant}}
\DoxyCodeLine{3801 \textcolor{comment}{                       dest string was null terminated}}
\DoxyCodeLine{3802 \textcolor{comment}{}}
\DoxyCodeLine{3803 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{3804 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{3805 \textcolor{comment}{}}
\DoxyCodeLine{3806 \textcolor{comment}{      STRSAFE\_E\_END\_OF\_FILE /}}
\DoxyCodeLine{3807 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_HANDLE\_EOF}}
\DoxyCodeLine{3808 \textcolor{comment}{                   -\/   this return value indicates an error or end-\/of-\/file}}
\DoxyCodeLine{3809 \textcolor{comment}{                       condition, use feof or ferror to determine which one has}}
\DoxyCodeLine{3810 \textcolor{comment}{                       occured.}}
\DoxyCodeLine{3811 \textcolor{comment}{}}
\DoxyCodeLine{3812 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{3813 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{3814 \textcolor{comment}{                   -\/   this return value is an indication that there was}}
\DoxyCodeLine{3815 \textcolor{comment}{                       insufficient space in the destination buffer to copy any}}
\DoxyCodeLine{3816 \textcolor{comment}{                       data}}
\DoxyCodeLine{3817 \textcolor{comment}{}}
\DoxyCodeLine{3818 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{3819 \textcolor{comment}{    return value of this function.}}
\DoxyCodeLine{3820 \textcolor{comment}{}}
\DoxyCodeLine{3821 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{3822 }
\DoxyCodeLine{3823 \textcolor{preprocessor}{\#ifndef STRSAFE\_LIB\_IMPL}}
\DoxyCodeLine{3824 STRSAFE\_INLINE\_API StringCchGetsExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{3825 STRSAFE\_INLINE\_API StringCchGetsExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{3826 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{3827 \textcolor{preprocessor}{\#define StringCchGetsEx  StringCchGetsExW}}
\DoxyCodeLine{3828 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3829 \textcolor{preprocessor}{\#define StringCchGetsEx  StringCchGetsExA}}
\DoxyCodeLine{3830 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{3831 }
\DoxyCodeLine{3832 STRSAFE\_INLINE\_API StringCchGetsExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{3833 \{}
\DoxyCodeLine{3834     HRESULT hr;}
\DoxyCodeLine{3835 }
\DoxyCodeLine{3836     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{3837     \{}
\DoxyCodeLine{3838         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{3839     \}}
\DoxyCodeLine{3840     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3841     \{}
\DoxyCodeLine{3842         \textcolor{keywordtype}{size\_t} cbDest;}
\DoxyCodeLine{3843 }
\DoxyCodeLine{3844         \textcolor{comment}{// safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE\_MAX\_CCH and sizeof(char) is 1}}
\DoxyCodeLine{3845         cbDest = cchDest * \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{3846 }
\DoxyCodeLine{3847         hr = StringGetsExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags);}
\DoxyCodeLine{3848     \}}
\DoxyCodeLine{3849 }
\DoxyCodeLine{3850     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{3851 \}}
\DoxyCodeLine{3852 }
\DoxyCodeLine{3853 STRSAFE\_INLINE\_API StringCchGetsExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{3854 \{}
\DoxyCodeLine{3855     HRESULT hr;}
\DoxyCodeLine{3856 }
\DoxyCodeLine{3857     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{3858     \{}
\DoxyCodeLine{3859         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{3860     \}}
\DoxyCodeLine{3861     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3862     \{}
\DoxyCodeLine{3863         \textcolor{keywordtype}{size\_t} cbDest;}
\DoxyCodeLine{3864 }
\DoxyCodeLine{3865         \textcolor{comment}{// safe to multiply cchDest * sizeof(wchar\_t) since cchDest < STRSAFE\_MAX\_CCH and sizeof(wchar\_t) is 2}}
\DoxyCodeLine{3866         cbDest = cchDest * \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{3867 }
\DoxyCodeLine{3868         hr = StringGetsExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags);}
\DoxyCodeLine{3869     \}}
\DoxyCodeLine{3870 }
\DoxyCodeLine{3871     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{3872 \}}
\DoxyCodeLine{3873 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{3874 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_LIB\_IMPL}}
\DoxyCodeLine{3875 }
\DoxyCodeLine{3876 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{3877 \textcolor{comment}{/*++}}
\DoxyCodeLine{3878 \textcolor{comment}{}}
\DoxyCodeLine{3879 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{3880 \textcolor{comment}{StringCbGetsEx(}}
\DoxyCodeLine{3881 \textcolor{comment}{    OUT LPTSTR  pszDest         OPTIONAL,}}
\DoxyCodeLine{3882 \textcolor{comment}{    IN  size\_t  cbDest,}}
\DoxyCodeLine{3883 \textcolor{comment}{    OUT LPTSTR* ppszDestEnd     OPTIONAL,}}
\DoxyCodeLine{3884 \textcolor{comment}{    OUT size\_t* pcbRemaining    OPTIONAL,}}
\DoxyCodeLine{3885 \textcolor{comment}{    IN  DWORD   dwFlags}}
\DoxyCodeLine{3886 \textcolor{comment}{    );}}
\DoxyCodeLine{3887 \textcolor{comment}{}}
\DoxyCodeLine{3888 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{3889 \textcolor{comment}{}}
\DoxyCodeLine{3890 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'gets' with}}
\DoxyCodeLine{3891 \textcolor{comment}{    some additional parameters. In addition to functionality provided by}}
\DoxyCodeLine{3892 \textcolor{comment}{    StringCbGets, this routine also returns a pointer to the end of the}}
\DoxyCodeLine{3893 \textcolor{comment}{    destination string and the number of characters left in the destination string}}
\DoxyCodeLine{3894 \textcolor{comment}{    including the null terminator. The flags parameter allows additional controls.}}
\DoxyCodeLine{3895 \textcolor{comment}{}}
\DoxyCodeLine{3896 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{3897 \textcolor{comment}{}}
\DoxyCodeLine{3898 \textcolor{comment}{    pszDest         -\/   destination string}}
\DoxyCodeLine{3899 \textcolor{comment}{}}
\DoxyCodeLine{3900 \textcolor{comment}{    cbDest          -\/   size of destination buffer in bytes.}}
\DoxyCodeLine{3901 \textcolor{comment}{}}
\DoxyCodeLine{3902 \textcolor{comment}{    ppszDestEnd     -\/   if ppszDestEnd is non-\/null, the function will return a}}
\DoxyCodeLine{3903 \textcolor{comment}{                        pointer to the end of the destination string.  If the}}
\DoxyCodeLine{3904 \textcolor{comment}{                        function copied any data, the result will point to the}}
\DoxyCodeLine{3905 \textcolor{comment}{                        null termination character}}
\DoxyCodeLine{3906 \textcolor{comment}{}}
\DoxyCodeLine{3907 \textcolor{comment}{    pcbRemaining    -\/   if pbRemaining is non-\/null, the function will return the}}
\DoxyCodeLine{3908 \textcolor{comment}{                        number of bytes left in the destination string,}}
\DoxyCodeLine{3909 \textcolor{comment}{                        including the null terminator}}
\DoxyCodeLine{3910 \textcolor{comment}{}}
\DoxyCodeLine{3911 \textcolor{comment}{    dwFlags         -\/   controls some details of the string copy:}}
\DoxyCodeLine{3912 \textcolor{comment}{}}
\DoxyCodeLine{3913 \textcolor{comment}{        STRSAFE\_FILL\_BEHIND\_NULL}}
\DoxyCodeLine{3914 \textcolor{comment}{                    if the function succeeds, the low byte of dwFlags will be}}
\DoxyCodeLine{3915 \textcolor{comment}{                    used to fill the uninitialize part of destination buffer}}
\DoxyCodeLine{3916 \textcolor{comment}{                    behind the null terminator}}
\DoxyCodeLine{3917 \textcolor{comment}{}}
\DoxyCodeLine{3918 \textcolor{comment}{        STRSAFE\_IGNORE\_NULLS}}
\DoxyCodeLine{3919 \textcolor{comment}{                    treat NULL string pointers like empty strings (TEXT("{}"{})).}}
\DoxyCodeLine{3920 \textcolor{comment}{}}
\DoxyCodeLine{3921 \textcolor{comment}{        STRSAFE\_FILL\_ON\_FAILURE}}
\DoxyCodeLine{3922 \textcolor{comment}{                    if the function fails, the low byte of dwFlags will be}}
\DoxyCodeLine{3923 \textcolor{comment}{                    used to fill all of the destination buffer, and it will}}
\DoxyCodeLine{3924 \textcolor{comment}{                    be null terminated.}}
\DoxyCodeLine{3925 \textcolor{comment}{}}
\DoxyCodeLine{3926 \textcolor{comment}{        STRSAFE\_NO\_TRUNCATION /}}
\DoxyCodeLine{3927 \textcolor{comment}{        STRSAFE\_NULL\_ON\_FAILURE}}
\DoxyCodeLine{3928 \textcolor{comment}{                    if the function fails, the destination buffer will be set}}
\DoxyCodeLine{3929 \textcolor{comment}{                    to the empty string.}}
\DoxyCodeLine{3930 \textcolor{comment}{}}
\DoxyCodeLine{3931 \textcolor{comment}{Notes:}}
\DoxyCodeLine{3932 \textcolor{comment}{    pszDest should not be NULL unless the STRSAFE\_IGNORE\_NULLS flag is specified.}}
\DoxyCodeLine{3933 \textcolor{comment}{    If STRSAFE\_IGNORE\_NULLS is passed and pszDest is NULL, an error may still be}}
\DoxyCodeLine{3934 \textcolor{comment}{    returned even though NULLS are ignored}}
\DoxyCodeLine{3935 \textcolor{comment}{}}
\DoxyCodeLine{3936 \textcolor{comment}{    cbDest must be > sizeof(TCHAR) for this function to succeed}}
\DoxyCodeLine{3937 \textcolor{comment}{}}
\DoxyCodeLine{3938 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{3939 \textcolor{comment}{}}
\DoxyCodeLine{3940 \textcolor{comment}{    S\_OK           -\/   data was read from stdin and copied, and the resultant}}
\DoxyCodeLine{3941 \textcolor{comment}{                       dest string was null terminated}}
\DoxyCodeLine{3942 \textcolor{comment}{}}
\DoxyCodeLine{3943 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{3944 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{3945 \textcolor{comment}{}}
\DoxyCodeLine{3946 \textcolor{comment}{      STRSAFE\_E\_END\_OF\_FILE /}}
\DoxyCodeLine{3947 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_HANDLE\_EOF}}
\DoxyCodeLine{3948 \textcolor{comment}{                   -\/   this return value indicates an error or end-\/of-\/file}}
\DoxyCodeLine{3949 \textcolor{comment}{                       condition, use feof or ferror to determine which one has}}
\DoxyCodeLine{3950 \textcolor{comment}{                       occured.}}
\DoxyCodeLine{3951 \textcolor{comment}{}}
\DoxyCodeLine{3952 \textcolor{comment}{      STRSAFE\_E\_INSUFFICIENT\_BUFFER /}}
\DoxyCodeLine{3953 \textcolor{comment}{      HRESULT\_CODE(hr) == ERROR\_INSUFFICIENT\_BUFFER}}
\DoxyCodeLine{3954 \textcolor{comment}{                   -\/   this return value is an indication that there was}}
\DoxyCodeLine{3955 \textcolor{comment}{                       insufficient space in the destination buffer to copy any}}
\DoxyCodeLine{3956 \textcolor{comment}{                       data}}
\DoxyCodeLine{3957 \textcolor{comment}{}}
\DoxyCodeLine{3958 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{3959 \textcolor{comment}{    return value of this function.}}
\DoxyCodeLine{3960 \textcolor{comment}{}}
\DoxyCodeLine{3961 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{3962 }
\DoxyCodeLine{3963 \textcolor{preprocessor}{\#ifndef STRSAFE\_LIB\_IMPL}}
\DoxyCodeLine{3964 STRSAFE\_INLINE\_API StringCbGetsExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{3965 STRSAFE\_INLINE\_API StringCbGetsExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags);}
\DoxyCodeLine{3966 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{3967 \textcolor{preprocessor}{\#define StringCbGetsEx  StringCbGetsExW}}
\DoxyCodeLine{3968 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3969 \textcolor{preprocessor}{\#define StringCbGetsEx  StringCbGetsExA}}
\DoxyCodeLine{3970 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{3971 }
\DoxyCodeLine{3972 STRSAFE\_INLINE\_API StringCbGetsExA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{3973 \{}
\DoxyCodeLine{3974     HRESULT hr;}
\DoxyCodeLine{3975     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{3976     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{3977 }
\DoxyCodeLine{3978     cchDest = cbDest / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{3979 }
\DoxyCodeLine{3980     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{3981     \{}
\DoxyCodeLine{3982         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{3983     \}}
\DoxyCodeLine{3984     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3985     \{}
\DoxyCodeLine{3986         hr = StringGetsExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, \&cchRemaining, dwFlags);}
\DoxyCodeLine{3987     \}}
\DoxyCodeLine{3988 }
\DoxyCodeLine{3989     \textcolor{keywordflow}{if} (SUCCEEDED(hr) ||}
\DoxyCodeLine{3990         (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER) ||}
\DoxyCodeLine{3991         (hr == STRSAFE\_E\_END\_OF\_FILE))}
\DoxyCodeLine{3992     \{}
\DoxyCodeLine{3993         \textcolor{keywordflow}{if} (pcbRemaining)}
\DoxyCodeLine{3994         \{}
\DoxyCodeLine{3995             \textcolor{comment}{// safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE\_MAX\_CCH and sizeof(char) is 1}}
\DoxyCodeLine{3996             *pcbRemaining = (cchRemaining * \textcolor{keyword}{sizeof}(char)) + (cbDest \% \textcolor{keyword}{sizeof}(char));}
\DoxyCodeLine{3997         \}}
\DoxyCodeLine{3998     \}}
\DoxyCodeLine{3999 }
\DoxyCodeLine{4000     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{4001 \}}
\DoxyCodeLine{4002 }
\DoxyCodeLine{4003 STRSAFE\_INLINE\_API StringCbGetsExW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcbRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{4004 \{}
\DoxyCodeLine{4005     HRESULT hr;}
\DoxyCodeLine{4006     \textcolor{keywordtype}{size\_t} cchDest;}
\DoxyCodeLine{4007     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{4008 }
\DoxyCodeLine{4009     cchDest = cbDest / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{4010 }
\DoxyCodeLine{4011     \textcolor{keywordflow}{if} (cchDest > STRSAFE\_MAX\_CCH)}
\DoxyCodeLine{4012     \{}
\DoxyCodeLine{4013         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4014     \}}
\DoxyCodeLine{4015     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4016     \{}
\DoxyCodeLine{4017         hr = StringGetsExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, \&cchRemaining, dwFlags);}
\DoxyCodeLine{4018     \}}
\DoxyCodeLine{4019 }
\DoxyCodeLine{4020     \textcolor{keywordflow}{if} (SUCCEEDED(hr) ||}
\DoxyCodeLine{4021         (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER) ||}
\DoxyCodeLine{4022         (hr == STRSAFE\_E\_END\_OF\_FILE))}
\DoxyCodeLine{4023     \{}
\DoxyCodeLine{4024         \textcolor{keywordflow}{if} (pcbRemaining)}
\DoxyCodeLine{4025         \{}
\DoxyCodeLine{4026             \textcolor{comment}{// safe to multiply cchRemaining * sizeof(wchar\_t) since cchRemaining < STRSAFE\_MAX\_CCH and sizeof(wchar\_t) is 2}}
\DoxyCodeLine{4027             *pcbRemaining = (cchRemaining * \textcolor{keyword}{sizeof}(wchar\_t)) + (cbDest \% \textcolor{keyword}{sizeof}(wchar\_t));}
\DoxyCodeLine{4028         \}}
\DoxyCodeLine{4029     \}}
\DoxyCodeLine{4030 }
\DoxyCodeLine{4031     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{4032 \}}
\DoxyCodeLine{4033 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{4034 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_LIB\_IMPL}}
\DoxyCodeLine{4035 }
\DoxyCodeLine{4036 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{4037 \textcolor{comment}{/*++}}
\DoxyCodeLine{4038 \textcolor{comment}{}}
\DoxyCodeLine{4039 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{4040 \textcolor{comment}{StringCchLength(}}
\DoxyCodeLine{4041 \textcolor{comment}{    IN  LPCTSTR psz,}}
\DoxyCodeLine{4042 \textcolor{comment}{    IN  size\_t  cchMax,}}
\DoxyCodeLine{4043 \textcolor{comment}{    OUT size\_t* pcch    OPTIONAL}}
\DoxyCodeLine{4044 \textcolor{comment}{    );}}
\DoxyCodeLine{4045 \textcolor{comment}{}}
\DoxyCodeLine{4046 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{4047 \textcolor{comment}{}}
\DoxyCodeLine{4048 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strlen'.}}
\DoxyCodeLine{4049 \textcolor{comment}{    It is used to make sure a string is not larger than a given length, and}}
\DoxyCodeLine{4050 \textcolor{comment}{    it optionally returns the current length in characters not including}}
\DoxyCodeLine{4051 \textcolor{comment}{    the null terminator.}}
\DoxyCodeLine{4052 \textcolor{comment}{}}
\DoxyCodeLine{4053 \textcolor{comment}{    This function returns a hresult, and not a pointer.  It returns}}
\DoxyCodeLine{4054 \textcolor{comment}{    S\_OK if the string is non-\/null and the length including the null}}
\DoxyCodeLine{4055 \textcolor{comment}{    terminator is less than or equal to cchMax characters.}}
\DoxyCodeLine{4056 \textcolor{comment}{}}
\DoxyCodeLine{4057 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{4058 \textcolor{comment}{}}
\DoxyCodeLine{4059 \textcolor{comment}{    psz         -\/   string to check the length of}}
\DoxyCodeLine{4060 \textcolor{comment}{}}
\DoxyCodeLine{4061 \textcolor{comment}{    cchMax      -\/   maximum number of characters including the null terminator}}
\DoxyCodeLine{4062 \textcolor{comment}{                    that psz is allowed to contain}}
\DoxyCodeLine{4063 \textcolor{comment}{}}
\DoxyCodeLine{4064 \textcolor{comment}{    pcch        -\/   if the function succeeds and pcch is non-\/null, the current length}}
\DoxyCodeLine{4065 \textcolor{comment}{                    in characters of psz excluding the null terminator will be returned.}}
\DoxyCodeLine{4066 \textcolor{comment}{                    This out parameter is equivalent to the return value of strlen(psz)}}
\DoxyCodeLine{4067 \textcolor{comment}{}}
\DoxyCodeLine{4068 \textcolor{comment}{Notes:}}
\DoxyCodeLine{4069 \textcolor{comment}{    psz can be null but the function will fail}}
\DoxyCodeLine{4070 \textcolor{comment}{}}
\DoxyCodeLine{4071 \textcolor{comment}{    cchMax should be greater than zero or the function will fail}}
\DoxyCodeLine{4072 \textcolor{comment}{}}
\DoxyCodeLine{4073 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{4074 \textcolor{comment}{}}
\DoxyCodeLine{4075 \textcolor{comment}{    S\_OK           -\/   psz is non-\/null and the length including the null}}
\DoxyCodeLine{4076 \textcolor{comment}{                       terminator is less than or equal to cchMax characters}}
\DoxyCodeLine{4077 \textcolor{comment}{}}
\DoxyCodeLine{4078 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{4079 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{4080 \textcolor{comment}{}}
\DoxyCodeLine{4081 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{4082 \textcolor{comment}{    return value of this function.}}
\DoxyCodeLine{4083 \textcolor{comment}{}}
\DoxyCodeLine{4084 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{4085 }
\DoxyCodeLine{4086 STRSAFEAPI StringCchLengthA(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* psz, \textcolor{keywordtype}{size\_t} cchMax, \textcolor{keywordtype}{size\_t}* pcch);}
\DoxyCodeLine{4087 STRSAFEAPI StringCchLengthW(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* psz, \textcolor{keywordtype}{size\_t} cchMax, \textcolor{keywordtype}{size\_t}* pcch);}
\DoxyCodeLine{4088 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{4089 \textcolor{preprocessor}{\#define StringCchLength  StringCchLengthW}}
\DoxyCodeLine{4090 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{4091 \textcolor{preprocessor}{\#define StringCchLength  StringCchLengthA}}
\DoxyCodeLine{4092 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{4093 }
\DoxyCodeLine{4094 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{4095 STRSAFEAPI StringCchLengthA(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* psz, \textcolor{keywordtype}{size\_t} cchMax, \textcolor{keywordtype}{size\_t}* pcch)}
\DoxyCodeLine{4096 \{}
\DoxyCodeLine{4097     HRESULT hr;}
\DoxyCodeLine{4098 }
\DoxyCodeLine{4099     \textcolor{keywordflow}{if} ((psz == NULL) || (cchMax > STRSAFE\_MAX\_CCH))}
\DoxyCodeLine{4100     \{}
\DoxyCodeLine{4101         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4102     \}}
\DoxyCodeLine{4103     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4104     \{}
\DoxyCodeLine{4105         hr = StringLengthWorkerA(psz, cchMax, pcch);}
\DoxyCodeLine{4106     \}}
\DoxyCodeLine{4107 }
\DoxyCodeLine{4108     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{4109 \}}
\DoxyCodeLine{4110 }
\DoxyCodeLine{4111 STRSAFEAPI StringCchLengthW(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* psz, \textcolor{keywordtype}{size\_t} cchMax, \textcolor{keywordtype}{size\_t}* pcch)}
\DoxyCodeLine{4112 \{}
\DoxyCodeLine{4113     HRESULT hr;}
\DoxyCodeLine{4114 }
\DoxyCodeLine{4115     \textcolor{keywordflow}{if} ((psz == NULL) || (cchMax > STRSAFE\_MAX\_CCH))}
\DoxyCodeLine{4116     \{}
\DoxyCodeLine{4117         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4118     \}}
\DoxyCodeLine{4119     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4120     \{}
\DoxyCodeLine{4121         hr = StringLengthWorkerW(psz, cchMax, pcch);}
\DoxyCodeLine{4122     \}}
\DoxyCodeLine{4123 }
\DoxyCodeLine{4124     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{4125 \}}
\DoxyCodeLine{4126 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{4127 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CCH\_FUNCTIONS}}
\DoxyCodeLine{4128 }
\DoxyCodeLine{4129 }
\DoxyCodeLine{4130 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{4131 \textcolor{comment}{/*++}}
\DoxyCodeLine{4132 \textcolor{comment}{}}
\DoxyCodeLine{4133 \textcolor{comment}{STDAPI}}
\DoxyCodeLine{4134 \textcolor{comment}{StringCbLength(}}
\DoxyCodeLine{4135 \textcolor{comment}{    IN  LPCTSTR psz,}}
\DoxyCodeLine{4136 \textcolor{comment}{    IN  size\_t  cbMax,}}
\DoxyCodeLine{4137 \textcolor{comment}{    OUT size\_t* pcb     OPTIONAL}}
\DoxyCodeLine{4138 \textcolor{comment}{    );}}
\DoxyCodeLine{4139 \textcolor{comment}{}}
\DoxyCodeLine{4140 \textcolor{comment}{Routine Description:}}
\DoxyCodeLine{4141 \textcolor{comment}{}}
\DoxyCodeLine{4142 \textcolor{comment}{    This routine is a safer version of the C built-\/in function 'strlen'.}}
\DoxyCodeLine{4143 \textcolor{comment}{    It is used to make sure a string is not larger than a given length, and}}
\DoxyCodeLine{4144 \textcolor{comment}{    it optionally returns the current length in bytes not including}}
\DoxyCodeLine{4145 \textcolor{comment}{    the null terminator.}}
\DoxyCodeLine{4146 \textcolor{comment}{}}
\DoxyCodeLine{4147 \textcolor{comment}{    This function returns a hresult, and not a pointer.  It returns}}
\DoxyCodeLine{4148 \textcolor{comment}{    S\_OK if the string is non-\/null and the length including the null}}
\DoxyCodeLine{4149 \textcolor{comment}{    terminator is less than or equal to cbMax bytes.}}
\DoxyCodeLine{4150 \textcolor{comment}{}}
\DoxyCodeLine{4151 \textcolor{comment}{Arguments:}}
\DoxyCodeLine{4152 \textcolor{comment}{}}
\DoxyCodeLine{4153 \textcolor{comment}{    psz         -\/   string to check the length of}}
\DoxyCodeLine{4154 \textcolor{comment}{}}
\DoxyCodeLine{4155 \textcolor{comment}{    cbMax       -\/   maximum number of bytes including the null terminator}}
\DoxyCodeLine{4156 \textcolor{comment}{                    that psz is allowed to contain}}
\DoxyCodeLine{4157 \textcolor{comment}{}}
\DoxyCodeLine{4158 \textcolor{comment}{    pcb         -\/   if the function succeeds and pcb is non-\/null, the current length}}
\DoxyCodeLine{4159 \textcolor{comment}{                    in bytes of psz excluding the null terminator will be returned.}}
\DoxyCodeLine{4160 \textcolor{comment}{                    This out parameter is equivalent to the return value of strlen(psz) * sizeof(TCHAR)}}
\DoxyCodeLine{4161 \textcolor{comment}{}}
\DoxyCodeLine{4162 \textcolor{comment}{Notes:}}
\DoxyCodeLine{4163 \textcolor{comment}{    psz can be null but the function will fail}}
\DoxyCodeLine{4164 \textcolor{comment}{}}
\DoxyCodeLine{4165 \textcolor{comment}{    cbMax should be greater than or equal to sizeof(TCHAR) or the function will fail}}
\DoxyCodeLine{4166 \textcolor{comment}{}}
\DoxyCodeLine{4167 \textcolor{comment}{Return Value:}}
\DoxyCodeLine{4168 \textcolor{comment}{}}
\DoxyCodeLine{4169 \textcolor{comment}{    S\_OK           -\/   psz is non-\/null and the length including the null}}
\DoxyCodeLine{4170 \textcolor{comment}{                       terminator is less than or equal to cbMax bytes}}
\DoxyCodeLine{4171 \textcolor{comment}{}}
\DoxyCodeLine{4172 \textcolor{comment}{    failure        -\/   you can use the macro HRESULT\_CODE() to get a win32}}
\DoxyCodeLine{4173 \textcolor{comment}{                       error code for all hresult failure cases}}
\DoxyCodeLine{4174 \textcolor{comment}{}}
\DoxyCodeLine{4175 \textcolor{comment}{    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the}}
\DoxyCodeLine{4176 \textcolor{comment}{    return value of this function.}}
\DoxyCodeLine{4177 \textcolor{comment}{}}
\DoxyCodeLine{4178 \textcolor{comment}{-\/-\/*/}}
\DoxyCodeLine{4179 }
\DoxyCodeLine{4180 STRSAFEAPI StringCbLengthA(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* psz, \textcolor{keywordtype}{size\_t} cchMax, \textcolor{keywordtype}{size\_t}* pcch);}
\DoxyCodeLine{4181 STRSAFEAPI StringCbLengthW(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* psz, \textcolor{keywordtype}{size\_t} cchMax, \textcolor{keywordtype}{size\_t}* pcch);}
\DoxyCodeLine{4182 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{4183 \textcolor{preprocessor}{\#define StringCbLength  StringCbLengthW}}
\DoxyCodeLine{4184 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{4185 \textcolor{preprocessor}{\#define StringCbLength  StringCbLengthA}}
\DoxyCodeLine{4186 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !UNICODE}}
\DoxyCodeLine{4187 }
\DoxyCodeLine{4188 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{4189 STRSAFEAPI StringCbLengthA(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* psz, \textcolor{keywordtype}{size\_t} cbMax, \textcolor{keywordtype}{size\_t}* pcb)}
\DoxyCodeLine{4190 \{}
\DoxyCodeLine{4191     HRESULT hr;}
\DoxyCodeLine{4192     \textcolor{keywordtype}{size\_t} cchMax;}
\DoxyCodeLine{4193     \textcolor{keywordtype}{size\_t} cch = 0;}
\DoxyCodeLine{4194 }
\DoxyCodeLine{4195     cchMax = cbMax / \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{4196 }
\DoxyCodeLine{4197     \textcolor{keywordflow}{if} ((psz == NULL) || (cchMax > STRSAFE\_MAX\_CCH))}
\DoxyCodeLine{4198     \{}
\DoxyCodeLine{4199         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4200     \}}
\DoxyCodeLine{4201     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4202     \{}
\DoxyCodeLine{4203         hr = StringLengthWorkerA(psz, cchMax, \&cch);}
\DoxyCodeLine{4204     \}}
\DoxyCodeLine{4205 }
\DoxyCodeLine{4206     \textcolor{keywordflow}{if} (SUCCEEDED(hr) \&\& pcb)}
\DoxyCodeLine{4207     \{}
\DoxyCodeLine{4208         \textcolor{comment}{// safe to multiply cch * sizeof(char) since cch < STRSAFE\_MAX\_CCH and sizeof(char) is 1}}
\DoxyCodeLine{4209         *pcb = cch * \textcolor{keyword}{sizeof}(char);}
\DoxyCodeLine{4210     \}}
\DoxyCodeLine{4211 }
\DoxyCodeLine{4212     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{4213 \}}
\DoxyCodeLine{4214 }
\DoxyCodeLine{4215 STRSAFEAPI StringCbLengthW(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* psz, \textcolor{keywordtype}{size\_t} cbMax, \textcolor{keywordtype}{size\_t}* pcb)}
\DoxyCodeLine{4216 \{}
\DoxyCodeLine{4217     HRESULT hr;}
\DoxyCodeLine{4218     \textcolor{keywordtype}{size\_t} cchMax;}
\DoxyCodeLine{4219     \textcolor{keywordtype}{size\_t} cch = 0;}
\DoxyCodeLine{4220 }
\DoxyCodeLine{4221     cchMax = cbMax / \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{4222 }
\DoxyCodeLine{4223     \textcolor{keywordflow}{if} ((psz == NULL) || (cchMax > STRSAFE\_MAX\_CCH))}
\DoxyCodeLine{4224     \{}
\DoxyCodeLine{4225         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4226     \}}
\DoxyCodeLine{4227     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4228     \{}
\DoxyCodeLine{4229         hr = StringLengthWorkerW(psz, cchMax, \&cch);}
\DoxyCodeLine{4230     \}}
\DoxyCodeLine{4231 }
\DoxyCodeLine{4232     \textcolor{keywordflow}{if} (SUCCEEDED(hr) \&\& pcb)}
\DoxyCodeLine{4233     \{}
\DoxyCodeLine{4234         \textcolor{comment}{// safe to multiply cch * sizeof(wchar\_t) since cch < STRSAFE\_MAX\_CCH and sizeof(wchar\_t) is 2}}
\DoxyCodeLine{4235         *pcb = cch * \textcolor{keyword}{sizeof}(wchar\_t);}
\DoxyCodeLine{4236     \}}
\DoxyCodeLine{4237 }
\DoxyCodeLine{4238     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{4239 \}}
\DoxyCodeLine{4240 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{4241 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_CB\_FUNCTIONS}}
\DoxyCodeLine{4242 }
\DoxyCodeLine{4243 }
\DoxyCodeLine{4244 \textcolor{comment}{// these are the worker functions that actually do the work}}
\DoxyCodeLine{4245 \textcolor{preprocessor}{\#ifdef STRSAFE\_INLINE}}
\DoxyCodeLine{4246 STRSAFEAPI StringCopyWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc)}
\DoxyCodeLine{4247 \{}
\DoxyCodeLine{4248     HRESULT hr = S\_OK;}
\DoxyCodeLine{4249 }
\DoxyCodeLine{4250     \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{4251     \{}
\DoxyCodeLine{4252         \textcolor{comment}{// can not null terminate a zero-\/byte dest buffer}}
\DoxyCodeLine{4253         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4254     \}}
\DoxyCodeLine{4255     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4256     \{}
\DoxyCodeLine{4257         \textcolor{keywordflow}{while} (cchDest \&\& (*pszSrc != \textcolor{charliteral}{'\(\backslash\)0'}))}
\DoxyCodeLine{4258         \{}
\DoxyCodeLine{4259             *pszDest++ = *pszSrc++;}
\DoxyCodeLine{4260             cchDest-\/-\/;}
\DoxyCodeLine{4261         \}}
\DoxyCodeLine{4262 }
\DoxyCodeLine{4263         \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{4264         \{}
\DoxyCodeLine{4265             \textcolor{comment}{// we are going to truncate pszDest}}
\DoxyCodeLine{4266             pszDest-\/-\/;}
\DoxyCodeLine{4267             hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{4268         \}}
\DoxyCodeLine{4269 }
\DoxyCodeLine{4270         *pszDest= \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4271     \}}
\DoxyCodeLine{4272 }
\DoxyCodeLine{4273     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{4274 \}}
\DoxyCodeLine{4275 }
\DoxyCodeLine{4276 STRSAFEAPI StringCopyWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc)}
\DoxyCodeLine{4277 \{}
\DoxyCodeLine{4278     HRESULT hr = S\_OK;}
\DoxyCodeLine{4279 }
\DoxyCodeLine{4280     \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{4281     \{}
\DoxyCodeLine{4282         \textcolor{comment}{// can not null terminate a zero-\/byte dest buffer}}
\DoxyCodeLine{4283         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4284     \}}
\DoxyCodeLine{4285     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4286     \{}
\DoxyCodeLine{4287         \textcolor{keywordflow}{while} (cchDest \&\& (*pszSrc != L\textcolor{charliteral}{'\(\backslash\)0'}))}
\DoxyCodeLine{4288         \{}
\DoxyCodeLine{4289             *pszDest++ = *pszSrc++;}
\DoxyCodeLine{4290             cchDest-\/-\/;}
\DoxyCodeLine{4291         \}}
\DoxyCodeLine{4292 }
\DoxyCodeLine{4293         \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{4294         \{}
\DoxyCodeLine{4295             \textcolor{comment}{// we are going to truncate pszDest}}
\DoxyCodeLine{4296             pszDest-\/-\/;}
\DoxyCodeLine{4297             hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{4298         \}}
\DoxyCodeLine{4299 }
\DoxyCodeLine{4300         *pszDest= L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4301     \}}
\DoxyCodeLine{4302 }
\DoxyCodeLine{4303     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{4304 \}}
\DoxyCodeLine{4305 }
\DoxyCodeLine{4306 STRSAFEAPI StringCopyExWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{4307 \{}
\DoxyCodeLine{4308     HRESULT hr = S\_OK;}
\DoxyCodeLine{4309     \textcolor{keywordtype}{char}* pszDestEnd = pszDest;}
\DoxyCodeLine{4310     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{4311 }
\DoxyCodeLine{4312     \textcolor{comment}{// ASSERT(cbDest == (cchDest * sizeof(char))    ||}}
\DoxyCodeLine{4313     \textcolor{comment}{//        cbDest == (cchDest * sizeof(char)) + (cbDest \% sizeof(char)));}}
\DoxyCodeLine{4314 }
\DoxyCodeLine{4315     \textcolor{comment}{// only accept valid flags}}
\DoxyCodeLine{4316     \textcolor{keywordflow}{if} (dwFlags \& (\string~STRSAFE\_VALID\_FLAGS))}
\DoxyCodeLine{4317     \{}
\DoxyCodeLine{4318         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4319     \}}
\DoxyCodeLine{4320     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4321     \{}
\DoxyCodeLine{4322         \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_IGNORE\_NULLS)}
\DoxyCodeLine{4323         \{}
\DoxyCodeLine{4324             \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{4325             \{}
\DoxyCodeLine{4326                 \textcolor{keywordflow}{if} ((cchDest != 0) || (cbDest != 0))}
\DoxyCodeLine{4327                 \{}
\DoxyCodeLine{4328                     \textcolor{comment}{// NULL pszDest and non-\/zero cchDest/cbDest is invalid}}
\DoxyCodeLine{4329                     hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4330                 \}}
\DoxyCodeLine{4331             \}}
\DoxyCodeLine{4332 }
\DoxyCodeLine{4333             \textcolor{keywordflow}{if} (pszSrc == NULL)}
\DoxyCodeLine{4334             \{}
\DoxyCodeLine{4335                 pszSrc = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{4336             \}}
\DoxyCodeLine{4337         \}}
\DoxyCodeLine{4338 }
\DoxyCodeLine{4339         \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{4340         \{}
\DoxyCodeLine{4341             \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{4342             \{}
\DoxyCodeLine{4343                 pszDestEnd = pszDest;}
\DoxyCodeLine{4344                 cchRemaining = 0;}
\DoxyCodeLine{4345 }
\DoxyCodeLine{4346                 \textcolor{comment}{// only fail if there was actually src data to copy}}
\DoxyCodeLine{4347                 \textcolor{keywordflow}{if} (*pszSrc != \textcolor{charliteral}{'\(\backslash\)0'})}
\DoxyCodeLine{4348                 \{}
\DoxyCodeLine{4349                     \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{4350                     \{}
\DoxyCodeLine{4351                         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4352                     \}}
\DoxyCodeLine{4353                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4354                     \{}
\DoxyCodeLine{4355                         hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{4356                     \}}
\DoxyCodeLine{4357                 \}}
\DoxyCodeLine{4358             \}}
\DoxyCodeLine{4359             \textcolor{keywordflow}{else}}
\DoxyCodeLine{4360             \{}
\DoxyCodeLine{4361                 pszDestEnd = pszDest;}
\DoxyCodeLine{4362                 cchRemaining = cchDest;}
\DoxyCodeLine{4363 }
\DoxyCodeLine{4364                 \textcolor{keywordflow}{while} (cchRemaining \&\& (*pszSrc != \textcolor{charliteral}{'\(\backslash\)0'}))}
\DoxyCodeLine{4365                 \{}
\DoxyCodeLine{4366                     *pszDestEnd++= *pszSrc++;}
\DoxyCodeLine{4367                     cchRemaining-\/-\/;}
\DoxyCodeLine{4368                 \}}
\DoxyCodeLine{4369 }
\DoxyCodeLine{4370                 \textcolor{keywordflow}{if} (cchRemaining > 0)}
\DoxyCodeLine{4371                 \{}
\DoxyCodeLine{4372                     \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_BEHIND\_NULL)}
\DoxyCodeLine{4373                     \{}
\DoxyCodeLine{4374                         memset(pszDestEnd + 1, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), ((cchRemaining -\/ 1) * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})) + (cbDest \% \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})));}
\DoxyCodeLine{4375                     \}}
\DoxyCodeLine{4376                 \}}
\DoxyCodeLine{4377                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{4378                 \{}
\DoxyCodeLine{4379                     \textcolor{comment}{// we are going to truncate pszDest}}
\DoxyCodeLine{4380                     pszDestEnd-\/-\/;}
\DoxyCodeLine{4381                     cchRemaining++;}
\DoxyCodeLine{4382 }
\DoxyCodeLine{4383                     hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{4384                 \}}
\DoxyCodeLine{4385 }
\DoxyCodeLine{4386                 *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4387             \}}
\DoxyCodeLine{4388         \}}
\DoxyCodeLine{4389     \}}
\DoxyCodeLine{4390 }
\DoxyCodeLine{4391     \textcolor{keywordflow}{if} (FAILED(hr))}
\DoxyCodeLine{4392     \{}
\DoxyCodeLine{4393         \textcolor{keywordflow}{if} (pszDest)}
\DoxyCodeLine{4394         \{}
\DoxyCodeLine{4395             \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_ON\_FAILURE)}
\DoxyCodeLine{4396             \{}
\DoxyCodeLine{4397                 memset(pszDest, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), cbDest);}
\DoxyCodeLine{4398 }
\DoxyCodeLine{4399                 \textcolor{keywordflow}{if} (STRSAFE\_GET\_FILL\_PATTERN(dwFlags) == 0)}
\DoxyCodeLine{4400                 \{}
\DoxyCodeLine{4401                     pszDestEnd = pszDest;}
\DoxyCodeLine{4402                     cchRemaining = cchDest;}
\DoxyCodeLine{4403                 \}}
\DoxyCodeLine{4404                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{4405                 \{}
\DoxyCodeLine{4406                     pszDestEnd = pszDest + cchDest -\/ 1;}
\DoxyCodeLine{4407                     cchRemaining = 1;}
\DoxyCodeLine{4408 }
\DoxyCodeLine{4409                     \textcolor{comment}{// null terminate the end of the string}}
\DoxyCodeLine{4410                     *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4411                 \}}
\DoxyCodeLine{4412             \}}
\DoxyCodeLine{4413 }
\DoxyCodeLine{4414             \textcolor{keywordflow}{if} (dwFlags \& (STRSAFE\_NULL\_ON\_FAILURE | STRSAFE\_NO\_TRUNCATION))}
\DoxyCodeLine{4415             \{}
\DoxyCodeLine{4416                 \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{4417                 \{}
\DoxyCodeLine{4418                     pszDestEnd = pszDest;}
\DoxyCodeLine{4419                     cchRemaining = cchDest;}
\DoxyCodeLine{4420 }
\DoxyCodeLine{4421                     \textcolor{comment}{// null terminate the beginning of the string}}
\DoxyCodeLine{4422                     *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4423                 \}}
\DoxyCodeLine{4424             \}}
\DoxyCodeLine{4425         \}}
\DoxyCodeLine{4426     \}}
\DoxyCodeLine{4427 }
\DoxyCodeLine{4428     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{4429     \{}
\DoxyCodeLine{4430         \textcolor{keywordflow}{if} (ppszDestEnd)}
\DoxyCodeLine{4431         \{}
\DoxyCodeLine{4432             *ppszDestEnd = pszDestEnd;}
\DoxyCodeLine{4433         \}}
\DoxyCodeLine{4434 }
\DoxyCodeLine{4435         \textcolor{keywordflow}{if} (pcchRemaining)}
\DoxyCodeLine{4436         \{}
\DoxyCodeLine{4437             *pcchRemaining = cchRemaining;}
\DoxyCodeLine{4438         \}}
\DoxyCodeLine{4439     \}}
\DoxyCodeLine{4440 }
\DoxyCodeLine{4441     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{4442 \}}
\DoxyCodeLine{4443 }
\DoxyCodeLine{4444 STRSAFEAPI StringCopyExWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{4445 \{}
\DoxyCodeLine{4446     HRESULT hr = S\_OK;}
\DoxyCodeLine{4447     \textcolor{keywordtype}{wchar\_t}* pszDestEnd = pszDest;}
\DoxyCodeLine{4448     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{4449 }
\DoxyCodeLine{4450     \textcolor{comment}{// ASSERT(cbDest == (cchDest * sizeof(wchar\_t)) ||}}
\DoxyCodeLine{4451     \textcolor{comment}{//        cbDest == (cchDest * sizeof(wchar\_t)) + (cbDest \% sizeof(wchar\_t)));}}
\DoxyCodeLine{4452 }
\DoxyCodeLine{4453     \textcolor{comment}{// only accept valid flags}}
\DoxyCodeLine{4454     \textcolor{keywordflow}{if} (dwFlags \& (\string~STRSAFE\_VALID\_FLAGS))}
\DoxyCodeLine{4455     \{}
\DoxyCodeLine{4456         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4457     \}}
\DoxyCodeLine{4458     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4459     \{}
\DoxyCodeLine{4460         \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_IGNORE\_NULLS)}
\DoxyCodeLine{4461         \{}
\DoxyCodeLine{4462             \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{4463             \{}
\DoxyCodeLine{4464                 \textcolor{keywordflow}{if} ((cchDest != 0) || (cbDest != 0))}
\DoxyCodeLine{4465                 \{}
\DoxyCodeLine{4466                     \textcolor{comment}{// NULL pszDest and non-\/zero cchDest/cbDest is invalid}}
\DoxyCodeLine{4467                     hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4468                 \}}
\DoxyCodeLine{4469             \}}
\DoxyCodeLine{4470 }
\DoxyCodeLine{4471             \textcolor{keywordflow}{if} (pszSrc == NULL)}
\DoxyCodeLine{4472             \{}
\DoxyCodeLine{4473                 pszSrc = L\textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{4474             \}}
\DoxyCodeLine{4475         \}}
\DoxyCodeLine{4476 }
\DoxyCodeLine{4477         \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{4478         \{}
\DoxyCodeLine{4479             \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{4480             \{}
\DoxyCodeLine{4481                 pszDestEnd = pszDest;}
\DoxyCodeLine{4482                 cchRemaining = 0;}
\DoxyCodeLine{4483 }
\DoxyCodeLine{4484                 \textcolor{comment}{// only fail if there was actually src data to copy}}
\DoxyCodeLine{4485                 \textcolor{keywordflow}{if} (*pszSrc != L\textcolor{charliteral}{'\(\backslash\)0'})}
\DoxyCodeLine{4486                 \{}
\DoxyCodeLine{4487                     \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{4488                     \{}
\DoxyCodeLine{4489                         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4490                     \}}
\DoxyCodeLine{4491                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4492                     \{}
\DoxyCodeLine{4493                         hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{4494                     \}}
\DoxyCodeLine{4495                 \}}
\DoxyCodeLine{4496             \}}
\DoxyCodeLine{4497             \textcolor{keywordflow}{else}}
\DoxyCodeLine{4498             \{}
\DoxyCodeLine{4499                 pszDestEnd = pszDest;}
\DoxyCodeLine{4500                 cchRemaining = cchDest;}
\DoxyCodeLine{4501 }
\DoxyCodeLine{4502                 \textcolor{keywordflow}{while} (cchRemaining \&\& (*pszSrc != L\textcolor{charliteral}{'\(\backslash\)0'}))}
\DoxyCodeLine{4503                 \{}
\DoxyCodeLine{4504                     *pszDestEnd++= *pszSrc++;}
\DoxyCodeLine{4505                     cchRemaining-\/-\/;}
\DoxyCodeLine{4506                 \}}
\DoxyCodeLine{4507 }
\DoxyCodeLine{4508                 \textcolor{keywordflow}{if} (cchRemaining > 0)}
\DoxyCodeLine{4509                 \{}
\DoxyCodeLine{4510                     \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_BEHIND\_NULL)}
\DoxyCodeLine{4511                     \{}
\DoxyCodeLine{4512                         memset(pszDestEnd + 1, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), ((cchRemaining -\/ 1) * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t})) + (cbDest \% \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t})));}
\DoxyCodeLine{4513                     \}}
\DoxyCodeLine{4514                 \}}
\DoxyCodeLine{4515                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{4516                 \{}
\DoxyCodeLine{4517                     \textcolor{comment}{// we are going to truncate pszDest}}
\DoxyCodeLine{4518                     pszDestEnd-\/-\/;}
\DoxyCodeLine{4519                     cchRemaining++;}
\DoxyCodeLine{4520 }
\DoxyCodeLine{4521                     hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{4522                 \}}
\DoxyCodeLine{4523 }
\DoxyCodeLine{4524                 *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4525             \}}
\DoxyCodeLine{4526         \}}
\DoxyCodeLine{4527     \}}
\DoxyCodeLine{4528 }
\DoxyCodeLine{4529     \textcolor{keywordflow}{if} (FAILED(hr))}
\DoxyCodeLine{4530     \{}
\DoxyCodeLine{4531         \textcolor{keywordflow}{if} (pszDest)}
\DoxyCodeLine{4532         \{}
\DoxyCodeLine{4533             \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_ON\_FAILURE)}
\DoxyCodeLine{4534             \{}
\DoxyCodeLine{4535                 memset(pszDest, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), cbDest);}
\DoxyCodeLine{4536 }
\DoxyCodeLine{4537                 \textcolor{keywordflow}{if} (STRSAFE\_GET\_FILL\_PATTERN(dwFlags) == 0)}
\DoxyCodeLine{4538                 \{}
\DoxyCodeLine{4539                     pszDestEnd = pszDest;}
\DoxyCodeLine{4540                     cchRemaining = cchDest;}
\DoxyCodeLine{4541                 \}}
\DoxyCodeLine{4542                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{4543                 \{}
\DoxyCodeLine{4544                     pszDestEnd = pszDest + cchDest -\/ 1;}
\DoxyCodeLine{4545                     cchRemaining = 1;}
\DoxyCodeLine{4546 }
\DoxyCodeLine{4547                     \textcolor{comment}{// null terminate the end of the string}}
\DoxyCodeLine{4548                     *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4549                 \}}
\DoxyCodeLine{4550             \}}
\DoxyCodeLine{4551 }
\DoxyCodeLine{4552             \textcolor{keywordflow}{if} (dwFlags \& (STRSAFE\_NULL\_ON\_FAILURE | STRSAFE\_NO\_TRUNCATION))}
\DoxyCodeLine{4553             \{}
\DoxyCodeLine{4554                 \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{4555                 \{}
\DoxyCodeLine{4556                     pszDestEnd = pszDest;}
\DoxyCodeLine{4557                     cchRemaining = cchDest;}
\DoxyCodeLine{4558 }
\DoxyCodeLine{4559                     \textcolor{comment}{// null terminate the beginning of the string}}
\DoxyCodeLine{4560                     *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4561                 \}}
\DoxyCodeLine{4562             \}}
\DoxyCodeLine{4563         \}}
\DoxyCodeLine{4564     \}}
\DoxyCodeLine{4565 }
\DoxyCodeLine{4566     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{4567     \{}
\DoxyCodeLine{4568         \textcolor{keywordflow}{if} (ppszDestEnd)}
\DoxyCodeLine{4569         \{}
\DoxyCodeLine{4570             *ppszDestEnd = pszDestEnd;}
\DoxyCodeLine{4571         \}}
\DoxyCodeLine{4572 }
\DoxyCodeLine{4573         \textcolor{keywordflow}{if} (pcchRemaining)}
\DoxyCodeLine{4574         \{}
\DoxyCodeLine{4575             *pcchRemaining = cchRemaining;}
\DoxyCodeLine{4576         \}}
\DoxyCodeLine{4577     \}}
\DoxyCodeLine{4578 }
\DoxyCodeLine{4579     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{4580 \}}
\DoxyCodeLine{4581 }
\DoxyCodeLine{4582 STRSAFEAPI StringCopyNWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cchSrc)}
\DoxyCodeLine{4583 \{}
\DoxyCodeLine{4584     HRESULT hr = S\_OK;}
\DoxyCodeLine{4585 }
\DoxyCodeLine{4586     \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{4587     \{}
\DoxyCodeLine{4588         \textcolor{comment}{// can not null terminate a zero-\/byte dest buffer}}
\DoxyCodeLine{4589         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4590     \}}
\DoxyCodeLine{4591     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4592     \{}
\DoxyCodeLine{4593         \textcolor{keywordflow}{while} (cchDest \&\& cchSrc \&\& (*pszSrc != \textcolor{charliteral}{'\(\backslash\)0'}))}
\DoxyCodeLine{4594         \{}
\DoxyCodeLine{4595             *pszDest++= *pszSrc++;}
\DoxyCodeLine{4596             cchDest-\/-\/;}
\DoxyCodeLine{4597             cchSrc-\/-\/;}
\DoxyCodeLine{4598         \}}
\DoxyCodeLine{4599 }
\DoxyCodeLine{4600         \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{4601         \{}
\DoxyCodeLine{4602             \textcolor{comment}{// we are going to truncate pszDest}}
\DoxyCodeLine{4603             pszDest-\/-\/;}
\DoxyCodeLine{4604             hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{4605         \}}
\DoxyCodeLine{4606 }
\DoxyCodeLine{4607         *pszDest= \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4608     \}}
\DoxyCodeLine{4609 }
\DoxyCodeLine{4610     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{4611 \}}
\DoxyCodeLine{4612 }
\DoxyCodeLine{4613 STRSAFEAPI StringCopyNWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cchSrc)}
\DoxyCodeLine{4614 \{}
\DoxyCodeLine{4615     HRESULT hr = S\_OK;}
\DoxyCodeLine{4616 }
\DoxyCodeLine{4617     \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{4618     \{}
\DoxyCodeLine{4619         \textcolor{comment}{// can not null terminate a zero-\/byte dest buffer}}
\DoxyCodeLine{4620         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4621     \}}
\DoxyCodeLine{4622     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4623     \{}
\DoxyCodeLine{4624         \textcolor{keywordflow}{while} (cchDest \&\& cchSrc \&\& (*pszSrc != L\textcolor{charliteral}{'\(\backslash\)0'}))}
\DoxyCodeLine{4625         \{}
\DoxyCodeLine{4626             *pszDest++= *pszSrc++;}
\DoxyCodeLine{4627             cchDest-\/-\/;}
\DoxyCodeLine{4628             cchSrc-\/-\/;}
\DoxyCodeLine{4629         \}}
\DoxyCodeLine{4630 }
\DoxyCodeLine{4631         \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{4632         \{}
\DoxyCodeLine{4633             \textcolor{comment}{// we are going to truncate pszDest}}
\DoxyCodeLine{4634             pszDest-\/-\/;}
\DoxyCodeLine{4635             hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{4636         \}}
\DoxyCodeLine{4637 }
\DoxyCodeLine{4638         *pszDest= L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4639     \}}
\DoxyCodeLine{4640 }
\DoxyCodeLine{4641     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{4642 \}}
\DoxyCodeLine{4643 }
\DoxyCodeLine{4644 STRSAFEAPI StringCopyNExWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cchSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{4645 \{}
\DoxyCodeLine{4646     HRESULT hr = S\_OK;}
\DoxyCodeLine{4647     \textcolor{keywordtype}{char}* pszDestEnd = pszDest;}
\DoxyCodeLine{4648     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{4649 }
\DoxyCodeLine{4650     \textcolor{comment}{// ASSERT(cbDest == (cchDest * sizeof(char))    ||}}
\DoxyCodeLine{4651     \textcolor{comment}{//        cbDest == (cchDest * sizeof(char)) + (cbDest \% sizeof(char)));}}
\DoxyCodeLine{4652 }
\DoxyCodeLine{4653     \textcolor{comment}{// only accept valid flags}}
\DoxyCodeLine{4654     \textcolor{keywordflow}{if} (dwFlags \& (\string~STRSAFE\_VALID\_FLAGS))}
\DoxyCodeLine{4655     \{}
\DoxyCodeLine{4656         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4657     \}}
\DoxyCodeLine{4658     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4659     \{}
\DoxyCodeLine{4660         \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_IGNORE\_NULLS)}
\DoxyCodeLine{4661         \{}
\DoxyCodeLine{4662             \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{4663             \{}
\DoxyCodeLine{4664                 \textcolor{keywordflow}{if} ((cchDest != 0) || (cbDest != 0))}
\DoxyCodeLine{4665                 \{}
\DoxyCodeLine{4666                     \textcolor{comment}{// NULL pszDest and non-\/zero cchDest/cbDest is invalid}}
\DoxyCodeLine{4667                     hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4668                 \}}
\DoxyCodeLine{4669             \}}
\DoxyCodeLine{4670 }
\DoxyCodeLine{4671             \textcolor{keywordflow}{if} (pszSrc == NULL)}
\DoxyCodeLine{4672             \{}
\DoxyCodeLine{4673                 pszSrc = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{4674             \}}
\DoxyCodeLine{4675         \}}
\DoxyCodeLine{4676 }
\DoxyCodeLine{4677         \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{4678         \{}
\DoxyCodeLine{4679             \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{4680             \{}
\DoxyCodeLine{4681                 pszDestEnd = pszDest;}
\DoxyCodeLine{4682                 cchRemaining = 0;}
\DoxyCodeLine{4683 }
\DoxyCodeLine{4684                 \textcolor{comment}{// only fail if there was actually src data to copy}}
\DoxyCodeLine{4685                 \textcolor{keywordflow}{if} (*pszSrc != \textcolor{charliteral}{'\(\backslash\)0'})}
\DoxyCodeLine{4686                 \{}
\DoxyCodeLine{4687                     \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{4688                     \{}
\DoxyCodeLine{4689                         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4690                     \}}
\DoxyCodeLine{4691                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4692                     \{}
\DoxyCodeLine{4693                         hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{4694                     \}}
\DoxyCodeLine{4695                 \}}
\DoxyCodeLine{4696             \}}
\DoxyCodeLine{4697             \textcolor{keywordflow}{else}}
\DoxyCodeLine{4698             \{}
\DoxyCodeLine{4699                 pszDestEnd = pszDest;}
\DoxyCodeLine{4700                 cchRemaining = cchDest;}
\DoxyCodeLine{4701 }
\DoxyCodeLine{4702                 \textcolor{keywordflow}{while} (cchRemaining \&\& cchSrc \&\& (*pszSrc != \textcolor{charliteral}{'\(\backslash\)0'}))}
\DoxyCodeLine{4703                 \{}
\DoxyCodeLine{4704                     *pszDestEnd++= *pszSrc++;}
\DoxyCodeLine{4705                     cchRemaining-\/-\/;}
\DoxyCodeLine{4706                     cchSrc-\/-\/;}
\DoxyCodeLine{4707                 \}}
\DoxyCodeLine{4708 }
\DoxyCodeLine{4709                 \textcolor{keywordflow}{if} (cchRemaining > 0)}
\DoxyCodeLine{4710                 \{}
\DoxyCodeLine{4711                     \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_BEHIND\_NULL)}
\DoxyCodeLine{4712                     \{}
\DoxyCodeLine{4713                         memset(pszDestEnd + 1, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), ((cchRemaining -\/ 1) * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})) + (cbDest \% \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})));}
\DoxyCodeLine{4714                     \}}
\DoxyCodeLine{4715                 \}}
\DoxyCodeLine{4716                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{4717                 \{}
\DoxyCodeLine{4718                     \textcolor{comment}{// we are going to truncate pszDest}}
\DoxyCodeLine{4719                     pszDestEnd-\/-\/;}
\DoxyCodeLine{4720                     cchRemaining++;}
\DoxyCodeLine{4721 }
\DoxyCodeLine{4722                     hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{4723                 \}}
\DoxyCodeLine{4724 }
\DoxyCodeLine{4725                 *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4726             \}}
\DoxyCodeLine{4727         \}}
\DoxyCodeLine{4728     \}}
\DoxyCodeLine{4729 }
\DoxyCodeLine{4730     \textcolor{keywordflow}{if} (FAILED(hr))}
\DoxyCodeLine{4731     \{}
\DoxyCodeLine{4732         \textcolor{keywordflow}{if} (pszDest)}
\DoxyCodeLine{4733         \{}
\DoxyCodeLine{4734             \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_ON\_FAILURE)}
\DoxyCodeLine{4735             \{}
\DoxyCodeLine{4736                 memset(pszDest, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), cbDest);}
\DoxyCodeLine{4737 }
\DoxyCodeLine{4738                 \textcolor{keywordflow}{if} (STRSAFE\_GET\_FILL\_PATTERN(dwFlags) == 0)}
\DoxyCodeLine{4739                 \{}
\DoxyCodeLine{4740                     pszDestEnd = pszDest;}
\DoxyCodeLine{4741                     cchRemaining = cchDest;}
\DoxyCodeLine{4742                 \}}
\DoxyCodeLine{4743                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{4744                 \{}
\DoxyCodeLine{4745                     pszDestEnd = pszDest + cchDest -\/ 1;}
\DoxyCodeLine{4746                     cchRemaining = 1;}
\DoxyCodeLine{4747 }
\DoxyCodeLine{4748                     \textcolor{comment}{// null terminate the end of the string}}
\DoxyCodeLine{4749                     *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4750                 \}}
\DoxyCodeLine{4751             \}}
\DoxyCodeLine{4752 }
\DoxyCodeLine{4753             \textcolor{keywordflow}{if} (dwFlags \& (STRSAFE\_NULL\_ON\_FAILURE | STRSAFE\_NO\_TRUNCATION))}
\DoxyCodeLine{4754             \{}
\DoxyCodeLine{4755                 \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{4756                 \{}
\DoxyCodeLine{4757                     pszDestEnd = pszDest;}
\DoxyCodeLine{4758                     cchRemaining = cchDest;}
\DoxyCodeLine{4759 }
\DoxyCodeLine{4760                     \textcolor{comment}{// null terminate the beginning of the string}}
\DoxyCodeLine{4761                     *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4762                 \}}
\DoxyCodeLine{4763             \}}
\DoxyCodeLine{4764         \}}
\DoxyCodeLine{4765     \}}
\DoxyCodeLine{4766 }
\DoxyCodeLine{4767     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{4768     \{}
\DoxyCodeLine{4769         \textcolor{keywordflow}{if} (ppszDestEnd)}
\DoxyCodeLine{4770         \{}
\DoxyCodeLine{4771             *ppszDestEnd = pszDestEnd;}
\DoxyCodeLine{4772         \}}
\DoxyCodeLine{4773 }
\DoxyCodeLine{4774         \textcolor{keywordflow}{if} (pcchRemaining)}
\DoxyCodeLine{4775         \{}
\DoxyCodeLine{4776             *pcchRemaining = cchRemaining;}
\DoxyCodeLine{4777         \}}
\DoxyCodeLine{4778     \}}
\DoxyCodeLine{4779 }
\DoxyCodeLine{4780     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{4781 \}}
\DoxyCodeLine{4782 }
\DoxyCodeLine{4783 STRSAFEAPI StringCopyNExWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cchSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{4784 \{}
\DoxyCodeLine{4785     HRESULT hr = S\_OK;}
\DoxyCodeLine{4786     \textcolor{keywordtype}{wchar\_t}* pszDestEnd = pszDest;}
\DoxyCodeLine{4787     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{4788 }
\DoxyCodeLine{4789     \textcolor{comment}{// ASSERT(cbDest == (cchDest * sizeof(wchar\_t)) ||}}
\DoxyCodeLine{4790     \textcolor{comment}{//        cbDest == (cchDest * sizeof(wchar\_t)) + (cbDest \% sizeof(wchar\_t)));}}
\DoxyCodeLine{4791 }
\DoxyCodeLine{4792     \textcolor{comment}{// only accept valid flags}}
\DoxyCodeLine{4793     \textcolor{keywordflow}{if} (dwFlags \& (\string~STRSAFE\_VALID\_FLAGS))}
\DoxyCodeLine{4794     \{}
\DoxyCodeLine{4795         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4796     \}}
\DoxyCodeLine{4797     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4798     \{}
\DoxyCodeLine{4799         \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_IGNORE\_NULLS)}
\DoxyCodeLine{4800         \{}
\DoxyCodeLine{4801             \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{4802             \{}
\DoxyCodeLine{4803                 \textcolor{keywordflow}{if} ((cchDest != 0) || (cbDest != 0))}
\DoxyCodeLine{4804                 \{}
\DoxyCodeLine{4805                     \textcolor{comment}{// NULL pszDest and non-\/zero cchDest/cbDest is invalid}}
\DoxyCodeLine{4806                     hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4807                 \}}
\DoxyCodeLine{4808             \}}
\DoxyCodeLine{4809 }
\DoxyCodeLine{4810             \textcolor{keywordflow}{if} (pszSrc == NULL)}
\DoxyCodeLine{4811             \{}
\DoxyCodeLine{4812                 pszSrc = L\textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{4813             \}}
\DoxyCodeLine{4814         \}}
\DoxyCodeLine{4815 }
\DoxyCodeLine{4816         \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{4817         \{}
\DoxyCodeLine{4818             \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{4819             \{}
\DoxyCodeLine{4820                 pszDestEnd = pszDest;}
\DoxyCodeLine{4821                 cchRemaining = 0;}
\DoxyCodeLine{4822 }
\DoxyCodeLine{4823                 \textcolor{comment}{// only fail if there was actually src data to copy}}
\DoxyCodeLine{4824                 \textcolor{keywordflow}{if} (*pszSrc != L\textcolor{charliteral}{'\(\backslash\)0'})}
\DoxyCodeLine{4825                 \{}
\DoxyCodeLine{4826                     \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{4827                     \{}
\DoxyCodeLine{4828                         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4829                     \}}
\DoxyCodeLine{4830                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4831                     \{}
\DoxyCodeLine{4832                         hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{4833                     \}}
\DoxyCodeLine{4834                 \}}
\DoxyCodeLine{4835             \}}
\DoxyCodeLine{4836             \textcolor{keywordflow}{else}}
\DoxyCodeLine{4837             \{}
\DoxyCodeLine{4838                 pszDestEnd = pszDest;}
\DoxyCodeLine{4839                 cchRemaining = cchDest;}
\DoxyCodeLine{4840 }
\DoxyCodeLine{4841                 \textcolor{keywordflow}{while} (cchRemaining \&\& cchSrc \&\& (*pszSrc != L\textcolor{charliteral}{'\(\backslash\)0'}))}
\DoxyCodeLine{4842                 \{}
\DoxyCodeLine{4843                     *pszDestEnd++= *pszSrc++;}
\DoxyCodeLine{4844                     cchRemaining-\/-\/;}
\DoxyCodeLine{4845                     cchSrc-\/-\/;}
\DoxyCodeLine{4846                 \}}
\DoxyCodeLine{4847 }
\DoxyCodeLine{4848                 \textcolor{keywordflow}{if} (cchRemaining > 0)}
\DoxyCodeLine{4849                 \{}
\DoxyCodeLine{4850                     \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_BEHIND\_NULL)}
\DoxyCodeLine{4851                     \{}
\DoxyCodeLine{4852                         memset(pszDestEnd + 1, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), ((cchRemaining -\/ 1) * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t})) + (cbDest \% \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t})));}
\DoxyCodeLine{4853                     \}}
\DoxyCodeLine{4854                 \}}
\DoxyCodeLine{4855                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{4856                 \{}
\DoxyCodeLine{4857                     \textcolor{comment}{// we are going to truncate pszDest}}
\DoxyCodeLine{4858                     pszDestEnd-\/-\/;}
\DoxyCodeLine{4859                     cchRemaining++;}
\DoxyCodeLine{4860 }
\DoxyCodeLine{4861                     hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{4862                 \}}
\DoxyCodeLine{4863 }
\DoxyCodeLine{4864                 *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4865             \}}
\DoxyCodeLine{4866         \}}
\DoxyCodeLine{4867     \}}
\DoxyCodeLine{4868 }
\DoxyCodeLine{4869     \textcolor{keywordflow}{if} (FAILED(hr))}
\DoxyCodeLine{4870     \{}
\DoxyCodeLine{4871         \textcolor{keywordflow}{if} (pszDest)}
\DoxyCodeLine{4872         \{}
\DoxyCodeLine{4873             \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_ON\_FAILURE)}
\DoxyCodeLine{4874             \{}
\DoxyCodeLine{4875                 memset(pszDest, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), cbDest);}
\DoxyCodeLine{4876 }
\DoxyCodeLine{4877                 \textcolor{keywordflow}{if} (STRSAFE\_GET\_FILL\_PATTERN(dwFlags) == 0)}
\DoxyCodeLine{4878                 \{}
\DoxyCodeLine{4879                     pszDestEnd = pszDest;}
\DoxyCodeLine{4880                     cchRemaining = cchDest;}
\DoxyCodeLine{4881                 \}}
\DoxyCodeLine{4882                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{4883                 \{}
\DoxyCodeLine{4884                     pszDestEnd = pszDest + cchDest -\/ 1;}
\DoxyCodeLine{4885                     cchRemaining = 1;}
\DoxyCodeLine{4886 }
\DoxyCodeLine{4887                     \textcolor{comment}{// null terminate the end of the string}}
\DoxyCodeLine{4888                     *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4889                 \}}
\DoxyCodeLine{4890             \}}
\DoxyCodeLine{4891 }
\DoxyCodeLine{4892             \textcolor{keywordflow}{if} (dwFlags \& (STRSAFE\_NULL\_ON\_FAILURE | STRSAFE\_NO\_TRUNCATION))}
\DoxyCodeLine{4893             \{}
\DoxyCodeLine{4894                 \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{4895                 \{}
\DoxyCodeLine{4896                     pszDestEnd = pszDest;}
\DoxyCodeLine{4897                     cchRemaining = cchDest;}
\DoxyCodeLine{4898 }
\DoxyCodeLine{4899                     \textcolor{comment}{// null terminate the beginning of the string}}
\DoxyCodeLine{4900                     *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4901                 \}}
\DoxyCodeLine{4902             \}}
\DoxyCodeLine{4903         \}}
\DoxyCodeLine{4904     \}}
\DoxyCodeLine{4905 }
\DoxyCodeLine{4906     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{4907     \{}
\DoxyCodeLine{4908         \textcolor{keywordflow}{if} (ppszDestEnd)}
\DoxyCodeLine{4909         \{}
\DoxyCodeLine{4910             *ppszDestEnd = pszDestEnd;}
\DoxyCodeLine{4911         \}}
\DoxyCodeLine{4912 }
\DoxyCodeLine{4913         \textcolor{keywordflow}{if} (pcchRemaining)}
\DoxyCodeLine{4914         \{}
\DoxyCodeLine{4915             *pcchRemaining = cchRemaining;}
\DoxyCodeLine{4916         \}}
\DoxyCodeLine{4917     \}}
\DoxyCodeLine{4918 }
\DoxyCodeLine{4919     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{4920 \}}
\DoxyCodeLine{4921 }
\DoxyCodeLine{4922 STRSAFEAPI StringCatWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc)}
\DoxyCodeLine{4923 \{}
\DoxyCodeLine{4924    HRESULT hr;}
\DoxyCodeLine{4925    \textcolor{keywordtype}{size\_t} cchDestCurrent;}
\DoxyCodeLine{4926 }
\DoxyCodeLine{4927    hr = StringLengthWorkerA(pszDest, cchDest, \&cchDestCurrent);}
\DoxyCodeLine{4928 }
\DoxyCodeLine{4929    \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{4930    \{}
\DoxyCodeLine{4931        hr = StringCopyWorkerA(pszDest + cchDestCurrent,}
\DoxyCodeLine{4932                               cchDest -\/ cchDestCurrent,}
\DoxyCodeLine{4933                               pszSrc);}
\DoxyCodeLine{4934    \}}
\DoxyCodeLine{4935 }
\DoxyCodeLine{4936    \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{4937 \}}
\DoxyCodeLine{4938 }
\DoxyCodeLine{4939 STRSAFEAPI StringCatWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc)}
\DoxyCodeLine{4940 \{}
\DoxyCodeLine{4941    HRESULT hr;}
\DoxyCodeLine{4942    \textcolor{keywordtype}{size\_t} cchDestCurrent;}
\DoxyCodeLine{4943 }
\DoxyCodeLine{4944    hr = StringLengthWorkerW(pszDest, cchDest, \&cchDestCurrent);}
\DoxyCodeLine{4945 }
\DoxyCodeLine{4946    \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{4947    \{}
\DoxyCodeLine{4948        hr = StringCopyWorkerW(pszDest + cchDestCurrent,}
\DoxyCodeLine{4949                               cchDest -\/ cchDestCurrent,}
\DoxyCodeLine{4950                               pszSrc);}
\DoxyCodeLine{4951    \}}
\DoxyCodeLine{4952 }
\DoxyCodeLine{4953    \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{4954 \}}
\DoxyCodeLine{4955 }
\DoxyCodeLine{4956 STRSAFEAPI StringCatExWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{4957 \{}
\DoxyCodeLine{4958     HRESULT hr = S\_OK;}
\DoxyCodeLine{4959     \textcolor{keywordtype}{char}* pszDestEnd = pszDest;}
\DoxyCodeLine{4960     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{4961 }
\DoxyCodeLine{4962     \textcolor{comment}{// ASSERT(cbDest == (cchDest * sizeof(char))    ||}}
\DoxyCodeLine{4963     \textcolor{comment}{//        cbDest == (cchDest * sizeof(char)) + (cbDest \% sizeof(char)));}}
\DoxyCodeLine{4964 }
\DoxyCodeLine{4965     \textcolor{comment}{// only accept valid flags}}
\DoxyCodeLine{4966     \textcolor{keywordflow}{if} (dwFlags \& (\string~STRSAFE\_VALID\_FLAGS))}
\DoxyCodeLine{4967     \{}
\DoxyCodeLine{4968         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4969     \}}
\DoxyCodeLine{4970     \textcolor{keywordflow}{else}}
\DoxyCodeLine{4971     \{}
\DoxyCodeLine{4972         \textcolor{keywordtype}{size\_t} cchDestCurrent;}
\DoxyCodeLine{4973 }
\DoxyCodeLine{4974         \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_IGNORE\_NULLS)}
\DoxyCodeLine{4975         \{}
\DoxyCodeLine{4976             \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{4977             \{}
\DoxyCodeLine{4978                 \textcolor{keywordflow}{if} ((cchDest == 0) \&\& (cbDest == 0))}
\DoxyCodeLine{4979                 \{}
\DoxyCodeLine{4980                     cchDestCurrent = 0;}
\DoxyCodeLine{4981                 \}}
\DoxyCodeLine{4982                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{4983                 \{}
\DoxyCodeLine{4984                     \textcolor{comment}{// NULL pszDest and non-\/zero cchDest/cbDest is invalid}}
\DoxyCodeLine{4985                     hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{4986                 \}}
\DoxyCodeLine{4987             \}}
\DoxyCodeLine{4988             \textcolor{keywordflow}{else}}
\DoxyCodeLine{4989             \{}
\DoxyCodeLine{4990                 hr = StringLengthWorkerA(pszDest, cchDest, \&cchDestCurrent);}
\DoxyCodeLine{4991 }
\DoxyCodeLine{4992                 \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{4993                 \{}
\DoxyCodeLine{4994                     pszDestEnd = pszDest + cchDestCurrent;}
\DoxyCodeLine{4995                     cchRemaining = cchDest -\/ cchDestCurrent;}
\DoxyCodeLine{4996                 \}}
\DoxyCodeLine{4997             \}}
\DoxyCodeLine{4998 }
\DoxyCodeLine{4999             \textcolor{keywordflow}{if} (pszSrc == NULL)}
\DoxyCodeLine{5000             \{}
\DoxyCodeLine{5001                 pszSrc = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{5002             \}}
\DoxyCodeLine{5003         \}}
\DoxyCodeLine{5004         \textcolor{keywordflow}{else}}
\DoxyCodeLine{5005         \{}
\DoxyCodeLine{5006             hr = StringLengthWorkerA(pszDest, cchDest, \&cchDestCurrent);}
\DoxyCodeLine{5007 }
\DoxyCodeLine{5008             \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{5009             \{}
\DoxyCodeLine{5010                 pszDestEnd = pszDest + cchDestCurrent;}
\DoxyCodeLine{5011                 cchRemaining = cchDest -\/ cchDestCurrent;}
\DoxyCodeLine{5012             \}}
\DoxyCodeLine{5013         \}}
\DoxyCodeLine{5014 }
\DoxyCodeLine{5015         \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{5016         \{}
\DoxyCodeLine{5017             \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{5018             \{}
\DoxyCodeLine{5019                 \textcolor{comment}{// only fail if there was actually src data to append}}
\DoxyCodeLine{5020                 \textcolor{keywordflow}{if} (*pszSrc != \textcolor{charliteral}{'\(\backslash\)0'})}
\DoxyCodeLine{5021                 \{}
\DoxyCodeLine{5022                     \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{5023                     \{}
\DoxyCodeLine{5024                         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5025                     \}}
\DoxyCodeLine{5026                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5027                     \{}
\DoxyCodeLine{5028                         hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{5029                     \}}
\DoxyCodeLine{5030                 \}}
\DoxyCodeLine{5031             \}}
\DoxyCodeLine{5032             \textcolor{keywordflow}{else}}
\DoxyCodeLine{5033             \{}
\DoxyCodeLine{5034                 \textcolor{comment}{// we handle the STRSAFE\_FILL\_ON\_FAILURE and STRSAFE\_NULL\_ON\_FAILURE cases below, so do not pass}}
\DoxyCodeLine{5035                 \textcolor{comment}{// those flags through}}
\DoxyCodeLine{5036                 hr = StringCopyExWorkerA(pszDestEnd,}
\DoxyCodeLine{5037                                          cchRemaining,}
\DoxyCodeLine{5038                                          (cchRemaining * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})) + (cbDest \% \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})),}
\DoxyCodeLine{5039                                          pszSrc,}
\DoxyCodeLine{5040                                          \&pszDestEnd,}
\DoxyCodeLine{5041                                          \&cchRemaining,}
\DoxyCodeLine{5042                                          dwFlags \& (\string~(STRSAFE\_FILL\_ON\_FAILURE | STRSAFE\_NULL\_ON\_FAILURE)));}
\DoxyCodeLine{5043             \}}
\DoxyCodeLine{5044         \}}
\DoxyCodeLine{5045     \}}
\DoxyCodeLine{5046 }
\DoxyCodeLine{5047     \textcolor{keywordflow}{if} (FAILED(hr))}
\DoxyCodeLine{5048     \{}
\DoxyCodeLine{5049         \textcolor{keywordflow}{if} (pszDest)}
\DoxyCodeLine{5050         \{}
\DoxyCodeLine{5051             \textcolor{comment}{// STRSAFE\_NO\_TRUNCATION is taken care of by StringCopyExWorkerA()}}
\DoxyCodeLine{5052 }
\DoxyCodeLine{5053             \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_ON\_FAILURE)}
\DoxyCodeLine{5054             \{}
\DoxyCodeLine{5055                 memset(pszDest, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), cbDest);}
\DoxyCodeLine{5056 }
\DoxyCodeLine{5057                 \textcolor{keywordflow}{if} (STRSAFE\_GET\_FILL\_PATTERN(dwFlags) == 0)}
\DoxyCodeLine{5058                 \{}
\DoxyCodeLine{5059                     pszDestEnd = pszDest;}
\DoxyCodeLine{5060                     cchRemaining = cchDest;}
\DoxyCodeLine{5061                 \}}
\DoxyCodeLine{5062                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{5063                 \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{5064                 \{}
\DoxyCodeLine{5065                     pszDestEnd = pszDest + cchDest -\/ 1;}
\DoxyCodeLine{5066                     cchRemaining = 1;}
\DoxyCodeLine{5067 }
\DoxyCodeLine{5068                     \textcolor{comment}{// null terminate the end of the string}}
\DoxyCodeLine{5069                     *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5070                 \}}
\DoxyCodeLine{5071             \}}
\DoxyCodeLine{5072 }
\DoxyCodeLine{5073             \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_NULL\_ON\_FAILURE)}
\DoxyCodeLine{5074             \{}
\DoxyCodeLine{5075                 \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{5076                 \{}
\DoxyCodeLine{5077                     pszDestEnd = pszDest;}
\DoxyCodeLine{5078                     cchRemaining = cchDest;}
\DoxyCodeLine{5079 }
\DoxyCodeLine{5080                     \textcolor{comment}{// null terminate the beginning of the string}}
\DoxyCodeLine{5081                     *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5082                 \}}
\DoxyCodeLine{5083             \}}
\DoxyCodeLine{5084         \}}
\DoxyCodeLine{5085     \}}
\DoxyCodeLine{5086 }
\DoxyCodeLine{5087     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{5088     \{}
\DoxyCodeLine{5089         \textcolor{keywordflow}{if} (ppszDestEnd)}
\DoxyCodeLine{5090         \{}
\DoxyCodeLine{5091             *ppszDestEnd = pszDestEnd;}
\DoxyCodeLine{5092         \}}
\DoxyCodeLine{5093 }
\DoxyCodeLine{5094         \textcolor{keywordflow}{if} (pcchRemaining)}
\DoxyCodeLine{5095         \{}
\DoxyCodeLine{5096             *pcchRemaining = cchRemaining;}
\DoxyCodeLine{5097         \}}
\DoxyCodeLine{5098     \}}
\DoxyCodeLine{5099 }
\DoxyCodeLine{5100     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{5101 \}}
\DoxyCodeLine{5102 }
\DoxyCodeLine{5103 STRSAFEAPI StringCatExWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{5104 \{}
\DoxyCodeLine{5105     HRESULT hr = S\_OK;}
\DoxyCodeLine{5106     \textcolor{keywordtype}{wchar\_t}* pszDestEnd = pszDest;}
\DoxyCodeLine{5107     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{5108 }
\DoxyCodeLine{5109     \textcolor{comment}{// ASSERT(cbDest == (cchDest * sizeof(wchar\_t)) ||}}
\DoxyCodeLine{5110     \textcolor{comment}{//        cbDest == (cchDest * sizeof(wchar\_t)) + (cbDest \% sizeof(wchar\_t)));}}
\DoxyCodeLine{5111 }
\DoxyCodeLine{5112     \textcolor{comment}{// only accept valid flags}}
\DoxyCodeLine{5113     \textcolor{keywordflow}{if} (dwFlags \& (\string~STRSAFE\_VALID\_FLAGS))}
\DoxyCodeLine{5114     \{}
\DoxyCodeLine{5115         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5116     \}}
\DoxyCodeLine{5117     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5118     \{}
\DoxyCodeLine{5119         \textcolor{keywordtype}{size\_t} cchDestCurrent;}
\DoxyCodeLine{5120 }
\DoxyCodeLine{5121         \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_IGNORE\_NULLS)}
\DoxyCodeLine{5122         \{}
\DoxyCodeLine{5123             \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{5124             \{}
\DoxyCodeLine{5125                 \textcolor{keywordflow}{if} ((cchDest == 0) \&\& (cbDest == 0))}
\DoxyCodeLine{5126                 \{}
\DoxyCodeLine{5127                     cchDestCurrent = 0;}
\DoxyCodeLine{5128                 \}}
\DoxyCodeLine{5129                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{5130                 \{}
\DoxyCodeLine{5131                     \textcolor{comment}{// NULL pszDest and non-\/zero cchDest/cbDest is invalid}}
\DoxyCodeLine{5132                     hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5133                 \}}
\DoxyCodeLine{5134             \}}
\DoxyCodeLine{5135             \textcolor{keywordflow}{else}}
\DoxyCodeLine{5136             \{}
\DoxyCodeLine{5137                 hr = StringLengthWorkerW(pszDest, cchDest, \&cchDestCurrent);}
\DoxyCodeLine{5138 }
\DoxyCodeLine{5139                 \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{5140                 \{}
\DoxyCodeLine{5141                     pszDestEnd = pszDest + cchDestCurrent;}
\DoxyCodeLine{5142                     cchRemaining = cchDest -\/ cchDestCurrent;}
\DoxyCodeLine{5143                 \}}
\DoxyCodeLine{5144             \}}
\DoxyCodeLine{5145 }
\DoxyCodeLine{5146             \textcolor{keywordflow}{if} (pszSrc == NULL)}
\DoxyCodeLine{5147             \{}
\DoxyCodeLine{5148                 pszSrc = L\textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{5149             \}}
\DoxyCodeLine{5150         \}}
\DoxyCodeLine{5151         \textcolor{keywordflow}{else}}
\DoxyCodeLine{5152         \{}
\DoxyCodeLine{5153             hr = StringLengthWorkerW(pszDest, cchDest, \&cchDestCurrent);}
\DoxyCodeLine{5154 }
\DoxyCodeLine{5155             \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{5156             \{}
\DoxyCodeLine{5157                 pszDestEnd = pszDest + cchDestCurrent;}
\DoxyCodeLine{5158                 cchRemaining = cchDest -\/ cchDestCurrent;}
\DoxyCodeLine{5159             \}}
\DoxyCodeLine{5160         \}}
\DoxyCodeLine{5161 }
\DoxyCodeLine{5162         \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{5163         \{}
\DoxyCodeLine{5164             \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{5165             \{}
\DoxyCodeLine{5166                 \textcolor{comment}{// only fail if there was actually src data to append}}
\DoxyCodeLine{5167                 \textcolor{keywordflow}{if} (*pszSrc != L\textcolor{charliteral}{'\(\backslash\)0'})}
\DoxyCodeLine{5168                 \{}
\DoxyCodeLine{5169                     \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{5170                     \{}
\DoxyCodeLine{5171                         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5172                     \}}
\DoxyCodeLine{5173                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5174                     \{}
\DoxyCodeLine{5175                         hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{5176                     \}}
\DoxyCodeLine{5177                 \}}
\DoxyCodeLine{5178             \}}
\DoxyCodeLine{5179             \textcolor{keywordflow}{else}}
\DoxyCodeLine{5180             \{}
\DoxyCodeLine{5181                 \textcolor{comment}{// we handle the STRSAFE\_FILL\_ON\_FAILURE and STRSAFE\_NULL\_ON\_FAILURE cases below, so do not pass}}
\DoxyCodeLine{5182                 \textcolor{comment}{// those flags through}}
\DoxyCodeLine{5183                 hr = StringCopyExWorkerW(pszDestEnd,}
\DoxyCodeLine{5184                                          cchRemaining,}
\DoxyCodeLine{5185                                          (cchRemaining * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t})) + (cbDest \% \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t})),}
\DoxyCodeLine{5186                                          pszSrc,}
\DoxyCodeLine{5187                                          \&pszDestEnd,}
\DoxyCodeLine{5188                                          \&cchRemaining,}
\DoxyCodeLine{5189                                          dwFlags \& (\string~(STRSAFE\_FILL\_ON\_FAILURE | STRSAFE\_NULL\_ON\_FAILURE)));}
\DoxyCodeLine{5190             \}}
\DoxyCodeLine{5191         \}}
\DoxyCodeLine{5192     \}}
\DoxyCodeLine{5193 }
\DoxyCodeLine{5194     \textcolor{keywordflow}{if} (FAILED(hr))}
\DoxyCodeLine{5195     \{}
\DoxyCodeLine{5196         \textcolor{keywordflow}{if} (pszDest)}
\DoxyCodeLine{5197         \{}
\DoxyCodeLine{5198             \textcolor{comment}{// STRSAFE\_NO\_TRUNCATION is taken care of by StringCopyExWorkerW()}}
\DoxyCodeLine{5199 }
\DoxyCodeLine{5200             \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_ON\_FAILURE)}
\DoxyCodeLine{5201             \{}
\DoxyCodeLine{5202                 memset(pszDest, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), cbDest);}
\DoxyCodeLine{5203 }
\DoxyCodeLine{5204                 \textcolor{keywordflow}{if} (STRSAFE\_GET\_FILL\_PATTERN(dwFlags) == 0)}
\DoxyCodeLine{5205                 \{}
\DoxyCodeLine{5206                     pszDestEnd = pszDest;}
\DoxyCodeLine{5207                     cchRemaining = cchDest;}
\DoxyCodeLine{5208                 \}}
\DoxyCodeLine{5209                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{5210                 \{}
\DoxyCodeLine{5211                     pszDestEnd = pszDest + cchDest -\/ 1;}
\DoxyCodeLine{5212                     cchRemaining = 1;}
\DoxyCodeLine{5213 }
\DoxyCodeLine{5214                     \textcolor{comment}{// null terminate the end of the string}}
\DoxyCodeLine{5215                     *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5216                 \}}
\DoxyCodeLine{5217             \}}
\DoxyCodeLine{5218 }
\DoxyCodeLine{5219             \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_NULL\_ON\_FAILURE)}
\DoxyCodeLine{5220             \{}
\DoxyCodeLine{5221                 \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{5222                 \{}
\DoxyCodeLine{5223                     pszDestEnd = pszDest;}
\DoxyCodeLine{5224                     cchRemaining = cchDest;}
\DoxyCodeLine{5225 }
\DoxyCodeLine{5226                     \textcolor{comment}{// null terminate the beginning of the string}}
\DoxyCodeLine{5227                     *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5228                 \}}
\DoxyCodeLine{5229             \}}
\DoxyCodeLine{5230         \}}
\DoxyCodeLine{5231     \}}
\DoxyCodeLine{5232 }
\DoxyCodeLine{5233     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{5234     \{}
\DoxyCodeLine{5235         \textcolor{keywordflow}{if} (ppszDestEnd)}
\DoxyCodeLine{5236         \{}
\DoxyCodeLine{5237             *ppszDestEnd = pszDestEnd;}
\DoxyCodeLine{5238         \}}
\DoxyCodeLine{5239 }
\DoxyCodeLine{5240         \textcolor{keywordflow}{if} (pcchRemaining)}
\DoxyCodeLine{5241         \{}
\DoxyCodeLine{5242             *pcchRemaining = cchRemaining;}
\DoxyCodeLine{5243         \}}
\DoxyCodeLine{5244     \}}
\DoxyCodeLine{5245 }
\DoxyCodeLine{5246     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{5247 \}}
\DoxyCodeLine{5248 }
\DoxyCodeLine{5249 STRSAFEAPI StringCatNWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cchMaxAppend)}
\DoxyCodeLine{5250 \{}
\DoxyCodeLine{5251     HRESULT hr;}
\DoxyCodeLine{5252     \textcolor{keywordtype}{size\_t} cchDestCurrent;}
\DoxyCodeLine{5253 }
\DoxyCodeLine{5254     hr = StringLengthWorkerA(pszDest, cchDest, \&cchDestCurrent);}
\DoxyCodeLine{5255 }
\DoxyCodeLine{5256     \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{5257     \{}
\DoxyCodeLine{5258         hr = StringCopyNWorkerA(pszDest + cchDestCurrent,}
\DoxyCodeLine{5259                                 cchDest -\/ cchDestCurrent,}
\DoxyCodeLine{5260                                 pszSrc,}
\DoxyCodeLine{5261                                 cchMaxAppend);}
\DoxyCodeLine{5262     \}}
\DoxyCodeLine{5263 }
\DoxyCodeLine{5264     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{5265 \}}
\DoxyCodeLine{5266 }
\DoxyCodeLine{5267 STRSAFEAPI StringCatNWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cchMaxAppend)}
\DoxyCodeLine{5268 \{}
\DoxyCodeLine{5269     HRESULT hr;}
\DoxyCodeLine{5270     \textcolor{keywordtype}{size\_t} cchDestCurrent;}
\DoxyCodeLine{5271 }
\DoxyCodeLine{5272     hr = StringLengthWorkerW(pszDest, cchDest, \&cchDestCurrent);}
\DoxyCodeLine{5273 }
\DoxyCodeLine{5274     \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{5275     \{}
\DoxyCodeLine{5276         hr = StringCopyNWorkerW(pszDest + cchDestCurrent,}
\DoxyCodeLine{5277                                 cchDest -\/ cchDestCurrent,}
\DoxyCodeLine{5278                                 pszSrc,}
\DoxyCodeLine{5279                                 cchMaxAppend);}
\DoxyCodeLine{5280     \}}
\DoxyCodeLine{5281 }
\DoxyCodeLine{5282     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{5283 \}}
\DoxyCodeLine{5284 }
\DoxyCodeLine{5285 STRSAFEAPI StringCatNExWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszSrc, \textcolor{keywordtype}{size\_t} cchMaxAppend, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{5286 \{}
\DoxyCodeLine{5287     HRESULT hr = S\_OK;}
\DoxyCodeLine{5288     \textcolor{keywordtype}{char}* pszDestEnd = pszDest;}
\DoxyCodeLine{5289     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{5290     \textcolor{keywordtype}{size\_t} cchDestCurrent = 0;}
\DoxyCodeLine{5291 }
\DoxyCodeLine{5292     \textcolor{comment}{// ASSERT(cbDest == (cchDest * sizeof(char))    ||}}
\DoxyCodeLine{5293     \textcolor{comment}{//        cbDest == (cchDest * sizeof(char)) + (cbDest \% sizeof(char)));}}
\DoxyCodeLine{5294 }
\DoxyCodeLine{5295     \textcolor{comment}{// only accept valid flags}}
\DoxyCodeLine{5296     \textcolor{keywordflow}{if} (dwFlags \& (\string~STRSAFE\_VALID\_FLAGS))}
\DoxyCodeLine{5297     \{}
\DoxyCodeLine{5298         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5299     \}}
\DoxyCodeLine{5300     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5301     \{}
\DoxyCodeLine{5302         \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_IGNORE\_NULLS)}
\DoxyCodeLine{5303         \{}
\DoxyCodeLine{5304             \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{5305             \{}
\DoxyCodeLine{5306                 \textcolor{keywordflow}{if} ((cchDest == 0) \&\& (cbDest == 0))}
\DoxyCodeLine{5307                 \{}
\DoxyCodeLine{5308                     cchDestCurrent = 0;}
\DoxyCodeLine{5309                 \}}
\DoxyCodeLine{5310                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{5311                 \{}
\DoxyCodeLine{5312                     \textcolor{comment}{// NULL pszDest and non-\/zero cchDest/cbDest is invalid}}
\DoxyCodeLine{5313                     hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5314                 \}}
\DoxyCodeLine{5315             \}}
\DoxyCodeLine{5316             \textcolor{keywordflow}{else}}
\DoxyCodeLine{5317             \{}
\DoxyCodeLine{5318                 hr = StringLengthWorkerA(pszDest, cchDest, \&cchDestCurrent);}
\DoxyCodeLine{5319 }
\DoxyCodeLine{5320                 \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{5321                 \{}
\DoxyCodeLine{5322                     pszDestEnd = pszDest + cchDestCurrent;}
\DoxyCodeLine{5323                     cchRemaining = cchDest -\/ cchDestCurrent;}
\DoxyCodeLine{5324                 \}}
\DoxyCodeLine{5325             \}}
\DoxyCodeLine{5326 }
\DoxyCodeLine{5327             \textcolor{keywordflow}{if} (pszSrc == NULL)}
\DoxyCodeLine{5328             \{}
\DoxyCodeLine{5329                 pszSrc = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{5330             \}}
\DoxyCodeLine{5331         \}}
\DoxyCodeLine{5332         \textcolor{keywordflow}{else}}
\DoxyCodeLine{5333         \{}
\DoxyCodeLine{5334             hr = StringLengthWorkerA(pszDest, cchDest, \&cchDestCurrent);}
\DoxyCodeLine{5335 }
\DoxyCodeLine{5336             \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{5337             \{}
\DoxyCodeLine{5338                 pszDestEnd = pszDest + cchDestCurrent;}
\DoxyCodeLine{5339                 cchRemaining = cchDest -\/ cchDestCurrent;}
\DoxyCodeLine{5340             \}}
\DoxyCodeLine{5341         \}}
\DoxyCodeLine{5342 }
\DoxyCodeLine{5343         \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{5344         \{}
\DoxyCodeLine{5345             \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{5346             \{}
\DoxyCodeLine{5347                 \textcolor{comment}{// only fail if there was actually src data to append}}
\DoxyCodeLine{5348                 \textcolor{keywordflow}{if} (*pszSrc != \textcolor{charliteral}{'\(\backslash\)0'})}
\DoxyCodeLine{5349                 \{}
\DoxyCodeLine{5350                     \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{5351                     \{}
\DoxyCodeLine{5352                         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5353                     \}}
\DoxyCodeLine{5354                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5355                     \{}
\DoxyCodeLine{5356                         hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{5357                     \}}
\DoxyCodeLine{5358                 \}}
\DoxyCodeLine{5359             \}}
\DoxyCodeLine{5360             \textcolor{keywordflow}{else}}
\DoxyCodeLine{5361             \{}
\DoxyCodeLine{5362                 \textcolor{comment}{// we handle the STRSAFE\_FILL\_ON\_FAILURE and STRSAFE\_NULL\_ON\_FAILURE cases below, so do not pass}}
\DoxyCodeLine{5363                 \textcolor{comment}{// those flags through}}
\DoxyCodeLine{5364                 hr = StringCopyNExWorkerA(pszDestEnd,}
\DoxyCodeLine{5365                                           cchRemaining,}
\DoxyCodeLine{5366                                           (cchRemaining * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})) + (cbDest \% \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})),}
\DoxyCodeLine{5367                                           pszSrc,}
\DoxyCodeLine{5368                                           cchMaxAppend,}
\DoxyCodeLine{5369                                           \&pszDestEnd,}
\DoxyCodeLine{5370                                           \&cchRemaining,}
\DoxyCodeLine{5371                                           dwFlags \& (\string~(STRSAFE\_FILL\_ON\_FAILURE | STRSAFE\_NULL\_ON\_FAILURE)));}
\DoxyCodeLine{5372             \}}
\DoxyCodeLine{5373         \}}
\DoxyCodeLine{5374     \}}
\DoxyCodeLine{5375 }
\DoxyCodeLine{5376     \textcolor{keywordflow}{if} (FAILED(hr))}
\DoxyCodeLine{5377     \{}
\DoxyCodeLine{5378         \textcolor{keywordflow}{if} (pszDest)}
\DoxyCodeLine{5379         \{}
\DoxyCodeLine{5380             \textcolor{comment}{// STRSAFE\_NO\_TRUNCATION is taken care of by StringCopyNExWorkerA()}}
\DoxyCodeLine{5381 }
\DoxyCodeLine{5382             \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_ON\_FAILURE)}
\DoxyCodeLine{5383             \{}
\DoxyCodeLine{5384                 memset(pszDest, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), cbDest);}
\DoxyCodeLine{5385 }
\DoxyCodeLine{5386                 \textcolor{keywordflow}{if} (STRSAFE\_GET\_FILL\_PATTERN(dwFlags) == 0)}
\DoxyCodeLine{5387                 \{}
\DoxyCodeLine{5388                     pszDestEnd = pszDest;}
\DoxyCodeLine{5389                     cchRemaining = cchDest;}
\DoxyCodeLine{5390                 \}}
\DoxyCodeLine{5391                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{5392                 \{}
\DoxyCodeLine{5393                     pszDestEnd = pszDest + cchDest -\/ 1;}
\DoxyCodeLine{5394                     cchRemaining = 1;}
\DoxyCodeLine{5395 }
\DoxyCodeLine{5396                     \textcolor{comment}{// null terminate the end of the string}}
\DoxyCodeLine{5397                     *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5398                 \}}
\DoxyCodeLine{5399             \}}
\DoxyCodeLine{5400 }
\DoxyCodeLine{5401             \textcolor{keywordflow}{if} (dwFlags \& (STRSAFE\_NULL\_ON\_FAILURE))}
\DoxyCodeLine{5402             \{}
\DoxyCodeLine{5403                 \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{5404                 \{}
\DoxyCodeLine{5405                     pszDestEnd = pszDest;}
\DoxyCodeLine{5406                     cchRemaining = cchDest;}
\DoxyCodeLine{5407 }
\DoxyCodeLine{5408                     \textcolor{comment}{// null terminate the beginning of the string}}
\DoxyCodeLine{5409                     *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5410                 \}}
\DoxyCodeLine{5411             \}}
\DoxyCodeLine{5412         \}}
\DoxyCodeLine{5413     \}}
\DoxyCodeLine{5414 }
\DoxyCodeLine{5415     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{5416     \{}
\DoxyCodeLine{5417         \textcolor{keywordflow}{if} (ppszDestEnd)}
\DoxyCodeLine{5418         \{}
\DoxyCodeLine{5419             *ppszDestEnd = pszDestEnd;}
\DoxyCodeLine{5420         \}}
\DoxyCodeLine{5421 }
\DoxyCodeLine{5422         \textcolor{keywordflow}{if} (pcchRemaining)}
\DoxyCodeLine{5423         \{}
\DoxyCodeLine{5424             *pcchRemaining = cchRemaining;}
\DoxyCodeLine{5425         \}}
\DoxyCodeLine{5426     \}}
\DoxyCodeLine{5427 }
\DoxyCodeLine{5428     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{5429 \}}
\DoxyCodeLine{5430 }
\DoxyCodeLine{5431 STRSAFEAPI StringCatNExWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszSrc, \textcolor{keywordtype}{size\_t} cchMaxAppend, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{5432 \{}
\DoxyCodeLine{5433     HRESULT hr = S\_OK;}
\DoxyCodeLine{5434     \textcolor{keywordtype}{wchar\_t}* pszDestEnd = pszDest;}
\DoxyCodeLine{5435     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{5436     \textcolor{keywordtype}{size\_t} cchDestCurrent = 0;}
\DoxyCodeLine{5437 }
\DoxyCodeLine{5438 }
\DoxyCodeLine{5439     \textcolor{comment}{// ASSERT(cbDest == (cchDest * sizeof(wchar\_t)) ||}}
\DoxyCodeLine{5440     \textcolor{comment}{//        cbDest == (cchDest * sizeof(wchar\_t)) + (cbDest \% sizeof(wchar\_t)));}}
\DoxyCodeLine{5441 }
\DoxyCodeLine{5442     \textcolor{comment}{// only accept valid flags}}
\DoxyCodeLine{5443     \textcolor{keywordflow}{if} (dwFlags \& (\string~STRSAFE\_VALID\_FLAGS))}
\DoxyCodeLine{5444     \{}
\DoxyCodeLine{5445         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5446     \}}
\DoxyCodeLine{5447     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5448     \{}
\DoxyCodeLine{5449         \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_IGNORE\_NULLS)}
\DoxyCodeLine{5450         \{}
\DoxyCodeLine{5451             \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{5452             \{}
\DoxyCodeLine{5453                 \textcolor{keywordflow}{if} ((cchDest == 0) \&\& (cbDest == 0))}
\DoxyCodeLine{5454                 \{}
\DoxyCodeLine{5455                     cchDestCurrent = 0;}
\DoxyCodeLine{5456                 \}}
\DoxyCodeLine{5457                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{5458                 \{}
\DoxyCodeLine{5459                     \textcolor{comment}{// NULL pszDest and non-\/zero cchDest/cbDest is invalid}}
\DoxyCodeLine{5460                     hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5461                 \}}
\DoxyCodeLine{5462             \}}
\DoxyCodeLine{5463             \textcolor{keywordflow}{else}}
\DoxyCodeLine{5464             \{}
\DoxyCodeLine{5465                 hr = StringLengthWorkerW(pszDest, cchDest, \&cchDestCurrent);}
\DoxyCodeLine{5466 }
\DoxyCodeLine{5467                 \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{5468                 \{}
\DoxyCodeLine{5469                     pszDestEnd = pszDest + cchDestCurrent;}
\DoxyCodeLine{5470                     cchRemaining = cchDest -\/ cchDestCurrent;}
\DoxyCodeLine{5471                 \}}
\DoxyCodeLine{5472             \}}
\DoxyCodeLine{5473 }
\DoxyCodeLine{5474             \textcolor{keywordflow}{if} (pszSrc == NULL)}
\DoxyCodeLine{5475             \{}
\DoxyCodeLine{5476                 pszSrc = L\textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{5477             \}}
\DoxyCodeLine{5478         \}}
\DoxyCodeLine{5479         \textcolor{keywordflow}{else}}
\DoxyCodeLine{5480         \{}
\DoxyCodeLine{5481             hr = StringLengthWorkerW(pszDest, cchDest, \&cchDestCurrent);}
\DoxyCodeLine{5482 }
\DoxyCodeLine{5483             \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{5484             \{}
\DoxyCodeLine{5485                 pszDestEnd = pszDest + cchDestCurrent;}
\DoxyCodeLine{5486                 cchRemaining = cchDest -\/ cchDestCurrent;}
\DoxyCodeLine{5487             \}}
\DoxyCodeLine{5488         \}}
\DoxyCodeLine{5489 }
\DoxyCodeLine{5490         \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{5491         \{}
\DoxyCodeLine{5492             \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{5493             \{}
\DoxyCodeLine{5494                 \textcolor{comment}{// only fail if there was actually src data to append}}
\DoxyCodeLine{5495                 \textcolor{keywordflow}{if} (*pszSrc != L\textcolor{charliteral}{'\(\backslash\)0'})}
\DoxyCodeLine{5496                 \{}
\DoxyCodeLine{5497                     \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{5498                     \{}
\DoxyCodeLine{5499                         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5500                     \}}
\DoxyCodeLine{5501                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5502                     \{}
\DoxyCodeLine{5503                         hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{5504                     \}}
\DoxyCodeLine{5505                 \}}
\DoxyCodeLine{5506             \}}
\DoxyCodeLine{5507             \textcolor{keywordflow}{else}}
\DoxyCodeLine{5508             \{}
\DoxyCodeLine{5509                 \textcolor{comment}{// we handle the STRSAFE\_FILL\_ON\_FAILURE and STRSAFE\_NULL\_ON\_FAILURE cases below, so do not pass}}
\DoxyCodeLine{5510                 \textcolor{comment}{// those flags through}}
\DoxyCodeLine{5511                 hr = StringCopyNExWorkerW(pszDestEnd,}
\DoxyCodeLine{5512                                           cchRemaining,}
\DoxyCodeLine{5513                                           (cchRemaining * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t})) + (cbDest \% \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t})),}
\DoxyCodeLine{5514                                           pszSrc,}
\DoxyCodeLine{5515                                           cchMaxAppend,}
\DoxyCodeLine{5516                                           \&pszDestEnd,}
\DoxyCodeLine{5517                                           \&cchRemaining,}
\DoxyCodeLine{5518                                           dwFlags \& (\string~(STRSAFE\_FILL\_ON\_FAILURE | STRSAFE\_NULL\_ON\_FAILURE)));}
\DoxyCodeLine{5519             \}}
\DoxyCodeLine{5520         \}}
\DoxyCodeLine{5521     \}}
\DoxyCodeLine{5522 }
\DoxyCodeLine{5523     \textcolor{keywordflow}{if} (FAILED(hr))}
\DoxyCodeLine{5524     \{}
\DoxyCodeLine{5525         \textcolor{keywordflow}{if} (pszDest)}
\DoxyCodeLine{5526         \{}
\DoxyCodeLine{5527             \textcolor{comment}{// STRSAFE\_NO\_TRUNCATION is taken care of by StringCopyNExWorkerW()}}
\DoxyCodeLine{5528 }
\DoxyCodeLine{5529             \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_ON\_FAILURE)}
\DoxyCodeLine{5530             \{}
\DoxyCodeLine{5531                 memset(pszDest, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), cbDest);}
\DoxyCodeLine{5532 }
\DoxyCodeLine{5533                 \textcolor{keywordflow}{if} (STRSAFE\_GET\_FILL\_PATTERN(dwFlags) == 0)}
\DoxyCodeLine{5534                 \{}
\DoxyCodeLine{5535                     pszDestEnd = pszDest;}
\DoxyCodeLine{5536                     cchRemaining = cchDest;}
\DoxyCodeLine{5537                 \}}
\DoxyCodeLine{5538                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{5539                 \{}
\DoxyCodeLine{5540                     pszDestEnd = pszDest + cchDest -\/ 1;}
\DoxyCodeLine{5541                     cchRemaining = 1;}
\DoxyCodeLine{5542 }
\DoxyCodeLine{5543                     \textcolor{comment}{// null terminate the end of the string}}
\DoxyCodeLine{5544                     *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5545                 \}}
\DoxyCodeLine{5546             \}}
\DoxyCodeLine{5547 }
\DoxyCodeLine{5548             \textcolor{keywordflow}{if} (dwFlags \& (STRSAFE\_NULL\_ON\_FAILURE))}
\DoxyCodeLine{5549             \{}
\DoxyCodeLine{5550                 \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{5551                 \{}
\DoxyCodeLine{5552                     pszDestEnd = pszDest;}
\DoxyCodeLine{5553                     cchRemaining = cchDest;}
\DoxyCodeLine{5554 }
\DoxyCodeLine{5555                     \textcolor{comment}{// null terminate the beginning of the string}}
\DoxyCodeLine{5556                     *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5557                 \}}
\DoxyCodeLine{5558             \}}
\DoxyCodeLine{5559         \}}
\DoxyCodeLine{5560     \}}
\DoxyCodeLine{5561 }
\DoxyCodeLine{5562     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{5563     \{}
\DoxyCodeLine{5564         \textcolor{keywordflow}{if} (ppszDestEnd)}
\DoxyCodeLine{5565         \{}
\DoxyCodeLine{5566             *ppszDestEnd = pszDestEnd;}
\DoxyCodeLine{5567         \}}
\DoxyCodeLine{5568 }
\DoxyCodeLine{5569         \textcolor{keywordflow}{if} (pcchRemaining)}
\DoxyCodeLine{5570         \{}
\DoxyCodeLine{5571             *pcchRemaining = cchRemaining;}
\DoxyCodeLine{5572         \}}
\DoxyCodeLine{5573     \}}
\DoxyCodeLine{5574 }
\DoxyCodeLine{5575     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{5576 \}}
\DoxyCodeLine{5577 }
\DoxyCodeLine{5578 STRSAFEAPI StringVPrintfWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, va\_list argList)}
\DoxyCodeLine{5579 \{}
\DoxyCodeLine{5580     HRESULT hr = S\_OK;}
\DoxyCodeLine{5581 }
\DoxyCodeLine{5582     \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{5583     \{}
\DoxyCodeLine{5584         \textcolor{comment}{// can not null terminate a zero-\/byte dest buffer}}
\DoxyCodeLine{5585         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5586     \}}
\DoxyCodeLine{5587     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5588     \{}
\DoxyCodeLine{5589         \textcolor{keywordtype}{int} iRet;}
\DoxyCodeLine{5590         \textcolor{keywordtype}{size\_t} cchMax;}
\DoxyCodeLine{5591 }
\DoxyCodeLine{5592         \textcolor{comment}{// leave the last space for the null terminator}}
\DoxyCodeLine{5593         cchMax = cchDest -\/ 1;}
\DoxyCodeLine{5594 }
\DoxyCodeLine{5595         iRet = \_vsnprintf(pszDest, cchMax, pszFormat, argList);}
\DoxyCodeLine{5596         \textcolor{comment}{// ASSERT((iRet < 0) || (((size\_t)iRet) <= cchMax));}}
\DoxyCodeLine{5597 }
\DoxyCodeLine{5598         \textcolor{keywordflow}{if} ((iRet < 0) || (((\textcolor{keywordtype}{size\_t})iRet) > cchMax))}
\DoxyCodeLine{5599         \{}
\DoxyCodeLine{5600             \textcolor{comment}{// need to null terminate the string}}
\DoxyCodeLine{5601             pszDest += cchMax;}
\DoxyCodeLine{5602             *pszDest = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5603 }
\DoxyCodeLine{5604             \textcolor{comment}{// we have truncated pszDest}}
\DoxyCodeLine{5605             hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{5606         \}}
\DoxyCodeLine{5607         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (((\textcolor{keywordtype}{size\_t})iRet) == cchMax)}
\DoxyCodeLine{5608         \{}
\DoxyCodeLine{5609             \textcolor{comment}{// need to null terminate the string}}
\DoxyCodeLine{5610             pszDest += cchMax;}
\DoxyCodeLine{5611             *pszDest = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5612         \}}
\DoxyCodeLine{5613     \}}
\DoxyCodeLine{5614 }
\DoxyCodeLine{5615     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{5616 \}}
\DoxyCodeLine{5617 }
\DoxyCodeLine{5618 STRSAFEAPI StringVPrintfWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, va\_list argList)}
\DoxyCodeLine{5619 \{}
\DoxyCodeLine{5620     HRESULT hr = S\_OK;}
\DoxyCodeLine{5621 }
\DoxyCodeLine{5622     \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{5623     \{}
\DoxyCodeLine{5624         \textcolor{comment}{// can not null terminate a zero-\/byte dest buffer}}
\DoxyCodeLine{5625         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5626     \}}
\DoxyCodeLine{5627     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5628     \{}
\DoxyCodeLine{5629         \textcolor{keywordtype}{int} iRet;}
\DoxyCodeLine{5630         \textcolor{keywordtype}{size\_t} cchMax;}
\DoxyCodeLine{5631 }
\DoxyCodeLine{5632         \textcolor{comment}{// leave the last space for the null terminator}}
\DoxyCodeLine{5633         cchMax = cchDest -\/ 1;}
\DoxyCodeLine{5634 }
\DoxyCodeLine{5635         iRet = \_vsnwprintf(pszDest, cchMax, pszFormat, argList);}
\DoxyCodeLine{5636         \textcolor{comment}{// ASSERT((iRet < 0) || (((size\_t)iRet) <= cchMax));}}
\DoxyCodeLine{5637 }
\DoxyCodeLine{5638         \textcolor{keywordflow}{if} ((iRet < 0) || (((\textcolor{keywordtype}{size\_t})iRet) > cchMax))}
\DoxyCodeLine{5639         \{}
\DoxyCodeLine{5640             \textcolor{comment}{// need to null terminate the string}}
\DoxyCodeLine{5641             pszDest += cchMax;}
\DoxyCodeLine{5642             *pszDest = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5643 }
\DoxyCodeLine{5644             \textcolor{comment}{// we have truncated pszDest}}
\DoxyCodeLine{5645             hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{5646         \}}
\DoxyCodeLine{5647         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (((\textcolor{keywordtype}{size\_t})iRet) == cchMax)}
\DoxyCodeLine{5648         \{}
\DoxyCodeLine{5649             \textcolor{comment}{// need to null terminate the string}}
\DoxyCodeLine{5650             pszDest += cchMax;}
\DoxyCodeLine{5651             *pszDest = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5652         \}}
\DoxyCodeLine{5653     \}}
\DoxyCodeLine{5654 }
\DoxyCodeLine{5655     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{5656 \}}
\DoxyCodeLine{5657 }
\DoxyCodeLine{5658 STRSAFEAPI StringVPrintfExWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pszFormat, va\_list argList)}
\DoxyCodeLine{5659 \{}
\DoxyCodeLine{5660     HRESULT hr = S\_OK;}
\DoxyCodeLine{5661     \textcolor{keywordtype}{char}* pszDestEnd = pszDest;}
\DoxyCodeLine{5662     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{5663 }
\DoxyCodeLine{5664     \textcolor{comment}{// ASSERT(cbDest == (cchDest * sizeof(char))    ||}}
\DoxyCodeLine{5665     \textcolor{comment}{//        cbDest == (cchDest * sizeof(char)) + (cbDest \% sizeof(char)));}}
\DoxyCodeLine{5666 }
\DoxyCodeLine{5667     \textcolor{comment}{// only accept valid flags}}
\DoxyCodeLine{5668     \textcolor{keywordflow}{if} (dwFlags \& (\string~STRSAFE\_VALID\_FLAGS))}
\DoxyCodeLine{5669     \{}
\DoxyCodeLine{5670         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5671     \}}
\DoxyCodeLine{5672     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5673     \{}
\DoxyCodeLine{5674         \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_IGNORE\_NULLS)}
\DoxyCodeLine{5675         \{}
\DoxyCodeLine{5676             \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{5677             \{}
\DoxyCodeLine{5678                 \textcolor{keywordflow}{if} ((cchDest != 0) || (cbDest != 0))}
\DoxyCodeLine{5679                 \{}
\DoxyCodeLine{5680                     \textcolor{comment}{// NULL pszDest and non-\/zero cchDest/cbDest is invalid}}
\DoxyCodeLine{5681                     hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5682                 \}}
\DoxyCodeLine{5683             \}}
\DoxyCodeLine{5684 }
\DoxyCodeLine{5685             \textcolor{keywordflow}{if} (pszFormat == NULL)}
\DoxyCodeLine{5686             \{}
\DoxyCodeLine{5687                 pszFormat = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{5688             \}}
\DoxyCodeLine{5689         \}}
\DoxyCodeLine{5690 }
\DoxyCodeLine{5691         \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{5692         \{}
\DoxyCodeLine{5693             \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{5694             \{}
\DoxyCodeLine{5695                 pszDestEnd = pszDest;}
\DoxyCodeLine{5696                 cchRemaining = 0;}
\DoxyCodeLine{5697 }
\DoxyCodeLine{5698                 \textcolor{comment}{// only fail if there was actually a non-\/empty format string}}
\DoxyCodeLine{5699                 \textcolor{keywordflow}{if} (*pszFormat != \textcolor{charliteral}{'\(\backslash\)0'})}
\DoxyCodeLine{5700                 \{}
\DoxyCodeLine{5701                     \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{5702                     \{}
\DoxyCodeLine{5703                         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5704                     \}}
\DoxyCodeLine{5705                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5706                     \{}
\DoxyCodeLine{5707                         hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{5708                     \}}
\DoxyCodeLine{5709                 \}}
\DoxyCodeLine{5710             \}}
\DoxyCodeLine{5711             \textcolor{keywordflow}{else}}
\DoxyCodeLine{5712             \{}
\DoxyCodeLine{5713                 \textcolor{keywordtype}{int} iRet;}
\DoxyCodeLine{5714                 \textcolor{keywordtype}{size\_t} cchMax;}
\DoxyCodeLine{5715 }
\DoxyCodeLine{5716                 \textcolor{comment}{// leave the last space for the null terminator}}
\DoxyCodeLine{5717                 cchMax = cchDest -\/ 1;}
\DoxyCodeLine{5718 }
\DoxyCodeLine{5719                 iRet = \_vsnprintf(pszDest, cchMax, pszFormat, argList);}
\DoxyCodeLine{5720                 \textcolor{comment}{// ASSERT((iRet < 0) || (((size\_t)iRet) <= cchMax));}}
\DoxyCodeLine{5721 }
\DoxyCodeLine{5722                 \textcolor{keywordflow}{if} ((iRet < 0) || (((\textcolor{keywordtype}{size\_t})iRet) > cchMax))}
\DoxyCodeLine{5723                 \{}
\DoxyCodeLine{5724                     \textcolor{comment}{// we have truncated pszDest}}
\DoxyCodeLine{5725                     pszDestEnd = pszDest + cchMax;}
\DoxyCodeLine{5726                     cchRemaining = 1;}
\DoxyCodeLine{5727 }
\DoxyCodeLine{5728                     \textcolor{comment}{// need to null terminate the string}}
\DoxyCodeLine{5729                     *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5730 }
\DoxyCodeLine{5731                     hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{5732                 \}}
\DoxyCodeLine{5733                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (((\textcolor{keywordtype}{size\_t})iRet) == cchMax)}
\DoxyCodeLine{5734                 \{}
\DoxyCodeLine{5735                     \textcolor{comment}{// string fit perfectly}}
\DoxyCodeLine{5736                     pszDestEnd = pszDest + cchMax;}
\DoxyCodeLine{5737                     cchRemaining = 1;}
\DoxyCodeLine{5738 }
\DoxyCodeLine{5739                     \textcolor{comment}{// need to null terminate the string}}
\DoxyCodeLine{5740                     *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5741                 \}}
\DoxyCodeLine{5742                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (((\textcolor{keywordtype}{size\_t})iRet) < cchMax)}
\DoxyCodeLine{5743                 \{}
\DoxyCodeLine{5744                     \textcolor{comment}{// there is extra room}}
\DoxyCodeLine{5745                     pszDestEnd = pszDest + iRet;}
\DoxyCodeLine{5746                     cchRemaining = cchDest -\/ iRet;}
\DoxyCodeLine{5747 }
\DoxyCodeLine{5748                     \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_BEHIND\_NULL)}
\DoxyCodeLine{5749                     \{}
\DoxyCodeLine{5750                         memset(pszDestEnd + 1, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), ((cchRemaining -\/ 1) * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})) + (cbDest \% \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})));}
\DoxyCodeLine{5751                     \}}
\DoxyCodeLine{5752                 \}}
\DoxyCodeLine{5753             \}}
\DoxyCodeLine{5754         \}}
\DoxyCodeLine{5755     \}}
\DoxyCodeLine{5756 }
\DoxyCodeLine{5757     \textcolor{keywordflow}{if} (FAILED(hr))}
\DoxyCodeLine{5758     \{}
\DoxyCodeLine{5759         \textcolor{keywordflow}{if} (pszDest)}
\DoxyCodeLine{5760         \{}
\DoxyCodeLine{5761             \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_ON\_FAILURE)}
\DoxyCodeLine{5762             \{}
\DoxyCodeLine{5763                 memset(pszDest, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), cbDest);}
\DoxyCodeLine{5764 }
\DoxyCodeLine{5765                 \textcolor{keywordflow}{if} (STRSAFE\_GET\_FILL\_PATTERN(dwFlags) == 0)}
\DoxyCodeLine{5766                 \{}
\DoxyCodeLine{5767                     pszDestEnd = pszDest;}
\DoxyCodeLine{5768                     cchRemaining = cchDest;}
\DoxyCodeLine{5769                 \}}
\DoxyCodeLine{5770                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{5771                 \{}
\DoxyCodeLine{5772                     pszDestEnd = pszDest + cchDest -\/ 1;}
\DoxyCodeLine{5773                     cchRemaining = 1;}
\DoxyCodeLine{5774 }
\DoxyCodeLine{5775                     \textcolor{comment}{// null terminate the end of the string}}
\DoxyCodeLine{5776                     *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5777                 \}}
\DoxyCodeLine{5778             \}}
\DoxyCodeLine{5779 }
\DoxyCodeLine{5780             \textcolor{keywordflow}{if} (dwFlags \& (STRSAFE\_NULL\_ON\_FAILURE | STRSAFE\_NO\_TRUNCATION))}
\DoxyCodeLine{5781             \{}
\DoxyCodeLine{5782                 \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{5783                 \{}
\DoxyCodeLine{5784                     pszDestEnd = pszDest;}
\DoxyCodeLine{5785                     cchRemaining = cchDest;}
\DoxyCodeLine{5786 }
\DoxyCodeLine{5787                     \textcolor{comment}{// null terminate the beginning of the string}}
\DoxyCodeLine{5788                     *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5789                 \}}
\DoxyCodeLine{5790             \}}
\DoxyCodeLine{5791         \}}
\DoxyCodeLine{5792     \}}
\DoxyCodeLine{5793 }
\DoxyCodeLine{5794     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{5795     \{}
\DoxyCodeLine{5796         \textcolor{keywordflow}{if} (ppszDestEnd)}
\DoxyCodeLine{5797         \{}
\DoxyCodeLine{5798             *ppszDestEnd = pszDestEnd;}
\DoxyCodeLine{5799         \}}
\DoxyCodeLine{5800 }
\DoxyCodeLine{5801         \textcolor{keywordflow}{if} (pcchRemaining)}
\DoxyCodeLine{5802         \{}
\DoxyCodeLine{5803             *pcchRemaining = cchRemaining;}
\DoxyCodeLine{5804         \}}
\DoxyCodeLine{5805     \}}
\DoxyCodeLine{5806 }
\DoxyCodeLine{5807     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{5808 \}}
\DoxyCodeLine{5809 }
\DoxyCodeLine{5810 STRSAFEAPI StringVPrintfExWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pszFormat, va\_list argList)}
\DoxyCodeLine{5811 \{}
\DoxyCodeLine{5812     HRESULT hr = S\_OK;}
\DoxyCodeLine{5813     \textcolor{keywordtype}{wchar\_t}* pszDestEnd = pszDest;}
\DoxyCodeLine{5814     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{5815 }
\DoxyCodeLine{5816     \textcolor{comment}{// ASSERT(cbDest == (cchDest * sizeof(wchar\_t)) ||}}
\DoxyCodeLine{5817     \textcolor{comment}{//        cbDest == (cchDest * sizeof(wchar\_t)) + (cbDest \% sizeof(wchar\_t)));}}
\DoxyCodeLine{5818 }
\DoxyCodeLine{5819     \textcolor{comment}{// only accept valid flags}}
\DoxyCodeLine{5820     \textcolor{keywordflow}{if} (dwFlags \& (\string~STRSAFE\_VALID\_FLAGS))}
\DoxyCodeLine{5821     \{}
\DoxyCodeLine{5822         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5823     \}}
\DoxyCodeLine{5824     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5825     \{}
\DoxyCodeLine{5826         \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_IGNORE\_NULLS)}
\DoxyCodeLine{5827         \{}
\DoxyCodeLine{5828             \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{5829             \{}
\DoxyCodeLine{5830                 \textcolor{keywordflow}{if} ((cchDest != 0) || (cbDest != 0))}
\DoxyCodeLine{5831                 \{}
\DoxyCodeLine{5832                     \textcolor{comment}{// NULL pszDest and non-\/zero cchDest/cbDest is invalid}}
\DoxyCodeLine{5833                     hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5834                 \}}
\DoxyCodeLine{5835             \}}
\DoxyCodeLine{5836 }
\DoxyCodeLine{5837             \textcolor{keywordflow}{if} (pszFormat == NULL)}
\DoxyCodeLine{5838             \{}
\DoxyCodeLine{5839                 pszFormat = L\textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{5840             \}}
\DoxyCodeLine{5841         \}}
\DoxyCodeLine{5842 }
\DoxyCodeLine{5843         \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{5844         \{}
\DoxyCodeLine{5845             \textcolor{keywordflow}{if} (cchDest == 0)}
\DoxyCodeLine{5846             \{}
\DoxyCodeLine{5847                 pszDestEnd = pszDest;}
\DoxyCodeLine{5848                 cchRemaining = 0;}
\DoxyCodeLine{5849 }
\DoxyCodeLine{5850                 \textcolor{comment}{// only fail if there was actually a non-\/empty format string}}
\DoxyCodeLine{5851                 \textcolor{keywordflow}{if} (*pszFormat != L\textcolor{charliteral}{'\(\backslash\)0'})}
\DoxyCodeLine{5852                 \{}
\DoxyCodeLine{5853                     \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{5854                     \{}
\DoxyCodeLine{5855                         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5856                     \}}
\DoxyCodeLine{5857                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{5858                     \{}
\DoxyCodeLine{5859                         hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{5860                     \}}
\DoxyCodeLine{5861                 \}}
\DoxyCodeLine{5862             \}}
\DoxyCodeLine{5863             \textcolor{keywordflow}{else}}
\DoxyCodeLine{5864             \{}
\DoxyCodeLine{5865                 \textcolor{keywordtype}{int} iRet;}
\DoxyCodeLine{5866                 \textcolor{keywordtype}{size\_t} cchMax;}
\DoxyCodeLine{5867 }
\DoxyCodeLine{5868                 \textcolor{comment}{// leave the last space for the null terminator}}
\DoxyCodeLine{5869                 cchMax = cchDest -\/ 1;}
\DoxyCodeLine{5870 }
\DoxyCodeLine{5871                 iRet = \_vsnwprintf(pszDest, cchMax, pszFormat, argList);}
\DoxyCodeLine{5872                 \textcolor{comment}{// ASSERT((iRet < 0) || (((size\_t)iRet) <= cchMax));}}
\DoxyCodeLine{5873 }
\DoxyCodeLine{5874                 \textcolor{keywordflow}{if} ((iRet < 0) || (((\textcolor{keywordtype}{size\_t})iRet) > cchMax))}
\DoxyCodeLine{5875                 \{}
\DoxyCodeLine{5876                     \textcolor{comment}{// we have truncated pszDest}}
\DoxyCodeLine{5877                     pszDestEnd = pszDest + cchMax;}
\DoxyCodeLine{5878                     cchRemaining = 1;}
\DoxyCodeLine{5879 }
\DoxyCodeLine{5880                     \textcolor{comment}{// need to null terminate the string}}
\DoxyCodeLine{5881                     *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5882 }
\DoxyCodeLine{5883                     hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{5884                 \}}
\DoxyCodeLine{5885                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (((\textcolor{keywordtype}{size\_t})iRet) == cchMax)}
\DoxyCodeLine{5886                 \{}
\DoxyCodeLine{5887                     \textcolor{comment}{// string fit perfectly}}
\DoxyCodeLine{5888                     pszDestEnd = pszDest + cchMax;}
\DoxyCodeLine{5889                     cchRemaining = 1;}
\DoxyCodeLine{5890 }
\DoxyCodeLine{5891                     \textcolor{comment}{// need to null terminate the string}}
\DoxyCodeLine{5892                     *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5893                 \}}
\DoxyCodeLine{5894                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (((\textcolor{keywordtype}{size\_t})iRet) < cchMax)}
\DoxyCodeLine{5895                 \{}
\DoxyCodeLine{5896                     \textcolor{comment}{// there is extra room}}
\DoxyCodeLine{5897                     pszDestEnd = pszDest + iRet;}
\DoxyCodeLine{5898                     cchRemaining = cchDest -\/ iRet;}
\DoxyCodeLine{5899 }
\DoxyCodeLine{5900                     \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_BEHIND\_NULL)}
\DoxyCodeLine{5901                     \{}
\DoxyCodeLine{5902                         memset(pszDestEnd + 1, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), ((cchRemaining -\/ 1) * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t})) + (cbDest \% \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t})));}
\DoxyCodeLine{5903                     \}}
\DoxyCodeLine{5904                 \}}
\DoxyCodeLine{5905             \}}
\DoxyCodeLine{5906         \}}
\DoxyCodeLine{5907     \}}
\DoxyCodeLine{5908 }
\DoxyCodeLine{5909     \textcolor{keywordflow}{if} (FAILED(hr))}
\DoxyCodeLine{5910     \{}
\DoxyCodeLine{5911         \textcolor{keywordflow}{if} (pszDest)}
\DoxyCodeLine{5912         \{}
\DoxyCodeLine{5913             \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_ON\_FAILURE)}
\DoxyCodeLine{5914             \{}
\DoxyCodeLine{5915                 memset(pszDest, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), cbDest);}
\DoxyCodeLine{5916 }
\DoxyCodeLine{5917                 \textcolor{keywordflow}{if} (STRSAFE\_GET\_FILL\_PATTERN(dwFlags) == 0)}
\DoxyCodeLine{5918                 \{}
\DoxyCodeLine{5919                     pszDestEnd = pszDest;}
\DoxyCodeLine{5920                     cchRemaining = cchDest;}
\DoxyCodeLine{5921                 \}}
\DoxyCodeLine{5922                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{5923                 \{}
\DoxyCodeLine{5924                     pszDestEnd = pszDest + cchDest -\/ 1;}
\DoxyCodeLine{5925                     cchRemaining = 1;}
\DoxyCodeLine{5926 }
\DoxyCodeLine{5927                     \textcolor{comment}{// null terminate the end of the string}}
\DoxyCodeLine{5928                     *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5929                 \}}
\DoxyCodeLine{5930             \}}
\DoxyCodeLine{5931 }
\DoxyCodeLine{5932             \textcolor{keywordflow}{if} (dwFlags \& (STRSAFE\_NULL\_ON\_FAILURE | STRSAFE\_NO\_TRUNCATION))}
\DoxyCodeLine{5933             \{}
\DoxyCodeLine{5934                 \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{5935                 \{}
\DoxyCodeLine{5936                     pszDestEnd = pszDest;}
\DoxyCodeLine{5937                     cchRemaining = cchDest;}
\DoxyCodeLine{5938 }
\DoxyCodeLine{5939                     \textcolor{comment}{// null terminate the beginning of the string}}
\DoxyCodeLine{5940                     *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{5941                 \}}
\DoxyCodeLine{5942             \}}
\DoxyCodeLine{5943         \}}
\DoxyCodeLine{5944     \}}
\DoxyCodeLine{5945 }
\DoxyCodeLine{5946     \textcolor{keywordflow}{if} (SUCCEEDED(hr) || (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER))}
\DoxyCodeLine{5947     \{}
\DoxyCodeLine{5948         \textcolor{keywordflow}{if} (ppszDestEnd)}
\DoxyCodeLine{5949         \{}
\DoxyCodeLine{5950             *ppszDestEnd = pszDestEnd;}
\DoxyCodeLine{5951         \}}
\DoxyCodeLine{5952 }
\DoxyCodeLine{5953         \textcolor{keywordflow}{if} (pcchRemaining)}
\DoxyCodeLine{5954         \{}
\DoxyCodeLine{5955             *pcchRemaining = cchRemaining;}
\DoxyCodeLine{5956         \}}
\DoxyCodeLine{5957     \}}
\DoxyCodeLine{5958 }
\DoxyCodeLine{5959     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{5960 \}}
\DoxyCodeLine{5961 }
\DoxyCodeLine{5962 STRSAFEAPI StringLengthWorkerA(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* psz, \textcolor{keywordtype}{size\_t} cchMax, \textcolor{keywordtype}{size\_t}* pcch)}
\DoxyCodeLine{5963 \{}
\DoxyCodeLine{5964     HRESULT hr = S\_OK;}
\DoxyCodeLine{5965     \textcolor{keywordtype}{size\_t} cchMaxPrev = cchMax;}
\DoxyCodeLine{5966 }
\DoxyCodeLine{5967     \textcolor{keywordflow}{while} (cchMax \&\& (*psz != \textcolor{charliteral}{'\(\backslash\)0'}))}
\DoxyCodeLine{5968     \{}
\DoxyCodeLine{5969         psz++;}
\DoxyCodeLine{5970         cchMax-\/-\/;}
\DoxyCodeLine{5971     \}}
\DoxyCodeLine{5972 }
\DoxyCodeLine{5973     \textcolor{keywordflow}{if} (cchMax == 0)}
\DoxyCodeLine{5974     \{}
\DoxyCodeLine{5975         \textcolor{comment}{// the string is longer than cchMax}}
\DoxyCodeLine{5976         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{5977     \}}
\DoxyCodeLine{5978 }
\DoxyCodeLine{5979     \textcolor{keywordflow}{if} (SUCCEEDED(hr) \&\& pcch)}
\DoxyCodeLine{5980     \{}
\DoxyCodeLine{5981         *pcch = cchMaxPrev -\/ cchMax;}
\DoxyCodeLine{5982     \}}
\DoxyCodeLine{5983 }
\DoxyCodeLine{5984     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{5985 \}}
\DoxyCodeLine{5986 }
\DoxyCodeLine{5987 STRSAFEAPI StringLengthWorkerW(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* psz, \textcolor{keywordtype}{size\_t} cchMax, \textcolor{keywordtype}{size\_t}* pcch)}
\DoxyCodeLine{5988 \{}
\DoxyCodeLine{5989     HRESULT hr = S\_OK;}
\DoxyCodeLine{5990     \textcolor{keywordtype}{size\_t} cchMaxPrev = cchMax;}
\DoxyCodeLine{5991 }
\DoxyCodeLine{5992     \textcolor{keywordflow}{while} (cchMax \&\& (*psz != L\textcolor{charliteral}{'\(\backslash\)0'}))}
\DoxyCodeLine{5993     \{}
\DoxyCodeLine{5994         psz++;}
\DoxyCodeLine{5995         cchMax-\/-\/;}
\DoxyCodeLine{5996     \}}
\DoxyCodeLine{5997 }
\DoxyCodeLine{5998     \textcolor{keywordflow}{if} (cchMax == 0)}
\DoxyCodeLine{5999     \{}
\DoxyCodeLine{6000         \textcolor{comment}{// the string is longer than cchMax}}
\DoxyCodeLine{6001         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{6002     \}}
\DoxyCodeLine{6003 }
\DoxyCodeLine{6004     \textcolor{keywordflow}{if} (SUCCEEDED(hr) \&\& pcch)}
\DoxyCodeLine{6005     \{}
\DoxyCodeLine{6006         *pcch = cchMaxPrev -\/ cchMax;}
\DoxyCodeLine{6007     \}}
\DoxyCodeLine{6008 }
\DoxyCodeLine{6009     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{6010 \}}
\DoxyCodeLine{6011 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// STRSAFE\_INLINE}}
\DoxyCodeLine{6012 }
\DoxyCodeLine{6013 \textcolor{preprocessor}{\#ifndef STRSAFE\_LIB\_IMPL}}
\DoxyCodeLine{6014 STRSAFE\_INLINE\_API StringGetsExWorkerA(\textcolor{keywordtype}{char}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{char}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{6015 \{}
\DoxyCodeLine{6016     HRESULT hr = S\_OK;}
\DoxyCodeLine{6017     \textcolor{keywordtype}{char}* pszDestEnd = pszDest;}
\DoxyCodeLine{6018     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{6019 }
\DoxyCodeLine{6020     \textcolor{comment}{// ASSERT(cbDest == (cchDest * sizeof(char))    ||}}
\DoxyCodeLine{6021     \textcolor{comment}{//        cbDest == (cchDest * sizeof(char)) + (cbDest \% sizeof(char)));}}
\DoxyCodeLine{6022 }
\DoxyCodeLine{6023     \textcolor{comment}{// only accept valid flags}}
\DoxyCodeLine{6024     \textcolor{keywordflow}{if} (dwFlags \& (\string~STRSAFE\_VALID\_FLAGS))}
\DoxyCodeLine{6025     \{}
\DoxyCodeLine{6026         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{6027     \}}
\DoxyCodeLine{6028     \textcolor{keywordflow}{else}}
\DoxyCodeLine{6029     \{}
\DoxyCodeLine{6030         \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_IGNORE\_NULLS)}
\DoxyCodeLine{6031         \{}
\DoxyCodeLine{6032             \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{6033             \{}
\DoxyCodeLine{6034                 \textcolor{keywordflow}{if} ((cchDest != 0) || (cbDest != 0))}
\DoxyCodeLine{6035                 \{}
\DoxyCodeLine{6036                     \textcolor{comment}{// NULL pszDest and non-\/zero cchDest/cbDest is invalid}}
\DoxyCodeLine{6037                     hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{6038                 \}}
\DoxyCodeLine{6039             \}}
\DoxyCodeLine{6040         \}}
\DoxyCodeLine{6041 }
\DoxyCodeLine{6042         \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{6043         \{}
\DoxyCodeLine{6044             \textcolor{keywordflow}{if} (cchDest <= 1)}
\DoxyCodeLine{6045             \{}
\DoxyCodeLine{6046                 pszDestEnd = pszDest;}
\DoxyCodeLine{6047                 cchRemaining = cchDest;}
\DoxyCodeLine{6048 }
\DoxyCodeLine{6049                 \textcolor{keywordflow}{if} (cchDest == 1)}
\DoxyCodeLine{6050                 \{}
\DoxyCodeLine{6051                     *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{6052                 \}}
\DoxyCodeLine{6053 }
\DoxyCodeLine{6054                 hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{6055             \}}
\DoxyCodeLine{6056             \textcolor{keywordflow}{else}}
\DoxyCodeLine{6057             \{}
\DoxyCodeLine{6058                 \textcolor{keywordtype}{char} ch;}
\DoxyCodeLine{6059 }
\DoxyCodeLine{6060                 pszDestEnd = pszDest;}
\DoxyCodeLine{6061                 cchRemaining = cchDest;}
\DoxyCodeLine{6062 }
\DoxyCodeLine{6063                 \textcolor{keywordflow}{while} ((cchRemaining > 1) \&\& (ch = (\textcolor{keywordtype}{char})getc(stdin)) != \textcolor{charliteral}{'\(\backslash\)n'})}
\DoxyCodeLine{6064                 \{}
\DoxyCodeLine{6065                     \textcolor{keywordflow}{if} (ch == EOF)}
\DoxyCodeLine{6066                     \{}
\DoxyCodeLine{6067                         \textcolor{keywordflow}{if} (pszDestEnd == pszDest)}
\DoxyCodeLine{6068                         \{}
\DoxyCodeLine{6069                             \textcolor{comment}{// we failed to read anything from stdin}}
\DoxyCodeLine{6070                             hr = STRSAFE\_E\_END\_OF\_FILE;}
\DoxyCodeLine{6071                         \}}
\DoxyCodeLine{6072                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{6073                     \}}
\DoxyCodeLine{6074 }
\DoxyCodeLine{6075                     *pszDestEnd = ch;}
\DoxyCodeLine{6076 }
\DoxyCodeLine{6077                     pszDestEnd++;}
\DoxyCodeLine{6078                     cchRemaining-\/-\/;}
\DoxyCodeLine{6079                 \}}
\DoxyCodeLine{6080 }
\DoxyCodeLine{6081                 \textcolor{keywordflow}{if} (cchRemaining > 0)}
\DoxyCodeLine{6082                 \{}
\DoxyCodeLine{6083                     \textcolor{comment}{// there is extra room}}
\DoxyCodeLine{6084                     \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_BEHIND\_NULL)}
\DoxyCodeLine{6085                     \{}
\DoxyCodeLine{6086                         memset(pszDestEnd + 1, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), ((cchRemaining -\/ 1) * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})) + (cbDest \% \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})));}
\DoxyCodeLine{6087                     \}}
\DoxyCodeLine{6088                 \}}
\DoxyCodeLine{6089 }
\DoxyCodeLine{6090                 *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{6091             \}}
\DoxyCodeLine{6092         \}}
\DoxyCodeLine{6093     \}}
\DoxyCodeLine{6094 }
\DoxyCodeLine{6095     \textcolor{keywordflow}{if} (FAILED(hr))}
\DoxyCodeLine{6096     \{}
\DoxyCodeLine{6097         \textcolor{keywordflow}{if} (pszDest)}
\DoxyCodeLine{6098         \{}
\DoxyCodeLine{6099             \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_ON\_FAILURE)}
\DoxyCodeLine{6100             \{}
\DoxyCodeLine{6101                 memset(pszDest, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), cbDest);}
\DoxyCodeLine{6102 }
\DoxyCodeLine{6103                 \textcolor{keywordflow}{if} (STRSAFE\_GET\_FILL\_PATTERN(dwFlags) == 0)}
\DoxyCodeLine{6104                 \{}
\DoxyCodeLine{6105                     pszDestEnd = pszDest;}
\DoxyCodeLine{6106                     cchRemaining = cchDest;}
\DoxyCodeLine{6107                 \}}
\DoxyCodeLine{6108                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{6109                 \{}
\DoxyCodeLine{6110                     pszDestEnd = pszDest + cchDest -\/ 1;}
\DoxyCodeLine{6111                     cchRemaining = 1;}
\DoxyCodeLine{6112 }
\DoxyCodeLine{6113                     \textcolor{comment}{// null terminate the end of the string}}
\DoxyCodeLine{6114                     *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{6115                 \}}
\DoxyCodeLine{6116             \}}
\DoxyCodeLine{6117 }
\DoxyCodeLine{6118             \textcolor{keywordflow}{if} (dwFlags \& (STRSAFE\_NULL\_ON\_FAILURE | STRSAFE\_NO\_TRUNCATION))}
\DoxyCodeLine{6119             \{}
\DoxyCodeLine{6120                 \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{6121                 \{}
\DoxyCodeLine{6122                     pszDestEnd = pszDest;}
\DoxyCodeLine{6123                     cchRemaining = cchDest;}
\DoxyCodeLine{6124 }
\DoxyCodeLine{6125                     \textcolor{comment}{// null terminate the beginning of the string}}
\DoxyCodeLine{6126                     *pszDestEnd = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{6127                 \}}
\DoxyCodeLine{6128             \}}
\DoxyCodeLine{6129         \}}
\DoxyCodeLine{6130     \}}
\DoxyCodeLine{6131 }
\DoxyCodeLine{6132     \textcolor{keywordflow}{if} (SUCCEEDED(hr) ||}
\DoxyCodeLine{6133         (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER) ||}
\DoxyCodeLine{6134         (hr == STRSAFE\_E\_END\_OF\_FILE))}
\DoxyCodeLine{6135     \{}
\DoxyCodeLine{6136         \textcolor{keywordflow}{if} (ppszDestEnd)}
\DoxyCodeLine{6137         \{}
\DoxyCodeLine{6138             *ppszDestEnd = pszDestEnd;}
\DoxyCodeLine{6139         \}}
\DoxyCodeLine{6140 }
\DoxyCodeLine{6141         \textcolor{keywordflow}{if} (pcchRemaining)}
\DoxyCodeLine{6142         \{}
\DoxyCodeLine{6143             *pcchRemaining = cchRemaining;}
\DoxyCodeLine{6144         \}}
\DoxyCodeLine{6145     \}}
\DoxyCodeLine{6146 }
\DoxyCodeLine{6147     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{6148 \}}
\DoxyCodeLine{6149 }
\DoxyCodeLine{6150 STRSAFE\_INLINE\_API StringGetsExWorkerW(\textcolor{keywordtype}{wchar\_t}* pszDest, \textcolor{keywordtype}{size\_t} cchDest, \textcolor{keywordtype}{size\_t} cbDest, \textcolor{keywordtype}{wchar\_t}** ppszDestEnd, \textcolor{keywordtype}{size\_t}* pcchRemaining, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dwFlags)}
\DoxyCodeLine{6151 \{}
\DoxyCodeLine{6152     HRESULT hr = S\_OK;}
\DoxyCodeLine{6153     \textcolor{keywordtype}{wchar\_t}* pszDestEnd = pszDest;}
\DoxyCodeLine{6154     \textcolor{keywordtype}{size\_t} cchRemaining = 0;}
\DoxyCodeLine{6155 }
\DoxyCodeLine{6156     \textcolor{comment}{// ASSERT(cbDest == (cchDest * sizeof(char))    ||}}
\DoxyCodeLine{6157     \textcolor{comment}{//        cbDest == (cchDest * sizeof(char)) + (cbDest \% sizeof(char)));}}
\DoxyCodeLine{6158 }
\DoxyCodeLine{6159     \textcolor{comment}{// only accept valid flags}}
\DoxyCodeLine{6160     \textcolor{keywordflow}{if} (dwFlags \& (\string~STRSAFE\_VALID\_FLAGS))}
\DoxyCodeLine{6161     \{}
\DoxyCodeLine{6162         hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{6163     \}}
\DoxyCodeLine{6164     \textcolor{keywordflow}{else}}
\DoxyCodeLine{6165     \{}
\DoxyCodeLine{6166         \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_IGNORE\_NULLS)}
\DoxyCodeLine{6167         \{}
\DoxyCodeLine{6168             \textcolor{keywordflow}{if} (pszDest == NULL)}
\DoxyCodeLine{6169             \{}
\DoxyCodeLine{6170                 \textcolor{keywordflow}{if} ((cchDest != 0) || (cbDest != 0))}
\DoxyCodeLine{6171                 \{}
\DoxyCodeLine{6172                     \textcolor{comment}{// NULL pszDest and non-\/zero cchDest/cbDest is invalid}}
\DoxyCodeLine{6173                     hr = STRSAFE\_E\_INVALID\_PARAMETER;}
\DoxyCodeLine{6174                 \}}
\DoxyCodeLine{6175             \}}
\DoxyCodeLine{6176         \}}
\DoxyCodeLine{6177 }
\DoxyCodeLine{6178         \textcolor{keywordflow}{if} (SUCCEEDED(hr))}
\DoxyCodeLine{6179         \{}
\DoxyCodeLine{6180             \textcolor{keywordflow}{if} (cchDest <= 1)}
\DoxyCodeLine{6181             \{}
\DoxyCodeLine{6182                 pszDestEnd = pszDest;}
\DoxyCodeLine{6183                 cchRemaining = cchDest;}
\DoxyCodeLine{6184 }
\DoxyCodeLine{6185                 \textcolor{keywordflow}{if} (cchDest == 1)}
\DoxyCodeLine{6186                 \{}
\DoxyCodeLine{6187                     *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{6188                 \}}
\DoxyCodeLine{6189 }
\DoxyCodeLine{6190                 hr = STRSAFE\_E\_INSUFFICIENT\_BUFFER;}
\DoxyCodeLine{6191             \}}
\DoxyCodeLine{6192             \textcolor{keywordflow}{else}}
\DoxyCodeLine{6193             \{}
\DoxyCodeLine{6194                 \textcolor{keywordtype}{wchar\_t} ch;}
\DoxyCodeLine{6195 }
\DoxyCodeLine{6196                 pszDestEnd = pszDest;}
\DoxyCodeLine{6197                 cchRemaining = cchDest;}
\DoxyCodeLine{6198 }
\DoxyCodeLine{6199                 \textcolor{keywordflow}{while} ((cchRemaining > 1) \&\& (ch = (\textcolor{keywordtype}{wchar\_t})getwc(stdin)) != L\textcolor{charliteral}{'\(\backslash\)n'})}
\DoxyCodeLine{6200                 \{}
\DoxyCodeLine{6201                     \textcolor{keywordflow}{if} (ch == EOF)}
\DoxyCodeLine{6202                     \{}
\DoxyCodeLine{6203                         \textcolor{keywordflow}{if} (pszDestEnd == pszDest)}
\DoxyCodeLine{6204                         \{}
\DoxyCodeLine{6205                             \textcolor{comment}{// we failed to read anything from stdin}}
\DoxyCodeLine{6206                             hr = STRSAFE\_E\_END\_OF\_FILE;}
\DoxyCodeLine{6207                         \}}
\DoxyCodeLine{6208                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{6209                     \}}
\DoxyCodeLine{6210 }
\DoxyCodeLine{6211                     *pszDestEnd = ch;}
\DoxyCodeLine{6212 }
\DoxyCodeLine{6213                     pszDestEnd++;}
\DoxyCodeLine{6214                     cchRemaining-\/-\/;}
\DoxyCodeLine{6215                 \}}
\DoxyCodeLine{6216 }
\DoxyCodeLine{6217                 \textcolor{keywordflow}{if} (cchRemaining > 0)}
\DoxyCodeLine{6218                 \{}
\DoxyCodeLine{6219                     \textcolor{comment}{// there is extra room}}
\DoxyCodeLine{6220                     \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_BEHIND\_NULL)}
\DoxyCodeLine{6221                     \{}
\DoxyCodeLine{6222                         memset(pszDestEnd + 1, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), ((cchRemaining -\/ 1) * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t})) + (cbDest \% \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t})));}
\DoxyCodeLine{6223                     \}}
\DoxyCodeLine{6224                 \}}
\DoxyCodeLine{6225 }
\DoxyCodeLine{6226                 *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{6227             \}}
\DoxyCodeLine{6228         \}}
\DoxyCodeLine{6229     \}}
\DoxyCodeLine{6230 }
\DoxyCodeLine{6231     \textcolor{keywordflow}{if} (FAILED(hr))}
\DoxyCodeLine{6232     \{}
\DoxyCodeLine{6233         \textcolor{keywordflow}{if} (pszDest)}
\DoxyCodeLine{6234         \{}
\DoxyCodeLine{6235             \textcolor{keywordflow}{if} (dwFlags \& STRSAFE\_FILL\_ON\_FAILURE)}
\DoxyCodeLine{6236             \{}
\DoxyCodeLine{6237                 memset(pszDest, STRSAFE\_GET\_FILL\_PATTERN(dwFlags), cbDest);}
\DoxyCodeLine{6238 }
\DoxyCodeLine{6239                 \textcolor{keywordflow}{if} (STRSAFE\_GET\_FILL\_PATTERN(dwFlags) == 0)}
\DoxyCodeLine{6240                 \{}
\DoxyCodeLine{6241                     pszDestEnd = pszDest;}
\DoxyCodeLine{6242                     cchRemaining = cchDest;}
\DoxyCodeLine{6243                 \}}
\DoxyCodeLine{6244                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{6245                 \{}
\DoxyCodeLine{6246                     pszDestEnd = pszDest + cchDest -\/ 1;}
\DoxyCodeLine{6247                     cchRemaining = 1;}
\DoxyCodeLine{6248 }
\DoxyCodeLine{6249                     \textcolor{comment}{// null terminate the end of the string}}
\DoxyCodeLine{6250                     *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{6251                 \}}
\DoxyCodeLine{6252             \}}
\DoxyCodeLine{6253 }
\DoxyCodeLine{6254             \textcolor{keywordflow}{if} (dwFlags \& (STRSAFE\_NULL\_ON\_FAILURE | STRSAFE\_NO\_TRUNCATION))}
\DoxyCodeLine{6255             \{}
\DoxyCodeLine{6256                 \textcolor{keywordflow}{if} (cchDest > 0)}
\DoxyCodeLine{6257                 \{}
\DoxyCodeLine{6258                     pszDestEnd = pszDest;}
\DoxyCodeLine{6259                     cchRemaining = cchDest;}
\DoxyCodeLine{6260 }
\DoxyCodeLine{6261                     \textcolor{comment}{// null terminate the beginning of the string}}
\DoxyCodeLine{6262                     *pszDestEnd = L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{6263                 \}}
\DoxyCodeLine{6264             \}}
\DoxyCodeLine{6265         \}}
\DoxyCodeLine{6266     \}}
\DoxyCodeLine{6267 }
\DoxyCodeLine{6268     \textcolor{keywordflow}{if} (SUCCEEDED(hr) ||}
\DoxyCodeLine{6269         (hr == STRSAFE\_E\_INSUFFICIENT\_BUFFER) ||}
\DoxyCodeLine{6270         (hr == STRSAFE\_E\_END\_OF\_FILE))}
\DoxyCodeLine{6271     \{}
\DoxyCodeLine{6272         \textcolor{keywordflow}{if} (ppszDestEnd)}
\DoxyCodeLine{6273         \{}
\DoxyCodeLine{6274             *ppszDestEnd = pszDestEnd;}
\DoxyCodeLine{6275         \}}
\DoxyCodeLine{6276 }
\DoxyCodeLine{6277         \textcolor{keywordflow}{if} (pcchRemaining)}
\DoxyCodeLine{6278         \{}
\DoxyCodeLine{6279             *pcchRemaining = cchRemaining;}
\DoxyCodeLine{6280         \}}
\DoxyCodeLine{6281     \}}
\DoxyCodeLine{6282 }
\DoxyCodeLine{6283     \textcolor{keywordflow}{return} hr;}
\DoxyCodeLine{6284 \}}
\DoxyCodeLine{6285 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_LIB\_IMPL}}
\DoxyCodeLine{6286 }
\DoxyCodeLine{6287 }
\DoxyCodeLine{6288 \textcolor{comment}{// Do not call these functions, they are worker functions for internal use within this file}}
\DoxyCodeLine{6289 \textcolor{preprocessor}{\#ifdef DEPRECATE\_SUPPORTED}}
\DoxyCodeLine{6290 \textcolor{preprocessor}{\#pragma deprecated(StringCopyWorkerA)}}
\DoxyCodeLine{6291 \textcolor{preprocessor}{\#pragma deprecated(StringCopyWorkerW)}}
\DoxyCodeLine{6292 \textcolor{preprocessor}{\#pragma deprecated(StringCopyExWorkerA)}}
\DoxyCodeLine{6293 \textcolor{preprocessor}{\#pragma deprecated(StringCopyExWorkerW)}}
\DoxyCodeLine{6294 \textcolor{preprocessor}{\#pragma deprecated(StringCatWorkerA)}}
\DoxyCodeLine{6295 \textcolor{preprocessor}{\#pragma deprecated(StringCatWorkerW)}}
\DoxyCodeLine{6296 \textcolor{preprocessor}{\#pragma deprecated(StringCatExWorkerA)}}
\DoxyCodeLine{6297 \textcolor{preprocessor}{\#pragma deprecated(StringCatExWorkerW)}}
\DoxyCodeLine{6298 \textcolor{preprocessor}{\#pragma deprecated(StringCatNWorkerA)}}
\DoxyCodeLine{6299 \textcolor{preprocessor}{\#pragma deprecated(StringCatNWorkerW)}}
\DoxyCodeLine{6300 \textcolor{preprocessor}{\#pragma deprecated(StringCatNExWorkerA)}}
\DoxyCodeLine{6301 \textcolor{preprocessor}{\#pragma deprecated(StringCatNExWorkerW)}}
\DoxyCodeLine{6302 \textcolor{preprocessor}{\#pragma deprecated(StringVPrintfWorkerA)}}
\DoxyCodeLine{6303 \textcolor{preprocessor}{\#pragma deprecated(StringVPrintfWorkerW)}}
\DoxyCodeLine{6304 \textcolor{preprocessor}{\#pragma deprecated(StringVPrintfExWorkerA)}}
\DoxyCodeLine{6305 \textcolor{preprocessor}{\#pragma deprecated(StringVPrintfExWorkerW)}}
\DoxyCodeLine{6306 \textcolor{preprocessor}{\#pragma deprecated(StringLengthWorkerA)}}
\DoxyCodeLine{6307 \textcolor{preprocessor}{\#pragma deprecated(StringLengthWorkerW)}}
\DoxyCodeLine{6308 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{6309 \textcolor{preprocessor}{\#define StringCopyWorkerA        StringCopyWorkerA\_instead\_use\_StringCchCopyA\_or\_StringCchCopyExA;}}
\DoxyCodeLine{6310 \textcolor{preprocessor}{\#define StringCopyWorkerW        StringCopyWorkerW\_instead\_use\_StringCchCopyW\_or\_StringCchCopyExW;}}
\DoxyCodeLine{6311 \textcolor{preprocessor}{\#define StringCopyExWorkerA      StringCopyExWorkerA\_instead\_use\_StringCchCopyA\_or\_StringCchCopyExA;}}
\DoxyCodeLine{6312 \textcolor{preprocessor}{\#define StringCopyExWorkerW      StringCopyExWorkerW\_instead\_use\_StringCchCopyW\_or\_StringCchCopyExW;}}
\DoxyCodeLine{6313 \textcolor{preprocessor}{\#define StringCatWorkerA         StringCatWorkerA\_instead\_use\_StringCchCatA\_or\_StringCchCatExA;}}
\DoxyCodeLine{6314 \textcolor{preprocessor}{\#define StringCatWorkerW         StringCatWorkerW\_instead\_use\_StringCchCatW\_or\_StringCchCatExW;}}
\DoxyCodeLine{6315 \textcolor{preprocessor}{\#define StringCatExWorkerA       StringCatExWorkerA\_instead\_use\_StringCchCatA\_or\_StringCchCatExA;}}
\DoxyCodeLine{6316 \textcolor{preprocessor}{\#define StringCatExWorkerW       StringCatExWorkerW\_instead\_use\_StringCchCatW\_or\_StringCchCatExW;}}
\DoxyCodeLine{6317 \textcolor{preprocessor}{\#define StringCatNWorkerA        StringCatNWorkerA\_instead\_use\_StringCchCatNA\_or\_StrincCbCatNA;}}
\DoxyCodeLine{6318 \textcolor{preprocessor}{\#define StringCatNWorkerW        StringCatNWorkerW\_instead\_use\_StringCchCatNW\_or\_StringCbCatNW;}}
\DoxyCodeLine{6319 \textcolor{preprocessor}{\#define StringCatNExWorkerA      StringCatNExWorkerA\_instead\_use\_StringCchCatNExA\_or\_StringCbCatNExA;}}
\DoxyCodeLine{6320 \textcolor{preprocessor}{\#define StringCatNExWorkerW      StringCatNExWorkerW\_instead\_use\_StringCchCatNExW\_or\_StringCbCatNExW;}}
\DoxyCodeLine{6321 \textcolor{preprocessor}{\#define StringVPrintfWorkerA     StringVPrintfWorkerA\_instead\_use\_StringCchVPrintfA\_or\_StringCchVPrintfExA;}}
\DoxyCodeLine{6322 \textcolor{preprocessor}{\#define StringVPrintfWorkerW     StringVPrintfWorkerW\_instead\_use\_StringCchVPrintfW\_or\_StringCchVPrintfExW;}}
\DoxyCodeLine{6323 \textcolor{preprocessor}{\#define StringVPrintfExWorkerA   StringVPrintfExWorkerA\_instead\_use\_StringCchVPrintfA\_or\_StringCchVPrintfExA;}}
\DoxyCodeLine{6324 \textcolor{preprocessor}{\#define StringVPrintfExWorkerW   StringVPrintfExWorkerW\_instead\_use\_StringCchVPrintfW\_or\_StringCchVPrintfExW;}}
\DoxyCodeLine{6325 \textcolor{preprocessor}{\#define StringLengthWorkerA      StringLengthWorkerA\_instead\_use\_StringCchLengthA\_or\_StringCbLengthA;}}
\DoxyCodeLine{6326 \textcolor{preprocessor}{\#define StringLengthWorkerW      StringLengthWorkerW\_instead\_use\_StringCchLengthW\_or\_StringCbLengthW;}}
\DoxyCodeLine{6327 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !DEPRECATE\_SUPPORTED}}
\DoxyCodeLine{6328 }
\DoxyCodeLine{6329 }
\DoxyCodeLine{6330 \textcolor{preprocessor}{\#ifndef STRSAFE\_NO\_DEPRECATE}}
\DoxyCodeLine{6331 \textcolor{comment}{// Deprecate all of the unsafe functions to generate compiletime errors. If you do not want}}
\DoxyCodeLine{6332 \textcolor{comment}{// this then you can \#define STRSAFE\_NO\_DEPRECATE before including this file.}}
\DoxyCodeLine{6333 \textcolor{preprocessor}{\#ifdef DEPRECATE\_SUPPORTED}}
\DoxyCodeLine{6334 }
\DoxyCodeLine{6335 \textcolor{comment}{// First all the names that are a/w variants (or shouldn't be \#defined by now anyway).}}
\DoxyCodeLine{6336 \textcolor{preprocessor}{\#pragma deprecated(lstrcpyA)}}
\DoxyCodeLine{6337 \textcolor{preprocessor}{\#pragma deprecated(lstrcpyW)}}
\DoxyCodeLine{6338 \textcolor{preprocessor}{\#pragma deprecated(lstrcatA)}}
\DoxyCodeLine{6339 \textcolor{preprocessor}{\#pragma deprecated(lstrcatW)}}
\DoxyCodeLine{6340 \textcolor{preprocessor}{\#pragma deprecated(wsprintfA)}}
\DoxyCodeLine{6341 \textcolor{preprocessor}{\#pragma deprecated(wsprintfW)}}
\DoxyCodeLine{6342 }
\DoxyCodeLine{6343 \textcolor{preprocessor}{\#pragma deprecated(StrCpyW)}}
\DoxyCodeLine{6344 \textcolor{preprocessor}{\#pragma deprecated(StrCatW)}}
\DoxyCodeLine{6345 \textcolor{preprocessor}{\#pragma deprecated(StrNCatA)}}
\DoxyCodeLine{6346 \textcolor{preprocessor}{\#pragma deprecated(StrNCatW)}}
\DoxyCodeLine{6347 \textcolor{preprocessor}{\#pragma deprecated(StrCatNA)}}
\DoxyCodeLine{6348 \textcolor{preprocessor}{\#pragma deprecated(StrCatNW)}}
\DoxyCodeLine{6349 \textcolor{preprocessor}{\#pragma deprecated(wvsprintfA)}}
\DoxyCodeLine{6350 \textcolor{preprocessor}{\#pragma deprecated(wvsprintfW)}}
\DoxyCodeLine{6351 }
\DoxyCodeLine{6352 \textcolor{preprocessor}{\#pragma deprecated(strcpy)}}
\DoxyCodeLine{6353 \textcolor{preprocessor}{\#pragma deprecated(wcscpy)}}
\DoxyCodeLine{6354 \textcolor{preprocessor}{\#pragma deprecated(strcat)}}
\DoxyCodeLine{6355 \textcolor{preprocessor}{\#pragma deprecated(wcscat)}}
\DoxyCodeLine{6356 \textcolor{preprocessor}{\#pragma deprecated(sprintf)}}
\DoxyCodeLine{6357 \textcolor{preprocessor}{\#pragma deprecated(swprintf)}}
\DoxyCodeLine{6358 \textcolor{preprocessor}{\#pragma deprecated(vsprintf)}}
\DoxyCodeLine{6359 \textcolor{preprocessor}{\#pragma deprecated(vswprintf)}}
\DoxyCodeLine{6360 \textcolor{preprocessor}{\#pragma deprecated(\_snprintf)}}
\DoxyCodeLine{6361 \textcolor{preprocessor}{\#pragma deprecated(\_snwprintf)}}
\DoxyCodeLine{6362 \textcolor{preprocessor}{\#pragma deprecated(\_vsnprintf)}}
\DoxyCodeLine{6363 \textcolor{preprocessor}{\#pragma deprecated(\_vsnwprintf)}}
\DoxyCodeLine{6364 \textcolor{preprocessor}{\#pragma deprecated(gets)}}
\DoxyCodeLine{6365 \textcolor{preprocessor}{\#pragma deprecated(\_getws)}}
\DoxyCodeLine{6366 }
\DoxyCodeLine{6367 \textcolor{comment}{// Then all the windows.h names -\/ we need to undef and redef based on UNICODE setting}}
\DoxyCodeLine{6368 \textcolor{preprocessor}{\#undef lstrcpy}}
\DoxyCodeLine{6369 \textcolor{preprocessor}{\#undef lstrcat}}
\DoxyCodeLine{6370 \textcolor{preprocessor}{\#undef wsprintf}}
\DoxyCodeLine{6371 \textcolor{preprocessor}{\#undef wvsprintf}}
\DoxyCodeLine{6372 \textcolor{preprocessor}{\#pragma deprecated(lstrcpy)}}
\DoxyCodeLine{6373 \textcolor{preprocessor}{\#pragma deprecated(lstrcat)}}
\DoxyCodeLine{6374 \textcolor{preprocessor}{\#pragma deprecated(wsprintf)}}
\DoxyCodeLine{6375 \textcolor{preprocessor}{\#pragma deprecated(wvsprintf)}}
\DoxyCodeLine{6376 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{6377 \textcolor{preprocessor}{\#define lstrcpy    lstrcpyW}}
\DoxyCodeLine{6378 \textcolor{preprocessor}{\#define lstrcat    lstrcatW}}
\DoxyCodeLine{6379 \textcolor{preprocessor}{\#define wsprintf   wsprintfW}}
\DoxyCodeLine{6380 \textcolor{preprocessor}{\#define wvsprintf  wvsprintfW}}
\DoxyCodeLine{6381 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{6382 \textcolor{preprocessor}{\#define lstrcpy    lstrcpyA}}
\DoxyCodeLine{6383 \textcolor{preprocessor}{\#define lstrcat    lstrcatA}}
\DoxyCodeLine{6384 \textcolor{preprocessor}{\#define wsprintf   wsprintfA}}
\DoxyCodeLine{6385 \textcolor{preprocessor}{\#define wvsprintf  wvsprintfA}}
\DoxyCodeLine{6386 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6387 }
\DoxyCodeLine{6388 \textcolor{comment}{// Then the shlwapi names -\/ they key off UNICODE also.}}
\DoxyCodeLine{6389 \textcolor{preprocessor}{\#undef StrCpyA}}
\DoxyCodeLine{6390 \textcolor{preprocessor}{\#undef StrCpy}}
\DoxyCodeLine{6391 \textcolor{preprocessor}{\#undef StrCatA}}
\DoxyCodeLine{6392 \textcolor{preprocessor}{\#undef StrCat}}
\DoxyCodeLine{6393 \textcolor{preprocessor}{\#undef StrNCat}}
\DoxyCodeLine{6394 \textcolor{preprocessor}{\#undef StrCatN}}
\DoxyCodeLine{6395 \textcolor{preprocessor}{\#pragma deprecated(StrCpyA)}}
\DoxyCodeLine{6396 \textcolor{preprocessor}{\#pragma deprecated(StrCatA)}}
\DoxyCodeLine{6397 \textcolor{preprocessor}{\#pragma deprecated(StrCatN)}}
\DoxyCodeLine{6398 \textcolor{preprocessor}{\#pragma deprecated(StrCpy)}}
\DoxyCodeLine{6399 \textcolor{preprocessor}{\#pragma deprecated(StrCat)}}
\DoxyCodeLine{6400 \textcolor{preprocessor}{\#pragma deprecated(StrNCat)}}
\DoxyCodeLine{6401 \textcolor{preprocessor}{\#define StrCpyA lstrcpyA}}
\DoxyCodeLine{6402 \textcolor{preprocessor}{\#define StrCatA lstrcatA}}
\DoxyCodeLine{6403 \textcolor{preprocessor}{\#define StrCatN StrNCat}}
\DoxyCodeLine{6404 \textcolor{preprocessor}{\#ifdef UNICODE}}
\DoxyCodeLine{6405 \textcolor{preprocessor}{\#define StrCpy  StrCpyW}}
\DoxyCodeLine{6406 \textcolor{preprocessor}{\#define StrCat  StrCatW}}
\DoxyCodeLine{6407 \textcolor{preprocessor}{\#define StrNCat StrNCatW}}
\DoxyCodeLine{6408 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{6409 \textcolor{preprocessor}{\#define StrCpy  lstrcpyA}}
\DoxyCodeLine{6410 \textcolor{preprocessor}{\#define StrCat  lstrcatA}}
\DoxyCodeLine{6411 \textcolor{preprocessor}{\#define StrNCat StrNCatA}}
\DoxyCodeLine{6412 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6413 }
\DoxyCodeLine{6414 \textcolor{comment}{// Then all the CRT names -\/ we need to undef/redef based on \_UNICODE value.}}
\DoxyCodeLine{6415 \textcolor{preprocessor}{\#undef \_tcscpy}}
\DoxyCodeLine{6416 \textcolor{preprocessor}{\#undef \_ftcscpy}}
\DoxyCodeLine{6417 \textcolor{preprocessor}{\#undef \_tcscat}}
\DoxyCodeLine{6418 \textcolor{preprocessor}{\#undef \_ftcscat}}
\DoxyCodeLine{6419 \textcolor{preprocessor}{\#undef \_stprintf}}
\DoxyCodeLine{6420 \textcolor{preprocessor}{\#undef \_sntprintf}}
\DoxyCodeLine{6421 \textcolor{preprocessor}{\#undef \_vstprintf}}
\DoxyCodeLine{6422 \textcolor{preprocessor}{\#undef \_vsntprintf}}
\DoxyCodeLine{6423 \textcolor{preprocessor}{\#undef \_getts}}
\DoxyCodeLine{6424 \textcolor{preprocessor}{\#pragma deprecated(\_tcscpy)}}
\DoxyCodeLine{6425 \textcolor{preprocessor}{\#pragma deprecated(\_ftcscpy)}}
\DoxyCodeLine{6426 \textcolor{preprocessor}{\#pragma deprecated(\_tcscat)}}
\DoxyCodeLine{6427 \textcolor{preprocessor}{\#pragma deprecated(\_ftcscat)}}
\DoxyCodeLine{6428 \textcolor{preprocessor}{\#pragma deprecated(\_stprintf)}}
\DoxyCodeLine{6429 \textcolor{preprocessor}{\#pragma deprecated(\_sntprintf)}}
\DoxyCodeLine{6430 \textcolor{preprocessor}{\#pragma deprecated(\_vstprintf)}}
\DoxyCodeLine{6431 \textcolor{preprocessor}{\#pragma deprecated(\_vsntprintf)}}
\DoxyCodeLine{6432 \textcolor{preprocessor}{\#pragma deprecated(\_getts)}}
\DoxyCodeLine{6433 \textcolor{preprocessor}{\#ifdef \_UNICODE}}
\DoxyCodeLine{6434 \textcolor{preprocessor}{\#define \_tcscpy     wcscpy}}
\DoxyCodeLine{6435 \textcolor{preprocessor}{\#define \_ftcscpy    wcscpy}}
\DoxyCodeLine{6436 \textcolor{preprocessor}{\#define \_tcscat     wcscat}}
\DoxyCodeLine{6437 \textcolor{preprocessor}{\#define \_ftcscat    wcscat}}
\DoxyCodeLine{6438 \textcolor{preprocessor}{\#define \_stprintf   swprintf}}
\DoxyCodeLine{6439 \textcolor{preprocessor}{\#define \_sntprintf  \_snwprintf}}
\DoxyCodeLine{6440 \textcolor{preprocessor}{\#define \_vstprintf  vswprintf}}
\DoxyCodeLine{6441 \textcolor{preprocessor}{\#define \_vsntprintf \_vsnwprintf}}
\DoxyCodeLine{6442 \textcolor{preprocessor}{\#define \_getts      \_getws}}
\DoxyCodeLine{6443 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{6444 \textcolor{preprocessor}{\#define \_tcscpy     strcpy}}
\DoxyCodeLine{6445 \textcolor{preprocessor}{\#define \_ftcscpy    strcpy}}
\DoxyCodeLine{6446 \textcolor{preprocessor}{\#define \_tcscat     strcat}}
\DoxyCodeLine{6447 \textcolor{preprocessor}{\#define \_ftcscat    strcat}}
\DoxyCodeLine{6448 \textcolor{preprocessor}{\#define \_stprintf   sprintf}}
\DoxyCodeLine{6449 \textcolor{preprocessor}{\#define \_sntprintf  \_snprintf}}
\DoxyCodeLine{6450 \textcolor{preprocessor}{\#define \_vstprintf  vsprintf}}
\DoxyCodeLine{6451 \textcolor{preprocessor}{\#define \_vsntprintf \_vsnprintf}}
\DoxyCodeLine{6452 \textcolor{preprocessor}{\#define \_getts      gets}}
\DoxyCodeLine{6453 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6454 }
\DoxyCodeLine{6455 \textcolor{preprocessor}{\#else }\textcolor{comment}{// DEPRECATE\_SUPPORTED}}
\DoxyCodeLine{6456 }
\DoxyCodeLine{6457 \textcolor{preprocessor}{\#undef strcpy}}
\DoxyCodeLine{6458 \textcolor{preprocessor}{\#define strcpy      strcpy\_instead\_use\_StringCbCopyA\_or\_StringCchCopyA;}}
\DoxyCodeLine{6459 }
\DoxyCodeLine{6460 \textcolor{preprocessor}{\#undef wcscpy}}
\DoxyCodeLine{6461 \textcolor{preprocessor}{\#define wcscpy      wcscpy\_instead\_use\_StringCbCopyW\_or\_StringCchCopyW;}}
\DoxyCodeLine{6462 }
\DoxyCodeLine{6463 \textcolor{preprocessor}{\#undef strcat}}
\DoxyCodeLine{6464 \textcolor{preprocessor}{\#define strcat      strcat\_instead\_use\_StringCbCatA\_or\_StringCchCatA;}}
\DoxyCodeLine{6465 }
\DoxyCodeLine{6466 \textcolor{preprocessor}{\#undef wcscat}}
\DoxyCodeLine{6467 \textcolor{preprocessor}{\#define wcscat      wcscat\_instead\_use\_StringCbCatW\_or\_StringCchCatW;}}
\DoxyCodeLine{6468 }
\DoxyCodeLine{6469 \textcolor{preprocessor}{\#undef sprintf}}
\DoxyCodeLine{6470 \textcolor{preprocessor}{\#define sprintf     sprintf\_instead\_use\_StringCbPrintfA\_or\_StringCchPrintfA;}}
\DoxyCodeLine{6471 }
\DoxyCodeLine{6472 \textcolor{preprocessor}{\#undef swprintf}}
\DoxyCodeLine{6473 \textcolor{preprocessor}{\#define swprintf    swprintf\_instead\_use\_StringCbPrintfW\_or\_StringCchPrintfW;}}
\DoxyCodeLine{6474 }
\DoxyCodeLine{6475 \textcolor{preprocessor}{\#undef vsprintf}}
\DoxyCodeLine{6476 \textcolor{preprocessor}{\#define vsprintf    vsprintf\_instead\_use\_StringCbVPrintfA\_or\_StringCchVPrintfA;}}
\DoxyCodeLine{6477 }
\DoxyCodeLine{6478 \textcolor{preprocessor}{\#undef vswprintf}}
\DoxyCodeLine{6479 \textcolor{preprocessor}{\#define vswprintf   vswprintf\_instead\_use\_StringCbVPrintfW\_or\_StringCchVPrintfW;}}
\DoxyCodeLine{6480 }
\DoxyCodeLine{6481 \textcolor{preprocessor}{\#undef \_snprintf}}
\DoxyCodeLine{6482 \textcolor{preprocessor}{\#define \_snprintf   \_snprintf\_instead\_use\_StringCbPrintfA\_or\_StringCchPrintfA;}}
\DoxyCodeLine{6483 }
\DoxyCodeLine{6484 \textcolor{preprocessor}{\#undef \_snwprintf}}
\DoxyCodeLine{6485 \textcolor{preprocessor}{\#define \_snwprintf  \_snwprintf\_instead\_use\_StringCbPrintfW\_or\_StringCchPrintfW;}}
\DoxyCodeLine{6486 }
\DoxyCodeLine{6487 \textcolor{preprocessor}{\#undef \_vsnprintf}}
\DoxyCodeLine{6488 \textcolor{preprocessor}{\#define \_vsnprintf  \_vsnprintf\_instead\_use\_StringCbVPrintfA\_or\_StringCchVPrintfA;}}
\DoxyCodeLine{6489 }
\DoxyCodeLine{6490 \textcolor{preprocessor}{\#undef \_vsnwprintf}}
\DoxyCodeLine{6491 \textcolor{preprocessor}{\#define \_vsnwprintf \_vsnwprintf\_instead\_use\_StringCbVPrintfW\_or\_StringCchVPrintfW;}}
\DoxyCodeLine{6492 }
\DoxyCodeLine{6493 \textcolor{preprocessor}{\#undef strcpyA}}
\DoxyCodeLine{6494 \textcolor{preprocessor}{\#define strcpyA     strcpyA\_instead\_use\_StringCbCopyA\_or\_StringCchCopyA;}}
\DoxyCodeLine{6495 }
\DoxyCodeLine{6496 \textcolor{preprocessor}{\#undef strcpyW}}
\DoxyCodeLine{6497 \textcolor{preprocessor}{\#define strcpyW     strcpyW\_instead\_use\_StringCbCopyW\_or\_StringCchCopyW;}}
\DoxyCodeLine{6498 }
\DoxyCodeLine{6499 \textcolor{preprocessor}{\#undef lstrcpy}}
\DoxyCodeLine{6500 \textcolor{preprocessor}{\#define lstrcpy     lstrcpy\_instead\_use\_StringCbCopy\_or\_StringCchCopy;}}
\DoxyCodeLine{6501 }
\DoxyCodeLine{6502 \textcolor{preprocessor}{\#undef lstrcpyA}}
\DoxyCodeLine{6503 \textcolor{preprocessor}{\#define lstrcpyA    lstrcpyA\_instead\_use\_StringCbCopyA\_or\_StringCchCopyA;}}
\DoxyCodeLine{6504 }
\DoxyCodeLine{6505 \textcolor{preprocessor}{\#undef lstrcpyW}}
\DoxyCodeLine{6506 \textcolor{preprocessor}{\#define lstrcpyW    lstrcpyW\_instead\_use\_StringCbCopyW\_or\_StringCchCopyW;}}
\DoxyCodeLine{6507 }
\DoxyCodeLine{6508 \textcolor{preprocessor}{\#undef StrCpy}}
\DoxyCodeLine{6509 \textcolor{preprocessor}{\#define StrCpy      StrCpy\_instead\_use\_StringCbCopy\_or\_StringCchCopy;}}
\DoxyCodeLine{6510 }
\DoxyCodeLine{6511 \textcolor{preprocessor}{\#undef StrCpyA}}
\DoxyCodeLine{6512 \textcolor{preprocessor}{\#define StrCpyA     StrCpyA\_instead\_use\_StringCbCopyA\_or\_StringCchCopyA;}}
\DoxyCodeLine{6513 }
\DoxyCodeLine{6514 \textcolor{preprocessor}{\#undef StrCpyW}}
\DoxyCodeLine{6515 \textcolor{preprocessor}{\#define StrCpyW     StrCpyW\_instead\_use\_StringCbCopyW\_or\_StringCchCopyW;}}
\DoxyCodeLine{6516 }
\DoxyCodeLine{6517 \textcolor{preprocessor}{\#undef \_tcscpy}}
\DoxyCodeLine{6518 \textcolor{preprocessor}{\#define \_tcscpy     \_tcscpy\_instead\_use\_StringCbCopy\_or\_StringCchCopy;}}
\DoxyCodeLine{6519 }
\DoxyCodeLine{6520 \textcolor{preprocessor}{\#undef \_ftcscpy}}
\DoxyCodeLine{6521 \textcolor{preprocessor}{\#define \_ftcscpy    \_ftcscpy\_instead\_use\_StringCbCopy\_or\_StringCchCopy;}}
\DoxyCodeLine{6522 }
\DoxyCodeLine{6523 \textcolor{preprocessor}{\#undef lstrcat}}
\DoxyCodeLine{6524 \textcolor{preprocessor}{\#define lstrcat     lstrcat\_instead\_use\_StringCbCat\_or\_StringCchCat;}}
\DoxyCodeLine{6525 }
\DoxyCodeLine{6526 \textcolor{preprocessor}{\#undef lstrcatA}}
\DoxyCodeLine{6527 \textcolor{preprocessor}{\#define lstrcatA    lstrcatA\_instead\_use\_StringCbCatA\_or\_StringCchCatA;}}
\DoxyCodeLine{6528 }
\DoxyCodeLine{6529 \textcolor{preprocessor}{\#undef lstrcatW}}
\DoxyCodeLine{6530 \textcolor{preprocessor}{\#define lstrcatW    lstrcatW\_instead\_use\_StringCbCatW\_or\_StringCchCatW;}}
\DoxyCodeLine{6531 }
\DoxyCodeLine{6532 \textcolor{preprocessor}{\#undef StrCat}}
\DoxyCodeLine{6533 \textcolor{preprocessor}{\#define StrCat      StrCat\_instead\_use\_StringCbCat\_or\_StringCchCat;}}
\DoxyCodeLine{6534 }
\DoxyCodeLine{6535 \textcolor{preprocessor}{\#undef StrCatA}}
\DoxyCodeLine{6536 \textcolor{preprocessor}{\#define StrCatA     StrCatA\_instead\_use\_StringCbCatA\_or\_StringCchCatA;}}
\DoxyCodeLine{6537 }
\DoxyCodeLine{6538 \textcolor{preprocessor}{\#undef StrCatW}}
\DoxyCodeLine{6539 \textcolor{preprocessor}{\#define StrCatW     StrCatW\_instead\_use\_StringCbCatW\_or\_StringCchCatW;}}
\DoxyCodeLine{6540 }
\DoxyCodeLine{6541 \textcolor{preprocessor}{\#undef StrNCat}}
\DoxyCodeLine{6542 \textcolor{preprocessor}{\#define StrNCat     StrNCat\_instead\_use\_StringCbCatN\_or\_StringCchCatN;}}
\DoxyCodeLine{6543 }
\DoxyCodeLine{6544 \textcolor{preprocessor}{\#undef StrNCatA}}
\DoxyCodeLine{6545 \textcolor{preprocessor}{\#define StrNCatA    StrNCatA\_instead\_use\_StringCbCatNA\_or\_StringCchCatNA;}}
\DoxyCodeLine{6546 }
\DoxyCodeLine{6547 \textcolor{preprocessor}{\#undef StrNCatW}}
\DoxyCodeLine{6548 \textcolor{preprocessor}{\#define StrNCatW    StrNCatW\_instead\_use\_StringCbCatNW\_or\_StringCchCatNW;}}
\DoxyCodeLine{6549 }
\DoxyCodeLine{6550 \textcolor{preprocessor}{\#undef StrCatN}}
\DoxyCodeLine{6551 \textcolor{preprocessor}{\#define StrCatN     StrCatN\_instead\_use\_StringCbCatN\_or\_StringCchCatN;}}
\DoxyCodeLine{6552 }
\DoxyCodeLine{6553 \textcolor{preprocessor}{\#undef StrCatNA}}
\DoxyCodeLine{6554 \textcolor{preprocessor}{\#define StrCatNA    StrCatNA\_instead\_use\_StringCbCatNA\_or\_StringCchCatNA;}}
\DoxyCodeLine{6555 }
\DoxyCodeLine{6556 \textcolor{preprocessor}{\#undef StrCatNW}}
\DoxyCodeLine{6557 \textcolor{preprocessor}{\#define StrCatNW    StrCatNW\_instead\_use\_StringCbCatNW\_or\_StringCchCatNW;}}
\DoxyCodeLine{6558 }
\DoxyCodeLine{6559 \textcolor{preprocessor}{\#undef \_tcscat}}
\DoxyCodeLine{6560 \textcolor{preprocessor}{\#define \_tcscat     \_tcscat\_instead\_use\_StringCbCat\_or\_StringCchCat;}}
\DoxyCodeLine{6561 }
\DoxyCodeLine{6562 \textcolor{preprocessor}{\#undef \_ftcscat}}
\DoxyCodeLine{6563 \textcolor{preprocessor}{\#define \_ftcscat    \_ftcscat\_instead\_use\_StringCbCat\_or\_StringCchCat;}}
\DoxyCodeLine{6564 }
\DoxyCodeLine{6565 \textcolor{preprocessor}{\#undef wsprintf}}
\DoxyCodeLine{6566 \textcolor{preprocessor}{\#define wsprintf    wsprintf\_instead\_use\_StringCbPrintf\_or\_StringCchPrintf;}}
\DoxyCodeLine{6567 }
\DoxyCodeLine{6568 \textcolor{preprocessor}{\#undef wsprintfA}}
\DoxyCodeLine{6569 \textcolor{preprocessor}{\#define wsprintfA   wsprintfA\_instead\_use\_StringCbPrintfA\_or\_StringCchPrintfA;}}
\DoxyCodeLine{6570 }
\DoxyCodeLine{6571 \textcolor{preprocessor}{\#undef wsprintfW}}
\DoxyCodeLine{6572 \textcolor{preprocessor}{\#define wsprintfW   wsprintfW\_instead\_use\_StringCbPrintfW\_or\_StringCchPrintfW;}}
\DoxyCodeLine{6573 }
\DoxyCodeLine{6574 \textcolor{preprocessor}{\#undef wvsprintf}}
\DoxyCodeLine{6575 \textcolor{preprocessor}{\#define wvsprintf   wvsprintf\_instead\_use\_StringCbVPrintf\_or\_StringCchVPrintf;}}
\DoxyCodeLine{6576 }
\DoxyCodeLine{6577 \textcolor{preprocessor}{\#undef wvsprintfA}}
\DoxyCodeLine{6578 \textcolor{preprocessor}{\#define wvsprintfA  wvsprintfA\_instead\_use\_StringCbVPrintfA\_or\_StringCchVPrintfA;}}
\DoxyCodeLine{6579 }
\DoxyCodeLine{6580 \textcolor{preprocessor}{\#undef wvsprintfW}}
\DoxyCodeLine{6581 \textcolor{preprocessor}{\#define wvsprintfW  wvsprintfW\_instead\_use\_StringCbVPrintfW\_or\_StringCchVPrintfW;}}
\DoxyCodeLine{6582 }
\DoxyCodeLine{6583 \textcolor{preprocessor}{\#undef \_vstprintf}}
\DoxyCodeLine{6584 \textcolor{preprocessor}{\#define \_vstprintf  \_vstprintf\_instead\_use\_StringCbVPrintf\_or\_StringCchVPrintf;}}
\DoxyCodeLine{6585 }
\DoxyCodeLine{6586 \textcolor{preprocessor}{\#undef \_vsntprintf}}
\DoxyCodeLine{6587 \textcolor{preprocessor}{\#define \_vsntprintf \_vsntprintf\_instead\_use\_StringCbVPrintf\_or\_StringCchVPrintf;}}
\DoxyCodeLine{6588 }
\DoxyCodeLine{6589 \textcolor{preprocessor}{\#undef \_stprintf}}
\DoxyCodeLine{6590 \textcolor{preprocessor}{\#define \_stprintf   \_stprintf\_instead\_use\_StringCbPrintf\_or\_StringCchPrintf;}}
\DoxyCodeLine{6591 }
\DoxyCodeLine{6592 \textcolor{preprocessor}{\#undef \_sntprintf}}
\DoxyCodeLine{6593 \textcolor{preprocessor}{\#define \_sntprintf  \_sntprintf\_instead\_use\_StringCbPrintf\_or\_StringCchPrintf;}}
\DoxyCodeLine{6594 }
\DoxyCodeLine{6595 \textcolor{preprocessor}{\#undef \_getts}}
\DoxyCodeLine{6596 \textcolor{preprocessor}{\#define \_getts      \_getts\_instead\_use\_StringCbGets\_or\_StringCchGets;}}
\DoxyCodeLine{6597 }
\DoxyCodeLine{6598 \textcolor{preprocessor}{\#undef gets}}
\DoxyCodeLine{6599 \textcolor{preprocessor}{\#define gets        \_gets\_instead\_use\_StringCbGetsA\_or\_StringCchGetsA;}}
\DoxyCodeLine{6600 }
\DoxyCodeLine{6601 \textcolor{preprocessor}{\#undef \_getws}}
\DoxyCodeLine{6602 \textcolor{preprocessor}{\#define \_getws      \_getws\_instead\_use\_StringCbGetsW\_or\_StringCchGetsW;}}
\DoxyCodeLine{6603 }
\DoxyCodeLine{6604 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !DEPRECATE\_SUPPORTED}}
\DoxyCodeLine{6605 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !STRSAFE\_NO\_DEPRECATE}}
\DoxyCodeLine{6606 }
\DoxyCodeLine{6607 \textcolor{preprocessor}{\#ifdef \_NTSTRSAFE\_H\_INCLUDED\_}}
\DoxyCodeLine{6608 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{6609 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_NTSTRSAFE\_H\_INCLUDED\_}}
\DoxyCodeLine{6610 }
\DoxyCodeLine{6611 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// \_STRSAFE\_H\_INCLUDED\_}}

\end{DoxyCode}
